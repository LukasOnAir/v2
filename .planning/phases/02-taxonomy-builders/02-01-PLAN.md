---
phase: 02-taxonomy-builders
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/taxonomy.ts
  - src/utils/hierarchicalId.ts
  - src/stores/taxonomyStore.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "TaxonomyItem type defines id, hierarchicalId, name, description, children"
    - "generateHierarchicalIds function produces 1, 1.1, 1.1.1 format IDs from tree structure"
    - "Zustand store persists risks and processes arrays to LocalStorage"
    - "Store actions allow setting full tree data with automatic ID regeneration"
  artifacts:
    - path: "src/types/taxonomy.ts"
      provides: "TaxonomyItem interface"
      exports: ["TaxonomyItem"]
    - path: "src/utils/hierarchicalId.ts"
      provides: "Hierarchical ID generation algorithm"
      exports: ["generateHierarchicalIds"]
    - path: "src/stores/taxonomyStore.ts"
      provides: "Zustand store for taxonomy state"
      exports: ["useTaxonomyStore"]
  key_links:
    - from: "src/stores/taxonomyStore.ts"
      to: "src/types/taxonomy.ts"
      via: "import TaxonomyItem type"
      pattern: "import.*TaxonomyItem.*from.*types/taxonomy"
    - from: "src/stores/taxonomyStore.ts"
      to: "src/utils/hierarchicalId.ts"
      via: "uses generateHierarchicalIds in setters"
      pattern: "generateHierarchicalIds"
---

<objective>
Set up taxonomy data infrastructure: TypeScript types, hierarchical ID generation utility, and Zustand store with immer middleware for deeply nested tree state.

Purpose: Foundation for both Risk and Process taxonomy builders. The store and types are shared between both taxonomies.
Output: `src/types/taxonomy.ts`, `src/utils/hierarchicalId.ts`, `src/stores/taxonomyStore.ts`
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-taxonomy-builders/02-RESEARCH.md

# Prior phase summary (for established patterns)
@.planning/phases/01-foundation/01-01-SUMMARY.md

# Existing store pattern to follow
@src/stores/uiStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and create types</name>
  <files>package.json, src/types/taxonomy.ts</files>
  <action>
Install required dependencies:
```bash
npm install react-arborist immer
```

Create `src/types/taxonomy.ts` with:
- `TaxonomyItem` interface with fields:
  - `id: string` (UUID for internal reference)
  - `hierarchicalId: string` (display ID like "1.2.3")
  - `name: string`
  - `description: string`
  - `children?: TaxonomyItem[]`

The type must be generic enough for both Risk and Process taxonomies (same structure).
  </action>
  <verify>
- `npm ls react-arborist immer` shows both packages installed
- `src/types/taxonomy.ts` exists and exports TaxonomyItem
- TypeScript compiles without errors: `npx tsc --noEmit`
  </verify>
  <done>TaxonomyItem type exported, dependencies installed, TypeScript validates</done>
</task>

<task type="auto">
  <name>Task 2: Create hierarchical ID utility</name>
  <files>src/utils/hierarchicalId.ts</files>
  <action>
Create `src/utils/hierarchicalId.ts` implementing the materialized path algorithm:

```typescript
// Function signature
export function generateHierarchicalIds<T extends { children?: T[] }>(
  items: T[],
  parentPath?: string
): (T & { hierarchicalId: string })[]
```

Algorithm:
1. Map over items with index
2. Position = index + 1 (1-based numbering)
3. hierarchicalId = parentPath ? `${parentPath}.${position}` : `${position}`
4. Recursively process children with new hierarchicalId as parentPath
5. Return items with hierarchicalId added to each

This function is called after ANY structure change (add, delete, move, reorder) to recalculate all IDs.

Important: This is a pure function with no side effects. It derives IDs from position, not stored values.
  </action>
  <verify>
Manual verification in code:
- Given `[{name: 'A', children: [{name: 'B'}, {name: 'C'}]}, {name: 'D'}]`
- Returns A with id "1", B with "1.1", C with "1.2", D with "2"
- TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>generateHierarchicalIds exported, produces correct 1.1.1 format IDs recursively</done>
</task>

<task type="auto">
  <name>Task 3: Create Zustand taxonomy store with immer</name>
  <files>src/stores/taxonomyStore.ts</files>
  <action>
Create `src/stores/taxonomyStore.ts` following the pattern from uiStore.ts but with immer middleware:

```typescript
import { create } from 'zustand'
import { persist, createJSONStorage } from 'zustand/middleware'
import { immer } from 'zustand/middleware/immer'
```

Store interface:
- `risks: TaxonomyItem[]` - Risk taxonomy tree
- `processes: TaxonomyItem[]` - Process taxonomy tree
- `setRisks: (items: TaxonomyItem[]) => void` - Replace entire risks tree (auto-regenerates IDs)
- `setProcesses: (items: TaxonomyItem[]) => void` - Replace entire processes tree (auto-regenerates IDs)

Implementation notes:
- Use immer middleware wrapper around persist: `persist(immer(...), options)`
- Store name: `'riskguard-taxonomy'` (separate from ui store)
- Both setters should call `generateHierarchicalIds` before setting state
- Initialize with empty arrays: `risks: []`, `processes: []`

The setters receive the full tree from react-arborist and persist with fresh IDs.
  </action>
  <verify>
- Import works: Add temporary `console.log(useTaxonomyStore.getState())` to App.tsx
- `npm run dev` starts without errors
- Browser DevTools > Application > LocalStorage shows `riskguard-taxonomy` key after any state change
- TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>Zustand store exports useTaxonomyStore, persists to LocalStorage, integrates hierarchical ID generation</done>
</task>

</tasks>

<verification>
After all tasks:
1. `npm run dev` starts without errors
2. `npx tsc --noEmit` passes (no TypeScript errors)
3. Types, utility, and store all import correctly
4. Store initializes with empty risks and processes arrays
</verification>

<success_criteria>
- TaxonomyItem type available for import
- generateHierarchicalIds utility produces correct hierarchical IDs
- useTaxonomyStore hook provides risks/processes state with persistence
- All code follows existing project patterns (@ imports, Zustand persist)
</success_criteria>

<output>
After completion, create `.planning/phases/02-taxonomy-builders/02-01-SUMMARY.md`
</output>
