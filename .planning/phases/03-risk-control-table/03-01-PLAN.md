---
phase: 03-risk-control-table
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/rct.ts
  - src/stores/rctStore.ts
  - src/utils/rctGenerator.ts
  - src/utils/heatmapColors.ts
  - src/components/rct/RCTTable.tsx
  - src/components/rct/index.ts
  - src/pages/RCTPage.tsx
  - package.json
autonomous: true

must_haves:
  truths:
    - "RCT generates rows from lowest-level risk x process combinations"
    - "Each row shows full hierarchy path (L1-L5 IDs and names)"
    - "Table renders with virtualization for performance"
    - "Rows persist after browser refresh"
  artifacts:
    - path: "src/types/rct.ts"
      provides: "RCTRow, Control, CustomColumn type definitions"
      exports: ["RCTRow", "Control", "CustomColumn"]
    - path: "src/stores/rctStore.ts"
      provides: "Zustand store for RCT state with persistence"
      exports: ["useRCTStore"]
    - path: "src/utils/rctGenerator.ts"
      provides: "Row generation from taxonomy combinations"
      exports: ["generateRCTRows", "getLeafItems"]
    - path: "src/components/rct/RCTTable.tsx"
      provides: "Main table component with TanStack Table + Virtual"
      min_lines: 80
  key_links:
    - from: "src/components/rct/RCTTable.tsx"
      to: "src/stores/rctStore.ts"
      via: "useRCTStore hook"
      pattern: "useRCTStore"
    - from: "src/utils/rctGenerator.ts"
      to: "src/stores/taxonomyStore.ts"
      via: "taxonomy data consumption"
      pattern: "TaxonomyItem"
    - from: "src/pages/RCTPage.tsx"
      to: "src/components/rct/RCTTable.tsx"
      via: "component import and render"
      pattern: "RCTTable"
---

<objective>
Build RCT core infrastructure: types, store, row generation, and table with virtualization

Purpose: Enable the Risk Control Table to auto-generate rows from taxonomy combinations and display them in a performant virtualized table. This is the foundation for scoring, controls, and filtering features.

Output: Working RCT page that shows all risk x process combinations in a scrollable virtualized table with hierarchy columns.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-risk-control-table/03-CONTEXT.md
@.planning/phases/03-risk-control-table/03-RESEARCH.md
@src/types/taxonomy.ts
@src/stores/taxonomyStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and create RCT types</name>
  <files>
    package.json
    src/types/rct.ts
  </files>
  <action>
Install TanStack Table, TanStack Virtual, hot-formula-parser, and Radix Dialog:
```bash
npm install @tanstack/react-table @tanstack/react-virtual hot-formula-parser @radix-ui/react-dialog
```

Create src/types/rct.ts with complete type definitions:

```typescript
/**
 * Control - Mitigation control for a risk-process combination
 */
export interface Control {
  id: string
  description: string
  netProbability: number | null  // 1-5
  netImpact: number | null       // 1-5
  netScore: number | null        // Calculated: probability * impact
}

/**
 * CustomColumn - User-defined column configuration
 */
export interface CustomColumn {
  id: string
  name: string
  type: 'text' | 'number' | 'dropdown' | 'date' | 'formula'
  options?: string[]    // For dropdown type
  formula?: string      // For formula type
  width?: number
}

/**
 * RCTRow - A single row in the Risk Control Table
 * Represents one lowest-level risk x lowest-level process combination
 */
export interface RCTRow {
  id: string
  // Risk hierarchy (from taxonomy)
  riskId: string
  riskL1Id: string
  riskL1Name: string
  riskL2Id: string
  riskL2Name: string
  riskL3Id: string
  riskL3Name: string
  riskL4Id: string
  riskL4Name: string
  riskL5Id: string
  riskL5Name: string
  riskName: string              // Lowest level name
  riskDescription: string
  // Process hierarchy (from taxonomy)
  processId: string
  processL1Id: string
  processL1Name: string
  processL2Id: string
  processL2Name: string
  processL3Id: string
  processL3Name: string
  processL4Id: string
  processL4Name: string
  processL5Id: string
  processL5Name: string
  processName: string           // Lowest level name
  processDescription: string
  // Scoring
  grossProbability: number | null  // 1-5
  grossImpact: number | null       // 1-5
  grossScore: number | null        // Calculated: probability * impact
  riskAppetite: number             // Default: 9
  withinAppetite: number | null    // Calculated: appetite - grossScore
  // Controls
  controls: Control[]
  hasControls: boolean             // Derived: controls.length > 0
  netScore: number | null          // From controls (lowest net score)
  // Custom columns
  customValues: Record<string, string | number | Date | null>
}
```
  </action>
  <verify>
Run `npm ls @tanstack/react-table @tanstack/react-virtual hot-formula-parser @radix-ui/react-dialog` shows all packages installed.
TypeScript compiles without errors: `npx tsc --noEmit`
  </verify>
  <done>
Dependencies installed and RCT types defined with full hierarchy support for 5 levels.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create RCT store and row generation utility</name>
  <files>
    src/stores/rctStore.ts
    src/utils/rctGenerator.ts
    src/utils/heatmapColors.ts
  </files>
  <action>
Create src/utils/rctGenerator.ts:

```typescript
import { nanoid } from 'nanoid'  // Already available via zustand
import type { TaxonomyItem } from '@/types/taxonomy'
import type { RCTRow } from '@/types/rct'

/**
 * Get all leaf (childless) items from a taxonomy tree
 */
export function getLeafItems(items: TaxonomyItem[]): TaxonomyItem[] {
  const leaves: TaxonomyItem[] = []

  function traverse(item: TaxonomyItem) {
    if (!item.children || item.children.length === 0) {
      leaves.push(item)
    } else {
      item.children.forEach(traverse)
    }
  }

  items.forEach(traverse)
  return leaves
}

/**
 * Build hierarchy path from leaf to root (L1-L5)
 * Returns object with l1-l5 properties, empty strings for unused levels
 */
function getHierarchyPath(
  leafItem: TaxonomyItem,
  allItems: TaxonomyItem[]
): { l1Id: string; l1Name: string; l2Id: string; l2Name: string; l3Id: string; l3Name: string; l4Id: string; l4Name: string; l5Id: string; l5Name: string } {
  // Parse hierarchical ID to determine path (e.g., "1.2.3" -> levels 1, 2, 3)
  const parts = leafItem.hierarchicalId.split('.')
  const result = {
    l1Id: '', l1Name: '',
    l2Id: '', l2Name: '',
    l3Id: '', l3Name: '',
    l4Id: '', l4Name: '',
    l5Id: '', l5Name: '',
  }

  // Find ancestors by building partial IDs
  for (let level = 0; level < parts.length; level++) {
    const partialId = parts.slice(0, level + 1).join('.')
    const item = findByHierarchicalId(allItems, partialId)
    if (item) {
      const key = `l${level + 1}` as 'l1' | 'l2' | 'l3' | 'l4' | 'l5'
      result[`${key}Id`] = item.hierarchicalId
      result[`${key}Name`] = item.name
    }
  }

  return result
}

/**
 * Find taxonomy item by hierarchical ID
 */
function findByHierarchicalId(items: TaxonomyItem[], hierarchicalId: string): TaxonomyItem | undefined {
  for (const item of items) {
    if (item.hierarchicalId === hierarchicalId) return item
    if (item.children) {
      const found = findByHierarchicalId(item.children, hierarchicalId)
      if (found) return found
    }
  }
  return undefined
}

/**
 * Generate RCT rows from Cartesian product of leaf risks x leaf processes
 */
export function generateRCTRows(
  risks: TaxonomyItem[],
  processes: TaxonomyItem[]
): RCTRow[] {
  const leafRisks = getLeafItems(risks)
  const leafProcesses = getLeafItems(processes)
  const rows: RCTRow[] = []

  for (const risk of leafRisks) {
    const riskPath = getHierarchyPath(risk, risks)

    for (const process of leafProcesses) {
      const processPath = getHierarchyPath(process, processes)

      rows.push({
        id: nanoid(),
        // Risk hierarchy
        riskId: risk.id,
        riskL1Id: riskPath.l1Id,
        riskL1Name: riskPath.l1Name,
        riskL2Id: riskPath.l2Id,
        riskL2Name: riskPath.l2Name,
        riskL3Id: riskPath.l3Id,
        riskL3Name: riskPath.l3Name,
        riskL4Id: riskPath.l4Id,
        riskL4Name: riskPath.l4Name,
        riskL5Id: riskPath.l5Id,
        riskL5Name: riskPath.l5Name,
        riskName: risk.name,
        riskDescription: risk.description,
        // Process hierarchy
        processId: process.id,
        processL1Id: processPath.l1Id,
        processL1Name: processPath.l1Name,
        processL2Id: processPath.l2Id,
        processL2Name: processPath.l2Name,
        processL3Id: processPath.l3Id,
        processL3Name: processPath.l3Name,
        processL4Id: processPath.l4Id,
        processL4Name: processPath.l4Name,
        processL5Id: processPath.l5Id,
        processL5Name: processPath.l5Name,
        processName: process.name,
        processDescription: process.description,
        // Scoring defaults
        grossProbability: null,
        grossImpact: null,
        grossScore: null,
        riskAppetite: 9,
        withinAppetite: null,
        // Controls
        controls: [],
        hasControls: false,
        netScore: null,
        // Custom columns
        customValues: {},
      })
    }
  }

  return rows
}
```

Create src/utils/heatmapColors.ts:

```typescript
/**
 * Heatmap color stops for risk scores (1-25)
 * Green (low risk) -> Yellow -> Orange -> Red (high risk)
 */
const HEATMAP_STOPS = [
  { score: 1, color: [34, 197, 94] },    // Green-500
  { score: 6, color: [234, 179, 8] },    // Yellow-500
  { score: 12, color: [249, 115, 22] },  // Orange-500
  { score: 25, color: [239, 68, 68] },   // Red-500
]

/**
 * Get interpolated heatmap color for a risk score
 */
export function getHeatmapColor(score: number | null): string {
  if (score === null) return 'transparent'

  // Clamp score to valid range
  const clampedScore = Math.max(1, Math.min(25, score))

  // Find surrounding stops
  let lower = HEATMAP_STOPS[0]
  let upper = HEATMAP_STOPS[HEATMAP_STOPS.length - 1]

  for (let i = 0; i < HEATMAP_STOPS.length - 1; i++) {
    if (clampedScore >= HEATMAP_STOPS[i].score && clampedScore <= HEATMAP_STOPS[i + 1].score) {
      lower = HEATMAP_STOPS[i]
      upper = HEATMAP_STOPS[i + 1]
      break
    }
  }

  // Interpolate
  const ratio = (clampedScore - lower.score) / (upper.score - lower.score)
  const r = Math.round(lower.color[0] + ratio * (upper.color[0] - lower.color[0]))
  const g = Math.round(lower.color[1] + ratio * (upper.color[1] - lower.color[1]))
  const b = Math.round(lower.color[2] + ratio * (upper.color[2] - lower.color[2]))

  return `rgb(${r}, ${g}, ${b})`
}

/**
 * Get contrasting text color for a background color
 */
export function getContrastingText(backgroundColor: string): string {
  if (backgroundColor === 'transparent') return '#a1a1aa' // text-secondary

  const match = backgroundColor.match(/\d+/g)
  if (!match) return '#fafafa' // text-primary

  const [r, g, b] = match.map(Number)
  // Luminance formula
  const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255
  return luminance > 0.5 ? '#1e293b' : '#fafafa' // Dark text on light bg, light text on dark bg
}

/**
 * Get color for "within appetite" indicator
 * Positive (within appetite) = green, Negative (exceeded) = red
 */
export function getAppetiteColor(withinAppetite: number | null): string {
  if (withinAppetite === null) return 'transparent'
  if (withinAppetite >= 0) return 'rgb(34, 197, 94)' // Green
  return 'rgb(239, 68, 68)' // Red
}
```

Create src/stores/rctStore.ts:

```typescript
import { create } from 'zustand'
import { persist, createJSONStorage } from 'zustand/middleware'
import { immer } from 'zustand/middleware/immer'
import type { RCTRow, Control, CustomColumn } from '@/types/rct'

interface RCTState {
  rows: RCTRow[]
  customColumns: CustomColumn[]
  columnVisibility: Record<string, boolean>
  columnOrder: string[]
  // Actions
  setRows: (rows: RCTRow[]) => void
  updateRow: (rowId: string, updates: Partial<RCTRow>) => void
  addControl: (rowId: string, control: Control) => void
  updateControl: (rowId: string, controlId: string, updates: Partial<Control>) => void
  removeControl: (rowId: string, controlId: string) => void
  addCustomColumn: (column: CustomColumn) => void
  removeCustomColumn: (columnId: string) => void
  setColumnVisibility: (visibility: Record<string, boolean>) => void
  setColumnOrder: (order: string[]) => void
}

export const useRCTStore = create<RCTState>()(
  persist(
    immer((set) => ({
      rows: [],
      customColumns: [],
      columnVisibility: {},
      columnOrder: [],

      setRows: (rows) => set((state) => {
        state.rows = rows
      }),

      updateRow: (rowId, updates) => set((state) => {
        const row = state.rows.find(r => r.id === rowId)
        if (row) {
          Object.assign(row, updates)
          // Recalculate derived fields
          if (row.grossProbability !== null && row.grossImpact !== null) {
            row.grossScore = row.grossProbability * row.grossImpact
            row.withinAppetite = row.riskAppetite - row.grossScore
          } else {
            row.grossScore = null
            row.withinAppetite = null
          }
        }
      }),

      addControl: (rowId, control) => set((state) => {
        const row = state.rows.find(r => r.id === rowId)
        if (row) {
          row.controls.push(control)
          row.hasControls = true
          // Recalculate net score (lowest net score from controls)
          const validScores = row.controls
            .map(c => c.netScore)
            .filter((s): s is number => s !== null)
          row.netScore = validScores.length ? Math.min(...validScores) : null
        }
      }),

      updateControl: (rowId, controlId, updates) => set((state) => {
        const row = state.rows.find(r => r.id === rowId)
        if (row) {
          const control = row.controls.find(c => c.id === controlId)
          if (control) {
            Object.assign(control, updates)
            // Recalculate control's net score
            if (control.netProbability !== null && control.netImpact !== null) {
              control.netScore = control.netProbability * control.netImpact
            } else {
              control.netScore = null
            }
            // Recalculate row's net score
            const validScores = row.controls
              .map(c => c.netScore)
              .filter((s): s is number => s !== null)
            row.netScore = validScores.length ? Math.min(...validScores) : null
          }
        }
      }),

      removeControl: (rowId, controlId) => set((state) => {
        const row = state.rows.find(r => r.id === rowId)
        if (row) {
          row.controls = row.controls.filter(c => c.id !== controlId)
          row.hasControls = row.controls.length > 0
          // Recalculate net score
          const validScores = row.controls
            .map(c => c.netScore)
            .filter((s): s is number => s !== null)
          row.netScore = validScores.length ? Math.min(...validScores) : null
        }
      }),

      addCustomColumn: (column) => set((state) => {
        state.customColumns.push(column)
        state.columnVisibility[column.id] = true
        state.columnOrder.push(column.id)
      }),

      removeCustomColumn: (columnId) => set((state) => {
        state.customColumns = state.customColumns.filter(c => c.id !== columnId)
        delete state.columnVisibility[columnId]
        state.columnOrder = state.columnOrder.filter(id => id !== columnId)
        // Remove custom values from all rows
        state.rows.forEach(row => {
          delete row.customValues[columnId]
        })
      }),

      setColumnVisibility: (visibility) => set((state) => {
        state.columnVisibility = visibility
      }),

      setColumnOrder: (order) => set((state) => {
        state.columnOrder = order
      }),
    })),
    {
      name: 'riskguard-rct',
      storage: createJSONStorage(() => localStorage),
    }
  )
)
```
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
Import paths resolve correctly in IDE.
  </verify>
  <done>
RCT store with full CRUD operations and row generation utility that creates Cartesian product rows.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create RCT table component with virtualization</name>
  <files>
    src/components/rct/RCTTable.tsx
    src/components/rct/index.ts
    src/pages/RCTPage.tsx
  </files>
  <action>
Create src/components/rct/RCTTable.tsx with TanStack Table + Virtual integration:

```typescript
import { useMemo, useRef, useCallback } from 'react'
import {
  useReactTable,
  getCoreRowModel,
  getFilteredRowModel,
  ColumnDef,
  flexRender,
} from '@tanstack/react-table'
import { useVirtualizer } from '@tanstack/react-virtual'
import { useRCTStore } from '@/stores/rctStore'
import { useTaxonomyStore } from '@/stores/taxonomyStore'
import { generateRCTRows } from '@/utils/rctGenerator'
import { getHeatmapColor, getContrastingText, getAppetiteColor } from '@/utils/heatmapColors'
import type { RCTRow } from '@/types/rct'

export function RCTTable() {
  const parentRef = useRef<HTMLDivElement>(null)
  const { rows, setRows, updateRow, columnVisibility } = useRCTStore()
  const { risks, processes } = useTaxonomyStore()

  // Check if taxonomies have leaf items
  const hasData = useMemo(() => {
    return risks.length > 0 && processes.length > 0
  }, [risks, processes])

  // Generate rows button handler
  const handleGenerateRows = useCallback(() => {
    const newRows = generateRCTRows(risks, processes)
    setRows(newRows)
  }, [risks, processes, setRows])

  // Column definitions
  const columns = useMemo<ColumnDef<RCTRow>[]>(() => [
    // Risk hierarchy columns
    { accessorKey: 'riskL1Id', header: 'Risk L1 ID', size: 80 },
    { accessorKey: 'riskL1Name', header: 'Risk L1 Name', size: 150 },
    { accessorKey: 'riskL2Id', header: 'Risk L2 ID', size: 80 },
    { accessorKey: 'riskL2Name', header: 'Risk L2 Name', size: 150 },
    { accessorKey: 'riskL3Id', header: 'Risk L3 ID', size: 80 },
    { accessorKey: 'riskL3Name', header: 'Risk L3 Name', size: 150 },
    { accessorKey: 'riskL4Id', header: 'Risk L4 ID', size: 80 },
    { accessorKey: 'riskL4Name', header: 'Risk L4 Name', size: 150 },
    { accessorKey: 'riskL5Id', header: 'Risk L5 ID', size: 80 },
    { accessorKey: 'riskL5Name', header: 'Risk L5 Name', size: 150 },
    // Process hierarchy columns
    { accessorKey: 'processL1Id', header: 'Process L1 ID', size: 80 },
    { accessorKey: 'processL1Name', header: 'Process L1 Name', size: 150 },
    { accessorKey: 'processL2Id', header: 'Process L2 ID', size: 80 },
    { accessorKey: 'processL2Name', header: 'Process L2 Name', size: 150 },
    { accessorKey: 'processL3Id', header: 'Process L3 ID', size: 80 },
    { accessorKey: 'processL3Name', header: 'Process L3 Name', size: 150 },
    { accessorKey: 'processL4Id', header: 'Process L4 ID', size: 80 },
    { accessorKey: 'processL4Name', header: 'Process L4 Name', size: 150 },
    { accessorKey: 'processL5Id', header: 'Process L5 ID', size: 80 },
    { accessorKey: 'processL5Name', header: 'Process L5 Name', size: 150 },
    // Scoring columns (placeholders - Plan 02 will add interactive cells)
    {
      accessorKey: 'grossProbability',
      header: 'Gross Prob.',
      size: 100,
      cell: ({ row }) => row.original.grossProbability ?? '-',
    },
    {
      accessorKey: 'grossImpact',
      header: 'Gross Impact',
      size: 100,
      cell: ({ row }) => row.original.grossImpact ?? '-',
    },
    {
      accessorKey: 'grossScore',
      header: 'Gross Score',
      size: 100,
      cell: ({ row }) => {
        const score = row.original.grossScore
        const bgColor = getHeatmapColor(score)
        const textColor = getContrastingText(bgColor)
        return (
          <div
            className="w-full h-full flex items-center justify-center font-medium rounded"
            style={{ backgroundColor: bgColor, color: textColor }}
          >
            {score ?? '-'}
          </div>
        )
      },
    },
    {
      accessorKey: 'riskAppetite',
      header: 'Appetite',
      size: 80,
      cell: ({ row }) => row.original.riskAppetite,
    },
    {
      accessorKey: 'withinAppetite',
      header: 'Within Appetite',
      size: 120,
      cell: ({ row }) => {
        const withinAppetite = row.original.withinAppetite
        const bgColor = getAppetiteColor(withinAppetite)
        const textColor = getContrastingText(bgColor)
        return (
          <div
            className="w-full h-full flex items-center justify-center font-medium rounded"
            style={{ backgroundColor: bgColor, color: textColor }}
          >
            {withinAppetite !== null ? (withinAppetite >= 0 ? `+${withinAppetite}` : withinAppetite) : '-'}
          </div>
        )
      },
    },
    {
      accessorKey: 'netScore',
      header: 'Net Score',
      size: 100,
      cell: ({ row }) => {
        const score = row.original.netScore
        const bgColor = getHeatmapColor(score)
        const textColor = getContrastingText(bgColor)
        return (
          <div
            className="w-full h-full flex items-center justify-center font-medium rounded"
            style={{ backgroundColor: bgColor, color: textColor }}
          >
            {score ?? '-'}
          </div>
        )
      },
    },
  ], [])

  // Table instance
  const table = useReactTable({
    data: rows,
    columns,
    state: {
      columnVisibility,
    },
    getCoreRowModel: getCoreRowModel(),
    getFilteredRowModel: getFilteredRowModel(),
  })

  // Virtualizer for rows
  const { rows: tableRows } = table.getRowModel()
  const virtualizer = useVirtualizer({
    count: tableRows.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => 48,
    overscan: 10,
  })

  // Empty state
  if (!hasData) {
    return (
      <div className="bg-surface-elevated rounded-lg p-6 border border-surface-border text-center">
        <p className="text-text-secondary mb-4">
          Build your Risk and Process taxonomies first to generate the Risk Control Table.
        </p>
        <a
          href="/taxonomy"
          className="text-accent-500 hover:text-accent-400 font-medium transition-colors"
        >
          Go to Taxonomies
        </a>
      </div>
    )
  }

  // No rows generated yet
  if (rows.length === 0) {
    return (
      <div className="bg-surface-elevated rounded-lg p-6 border border-surface-border text-center">
        <p className="text-text-secondary mb-4">
          Taxonomies are ready. Generate the Risk Control Table from your risk and process combinations.
        </p>
        <button
          onClick={handleGenerateRows}
          className="px-4 py-2 bg-accent-500 text-white rounded-lg font-medium hover:bg-accent-600 transition-colors"
        >
          Generate RCT
        </button>
      </div>
    )
  }

  return (
    <div className="flex flex-col h-full">
      {/* Toolbar placeholder - Plan 03 will add column management */}
      <div className="flex items-center gap-4 mb-4">
        <span className="text-text-secondary text-sm">
          {rows.length} rows
        </span>
        <button
          onClick={handleGenerateRows}
          className="px-3 py-1.5 text-sm bg-surface-elevated border border-surface-border rounded hover:bg-surface-overlay transition-colors"
        >
          Regenerate
        </button>
      </div>

      {/* Table container */}
      <div
        ref={parentRef}
        className="flex-1 overflow-auto border border-surface-border rounded-lg"
      >
        <table className="w-full border-collapse">
          <thead className="sticky top-0 bg-surface-elevated z-10">
            {table.getHeaderGroups().map(headerGroup => (
              <tr key={headerGroup.id}>
                {headerGroup.headers.map(header => (
                  <th
                    key={header.id}
                    className="px-3 py-2 text-left text-sm font-medium text-text-secondary border-b border-surface-border whitespace-nowrap"
                    style={{ width: header.getSize() }}
                  >
                    {header.isPlaceholder
                      ? null
                      : flexRender(header.column.columnDef.header, header.getContext())}
                  </th>
                ))}
              </tr>
            ))}
          </thead>
          <tbody
            style={{
              height: `${virtualizer.getTotalSize()}px`,
              position: 'relative',
            }}
          >
            {virtualizer.getVirtualItems().map(virtualRow => {
              const row = tableRows[virtualRow.index]
              return (
                <tr
                  key={row.id}
                  className="hover:bg-surface-overlay transition-colors"
                  style={{
                    position: 'absolute',
                    top: 0,
                    left: 0,
                    width: '100%',
                    height: `${virtualRow.size}px`,
                    transform: `translateY(${virtualRow.start}px)`,
                  }}
                >
                  {row.getVisibleCells().map(cell => (
                    <td
                      key={cell.id}
                      className="px-3 py-2 text-sm text-text-primary border-b border-surface-border whitespace-nowrap overflow-hidden text-ellipsis"
                      style={{ width: cell.column.getSize() }}
                    >
                      {flexRender(cell.column.columnDef.cell, cell.getContext())}
                    </td>
                  ))}
                </tr>
              )
            })}
          </tbody>
        </table>
      </div>
    </div>
  )
}
```

Create src/components/rct/index.ts:

```typescript
export { RCTTable } from './RCTTable'
```

Update src/pages/RCTPage.tsx:

```typescript
import { RCTTable } from '@/components/rct'

export function RCTPage() {
  return (
    <div className="flex flex-col h-full">
      <h1 className="text-2xl font-semibold text-text-primary mb-6">
        Risk Control Table
      </h1>
      <div className="flex-1 min-h-0">
        <RCTTable />
      </div>
    </div>
  )
}
```
  </action>
  <verify>
Run `npm run dev` and navigate to RCT page.
If no taxonomies: Shows "Build your taxonomies first" message with link.
If taxonomies exist but no RCT: Shows "Generate RCT" button.
After clicking Generate: Table shows all combinations with hierarchy columns.
Scroll works smoothly (virtualization).
  </verify>
  <done>
RCT table renders all risk x process combinations with virtualization. Shows hierarchy columns L1-L5 for both risk and process. Heatmap coloring for score columns (non-interactive for now).
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Dependencies installed: @tanstack/react-table, @tanstack/react-virtual, hot-formula-parser, @radix-ui/react-dialog
2. Types defined in src/types/rct.ts
3. Store working with persistence in src/stores/rctStore.ts
4. Row generation produces Cartesian product in src/utils/rctGenerator.ts
5. RCT page shows table with all hierarchy columns
6. Virtualization handles large datasets smoothly
7. Data persists after browser refresh
</verification>

<success_criteria>
- RCT generates rows from lowest-level risk x process combinations (RCT-01)
- Each row shows full hierarchy path L1-L5 (RCT-02)
- Table renders with virtualization
- Rows persist after refresh
- Heatmap colors display for score columns (non-interactive in this plan)
</success_criteria>

<output>
After completion, create `.planning/phases/03-risk-control-table/03-01-SUMMARY.md`
</output>
