---
phase: 03-risk-control-table
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/components/rct/ColumnVisibilityMenu.tsx
  - src/components/rct/ColumnFilter.tsx
  - src/components/rct/AddColumnDialog.tsx
  - src/components/rct/RCTToolbar.tsx
  - src/components/rct/RCTTable.tsx
  - src/components/rct/index.ts
  - src/utils/formulaEngine.ts
autonomous: true

must_haves:
  truths:
    - "User can show/hide any column via visibility toggle"
    - "User can filter column values via Excel-like dropdown"
    - "User can add custom columns with Text, Number, Dropdown, Date, or Formula type"
    - "Formula columns evaluate Excel-like expressions"
  artifacts:
    - path: "src/components/rct/ColumnVisibilityMenu.tsx"
      provides: "Dropdown menu for toggling column visibility"
      min_lines: 30
    - path: "src/components/rct/ColumnFilter.tsx"
      provides: "Excel-like filter dropdown with multi-select checkboxes"
      min_lines: 50
    - path: "src/components/rct/AddColumnDialog.tsx"
      provides: "Dialog for adding custom columns with type selection"
      min_lines: 80
    - path: "src/utils/formulaEngine.ts"
      provides: "Wrapper for hot-formula-parser with row value binding"
      exports: ["evaluateFormula"]
  key_links:
    - from: "src/components/rct/ColumnVisibilityMenu.tsx"
      to: "src/stores/rctStore.ts"
      via: "columnVisibility state"
      pattern: "columnVisibility"
    - from: "src/components/rct/ColumnFilter.tsx"
      to: "@tanstack/react-table"
      via: "getFacetedUniqueValues"
      pattern: "getFacetedUniqueValues"
    - from: "src/components/rct/AddColumnDialog.tsx"
      to: "src/stores/rctStore.ts"
      via: "addCustomColumn action"
      pattern: "addCustomColumn"
---

<objective>
Add column management: visibility toggles, Excel-like filters, and custom columns with formula support

Purpose: Enable users to customize the RCT view by hiding irrelevant columns, filtering data by specific values, and adding custom columns for organization-specific data capture. This completes the column management requirements.

Output: Column visibility menu, filter dropdowns on headers, and Add Column dialog supporting Text, Number, Dropdown, Date, and Formula types.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-risk-control-table/03-CONTEXT.md
@.planning/phases/03-risk-control-table/03-RESEARCH.md
@src/components/rct/RCTTable.tsx
@src/stores/rctStore.ts
@src/types/rct.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create column visibility and filter components</name>
  <files>
    src/components/rct/ColumnVisibilityMenu.tsx
    src/components/rct/ColumnFilter.tsx
    src/components/rct/index.ts
  </files>
  <action>
Create src/components/rct/ColumnVisibilityMenu.tsx:

```typescript
import { useState, useRef, useEffect } from 'react'
import { Eye, EyeOff, ChevronDown } from 'lucide-react'
import { Table } from '@tanstack/react-table'
import { clsx } from 'clsx'
import type { RCTRow } from '@/types/rct'

interface ColumnVisibilityMenuProps {
  table: Table<RCTRow>
}

export function ColumnVisibilityMenu({ table }: ColumnVisibilityMenuProps) {
  const [isOpen, setIsOpen] = useState(false)
  const menuRef = useRef<HTMLDivElement>(null)

  // Close on click outside
  useEffect(() => {
    function handleClickOutside(event: MouseEvent) {
      if (menuRef.current && !menuRef.current.contains(event.target as Node)) {
        setIsOpen(false)
      }
    }
    document.addEventListener('mousedown', handleClickOutside)
    return () => document.removeEventListener('mousedown', handleClickOutside)
  }, [])

  const allColumns = table.getAllLeafColumns()
  const visibleCount = allColumns.filter(c => c.getIsVisible()).length

  return (
    <div ref={menuRef} className="relative">
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="flex items-center gap-2 px-3 py-1.5 text-sm bg-surface-elevated border border-surface-border rounded hover:bg-surface-overlay transition-colors"
      >
        <Eye size={16} />
        <span>Columns ({visibleCount}/{allColumns.length})</span>
        <ChevronDown size={14} className={clsx('transition-transform', isOpen && 'rotate-180')} />
      </button>

      {isOpen && (
        <div className="absolute top-full left-0 mt-1 w-64 max-h-96 overflow-auto bg-surface-elevated border border-surface-border rounded-lg shadow-lg z-20">
          <div className="p-2 border-b border-surface-border">
            <button
              onClick={() => {
                allColumns.forEach(col => col.toggleVisibility(true))
              }}
              className="text-xs text-accent-500 hover:text-accent-400 mr-3"
            >
              Show all
            </button>
            <button
              onClick={() => {
                allColumns.forEach(col => col.toggleVisibility(false))
              }}
              className="text-xs text-text-muted hover:text-text-secondary"
            >
              Hide all
            </button>
          </div>

          <div className="p-2 space-y-1">
            {allColumns.map(column => {
              const isVisible = column.getIsVisible()
              return (
                <label
                  key={column.id}
                  className="flex items-center gap-2 px-2 py-1.5 rounded hover:bg-surface-overlay cursor-pointer"
                >
                  <input
                    type="checkbox"
                    checked={isVisible}
                    onChange={column.getToggleVisibilityHandler()}
                    className="w-4 h-4 rounded border-surface-border bg-surface-overlay text-accent-500 focus:ring-accent-500 focus:ring-offset-0"
                  />
                  <span className="text-sm text-text-primary truncate">
                    {typeof column.columnDef.header === 'string'
                      ? column.columnDef.header
                      : column.id}
                  </span>
                  {isVisible ? (
                    <Eye size={14} className="ml-auto text-text-muted" />
                  ) : (
                    <EyeOff size={14} className="ml-auto text-text-muted" />
                  )}
                </label>
              )
            })}
          </div>
        </div>
      )}
    </div>
  )
}
```

Create src/components/rct/ColumnFilter.tsx:

```typescript
import { useState, useRef, useEffect, useMemo } from 'react'
import { Filter, X } from 'lucide-react'
import { Column } from '@tanstack/react-table'
import { clsx } from 'clsx'
import type { RCTRow } from '@/types/rct'

interface ColumnFilterProps {
  column: Column<RCTRow>
}

export function ColumnFilter({ column }: ColumnFilterProps) {
  const [isOpen, setIsOpen] = useState(false)
  const menuRef = useRef<HTMLDivElement>(null)

  // Close on click outside
  useEffect(() => {
    function handleClickOutside(event: MouseEvent) {
      if (menuRef.current && !menuRef.current.contains(event.target as Node)) {
        setIsOpen(false)
      }
    }
    document.addEventListener('mousedown', handleClickOutside)
    return () => document.removeEventListener('mousedown', handleClickOutside)
  }, [])

  const columnFilterValue = column.getFilterValue() as string[] | undefined
  const facetedUniqueValues = column.getFacetedUniqueValues()

  // Get ALL unique values sorted
  const allUniqueValues = useMemo(() => {
    const values = Array.from(facetedUniqueValues.keys())
      .filter(v => v !== '' && v !== null && v !== undefined)
      .map(String)
      .sort()
    return values
  }, [facetedUniqueValues])

  const toggleValue = (value: string) => {
    const current = columnFilterValue ?? []
    const updated = current.includes(value)
      ? current.filter(v => v !== value)
      : [...current, value]
    column.setFilterValue(updated.length ? updated : undefined)
  }

  const clearFilter = () => {
    column.setFilterValue(undefined)
    setIsOpen(false)
  }

  const hasFilter = columnFilterValue && columnFilterValue.length > 0

  return (
    <div ref={menuRef} className="relative inline-block">
      <button
        onClick={() => setIsOpen(!isOpen)}
        className={clsx(
          'p-1 rounded hover:bg-surface-overlay transition-colors',
          hasFilter ? 'text-accent-500' : 'text-text-muted'
        )}
        title={hasFilter ? `Filtered: ${columnFilterValue.length} selected` : 'Filter'}
      >
        <Filter size={14} />
      </button>

      {isOpen && (
        <div className="absolute top-full right-0 mt-1 w-56 max-h-64 overflow-auto bg-surface-elevated border border-surface-border rounded-lg shadow-lg z-30">
          {/* Header with clear */}
          <div className="flex items-center justify-between p-2 border-b border-surface-border">
            <span className="text-xs text-text-muted">
              {allUniqueValues.length} unique values
            </span>
            {hasFilter && (
              <button
                onClick={clearFilter}
                className="flex items-center gap-1 text-xs text-red-400 hover:text-red-300"
              >
                <X size={12} />
                Clear
              </button>
            )}
          </div>

          {/* Value checkboxes */}
          <div className="p-2 space-y-1">
            {allUniqueValues.length === 0 ? (
              <p className="text-xs text-text-muted py-2 text-center">No values</p>
            ) : (
              allUniqueValues.map(value => (
                <label
                  key={value}
                  className="flex items-center gap-2 px-2 py-1 rounded hover:bg-surface-overlay cursor-pointer"
                >
                  <input
                    type="checkbox"
                    checked={columnFilterValue?.includes(value) ?? false}
                    onChange={() => toggleValue(value)}
                    className="w-4 h-4 rounded border-surface-border bg-surface-overlay text-accent-500 focus:ring-accent-500 focus:ring-offset-0"
                  />
                  <span className="text-sm text-text-primary truncate" title={value}>
                    {value || '(empty)'}
                  </span>
                </label>
              ))
            )}
          </div>
        </div>
      )}
    </div>
  )
}
```

Update src/components/rct/index.ts:

```typescript
export { RCTTable } from './RCTTable'
export { ScoreSelector, ScoreDisplay } from './ScoreSelector'
export { HeatmapCell } from './HeatmapCell'
export { ControlPanel } from './ControlPanel'
export { ColumnVisibilityMenu } from './ColumnVisibilityMenu'
export { ColumnFilter } from './ColumnFilter'
```
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>
ColumnVisibilityMenu provides checkbox list to show/hide columns. ColumnFilter provides Excel-like multi-select filter dropdown.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create formula engine and AddColumnDialog</name>
  <files>
    src/utils/formulaEngine.ts
    src/components/rct/AddColumnDialog.tsx
    src/components/rct/index.ts
  </files>
  <action>
Create src/utils/formulaEngine.ts:

```typescript
import { Parser } from 'hot-formula-parser'
import type { RCTRow, CustomColumn } from '@/types/rct'

/**
 * Evaluate a formula against a row's values
 * Supports Excel-like formulas: IF, SUM, AVG, MAX, MIN, AND, OR
 * Column references use underscore instead of spaces: Gross_Score, Risk_Appetite
 */
export function evaluateFormula(
  formula: string,
  row: RCTRow,
  customColumns: CustomColumn[]
): { result: string | number | null; error: string | null } {
  const parser = new Parser()

  // Map variable names to row values
  parser.on('callVariable', (name: string, done: (value: unknown) => void) => {
    // Built-in columns (snake_case)
    const builtInValues: Record<string, unknown> = {
      Gross_Probability: row.grossProbability,
      Gross_Impact: row.grossImpact,
      Gross_Score: row.grossScore,
      Risk_Appetite: row.riskAppetite,
      Within_Appetite: row.withinAppetite,
      Net_Score: row.netScore,
      Has_Controls: row.hasControls,
      Control_Count: row.controls.length,
    }

    if (name in builtInValues) {
      done(builtInValues[name] ?? 0)
      return
    }

    // Custom columns (normalize name to match)
    const normalizedName = name.replace(/_/g, ' ').toLowerCase()
    const customCol = customColumns.find(
      c => c.name.toLowerCase() === normalizedName ||
           c.name.replace(/\s/g, '_').toLowerCase() === name.toLowerCase()
    )

    if (customCol) {
      const value = row.customValues[customCol.id]
      done(value ?? (customCol.type === 'number' ? 0 : ''))
      return
    }

    // Unknown variable - return 0 to avoid errors
    done(0)
  })

  try {
    const parsed = parser.parse(formula)

    if (parsed.error) {
      return { result: null, error: parsed.error }
    }

    return { result: parsed.result, error: null }
  } catch (err) {
    return { result: null, error: 'Invalid formula' }
  }
}

/**
 * Validate a formula without executing it
 */
export function validateFormula(formula: string): { valid: boolean; error: string | null } {
  const parser = new Parser()

  // Provide dummy values for all variables during validation
  parser.on('callVariable', (_name: string, done: (value: unknown) => void) => {
    done(0)
  })

  try {
    const parsed = parser.parse(formula)
    return {
      valid: !parsed.error,
      error: parsed.error || null,
    }
  } catch {
    return { valid: false, error: 'Invalid formula syntax' }
  }
}
```

Create src/components/rct/AddColumnDialog.tsx:

```typescript
import { useState } from 'react'
import * as Dialog from '@radix-ui/react-dialog'
import { X, Plus, Trash2 } from 'lucide-react'
import { nanoid } from 'nanoid'
import { useRCTStore } from '@/stores/rctStore'
import { validateFormula } from '@/utils/formulaEngine'
import type { CustomColumn } from '@/types/rct'

interface AddColumnDialogProps {
  isOpen: boolean
  onClose: () => void
}

type ColumnType = CustomColumn['type']

export function AddColumnDialog({ isOpen, onClose }: AddColumnDialogProps) {
  const { addCustomColumn } = useRCTStore()

  const [name, setName] = useState('')
  const [type, setType] = useState<ColumnType>('text')
  const [dropdownOptions, setDropdownOptions] = useState<string[]>([''])
  const [formula, setFormula] = useState('')
  const [formulaError, setFormulaError] = useState<string | null>(null)

  const resetForm = () => {
    setName('')
    setType('text')
    setDropdownOptions([''])
    setFormula('')
    setFormulaError(null)
  }

  const handleClose = () => {
    resetForm()
    onClose()
  }

  const handleFormulaChange = (value: string) => {
    setFormula(value)
    if (value.trim()) {
      const validation = validateFormula(value)
      setFormulaError(validation.error)
    } else {
      setFormulaError(null)
    }
  }

  const addDropdownOption = () => {
    setDropdownOptions([...dropdownOptions, ''])
  }

  const updateDropdownOption = (index: number, value: string) => {
    const updated = [...dropdownOptions]
    updated[index] = value
    setDropdownOptions(updated)
  }

  const removeDropdownOption = (index: number) => {
    setDropdownOptions(dropdownOptions.filter((_, i) => i !== index))
  }

  const handleSubmit = () => {
    if (!name.trim()) return

    const column: CustomColumn = {
      id: nanoid(),
      name: name.trim(),
      type,
    }

    if (type === 'dropdown') {
      column.options = dropdownOptions.filter(o => o.trim())
    }

    if (type === 'formula') {
      if (!formula.trim() || formulaError) return
      column.formula = formula.trim()
    }

    addCustomColumn(column)
    handleClose()
  }

  const canSubmit = name.trim() &&
    (type !== 'formula' || (formula.trim() && !formulaError)) &&
    (type !== 'dropdown' || dropdownOptions.some(o => o.trim()))

  return (
    <Dialog.Root open={isOpen} onOpenChange={(open) => !open && handleClose()}>
      <Dialog.Portal>
        <Dialog.Overlay className="fixed inset-0 bg-black/60 z-40" />
        <Dialog.Content className="fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-[440px] bg-surface-elevated border border-surface-border rounded-lg shadow-xl z-50">
          {/* Header */}
          <div className="flex items-center justify-between p-4 border-b border-surface-border">
            <Dialog.Title className="text-lg font-semibold text-text-primary">
              Add Custom Column
            </Dialog.Title>
            <Dialog.Close asChild>
              <button className="p-2 rounded-lg hover:bg-surface-overlay transition-colors">
                <X size={20} className="text-text-secondary" />
              </button>
            </Dialog.Close>
          </div>

          {/* Form */}
          <div className="p-4 space-y-4">
            {/* Name */}
            <div>
              <label className="block text-sm font-medium text-text-secondary mb-1.5">
                Column Name
              </label>
              <input
                type="text"
                value={name}
                onChange={(e) => setName(e.target.value)}
                placeholder="e.g., Owner, Due Date, Notes..."
                className="w-full px-3 py-2 bg-surface-overlay border border-surface-border rounded-lg text-sm text-text-primary placeholder:text-text-muted focus:outline-none focus:ring-2 focus:ring-accent-500"
              />
            </div>

            {/* Type */}
            <div>
              <label className="block text-sm font-medium text-text-secondary mb-1.5">
                Column Type
              </label>
              <select
                value={type}
                onChange={(e) => setType(e.target.value as ColumnType)}
                className="w-full px-3 py-2 bg-surface-overlay border border-surface-border rounded-lg text-sm text-text-primary focus:outline-none focus:ring-2 focus:ring-accent-500"
              >
                <option value="text">Text</option>
                <option value="number">Number</option>
                <option value="dropdown">Dropdown</option>
                <option value="date">Date</option>
                <option value="formula">Formula</option>
              </select>
            </div>

            {/* Dropdown options */}
            {type === 'dropdown' && (
              <div>
                <label className="block text-sm font-medium text-text-secondary mb-1.5">
                  Options
                </label>
                <div className="space-y-2">
                  {dropdownOptions.map((option, index) => (
                    <div key={index} className="flex gap-2">
                      <input
                        type="text"
                        value={option}
                        onChange={(e) => updateDropdownOption(index, e.target.value)}
                        placeholder={`Option ${index + 1}`}
                        className="flex-1 px-3 py-2 bg-surface-overlay border border-surface-border rounded-lg text-sm text-text-primary placeholder:text-text-muted focus:outline-none focus:ring-2 focus:ring-accent-500"
                      />
                      {dropdownOptions.length > 1 && (
                        <button
                          onClick={() => removeDropdownOption(index)}
                          className="p-2 text-text-muted hover:text-red-400 transition-colors"
                        >
                          <Trash2 size={16} />
                        </button>
                      )}
                    </div>
                  ))}
                  <button
                    onClick={addDropdownOption}
                    className="flex items-center gap-1 text-sm text-accent-500 hover:text-accent-400"
                  >
                    <Plus size={14} />
                    Add option
                  </button>
                </div>
              </div>
            )}

            {/* Formula */}
            {type === 'formula' && (
              <div>
                <label className="block text-sm font-medium text-text-secondary mb-1.5">
                  Formula
                </label>
                <input
                  type="text"
                  value={formula}
                  onChange={(e) => handleFormulaChange(e.target.value)}
                  placeholder="e.g., IF(Gross_Score>15,'High','Low')"
                  className="w-full px-3 py-2 bg-surface-overlay border border-surface-border rounded-lg text-sm text-text-primary placeholder:text-text-muted focus:outline-none focus:ring-2 focus:ring-accent-500 font-mono"
                />
                {formulaError && (
                  <p className="mt-1 text-xs text-red-400">{formulaError}</p>
                )}
                <p className="mt-1.5 text-xs text-text-muted">
                  Available: Gross_Score, Gross_Probability, Gross_Impact, Risk_Appetite, Within_Appetite, Net_Score, Control_Count
                </p>
              </div>
            )}
          </div>

          {/* Footer */}
          <div className="flex justify-end gap-2 p-4 border-t border-surface-border">
            <button
              onClick={handleClose}
              className="px-4 py-2 text-sm text-text-secondary hover:text-text-primary transition-colors"
            >
              Cancel
            </button>
            <button
              onClick={handleSubmit}
              disabled={!canSubmit}
              className="px-4 py-2 bg-accent-500 text-white rounded-lg text-sm font-medium hover:bg-accent-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
            >
              Add Column
            </button>
          </div>
        </Dialog.Content>
      </Dialog.Portal>
    </Dialog.Root>
  )
}
```

Update src/components/rct/index.ts:

```typescript
export { RCTTable } from './RCTTable'
export { ScoreSelector, ScoreDisplay } from './ScoreSelector'
export { HeatmapCell } from './HeatmapCell'
export { ControlPanel } from './ControlPanel'
export { ColumnVisibilityMenu } from './ColumnVisibilityMenu'
export { ColumnFilter } from './ColumnFilter'
export { AddColumnDialog } from './AddColumnDialog'
```
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>
FormulaEngine wraps hot-formula-parser with row value binding. AddColumnDialog supports all 5 column types with validation.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create toolbar and integrate into RCTTable</name>
  <files>
    src/components/rct/RCTToolbar.tsx
    src/components/rct/RCTTable.tsx
    src/components/rct/index.ts
  </files>
  <action>
Create src/components/rct/RCTToolbar.tsx:

```typescript
import { useState } from 'react'
import { Plus, RefreshCw } from 'lucide-react'
import { Table } from '@tanstack/react-table'
import { ColumnVisibilityMenu } from './ColumnVisibilityMenu'
import { AddColumnDialog } from './AddColumnDialog'
import type { RCTRow } from '@/types/rct'

interface RCTToolbarProps {
  table: Table<RCTRow>
  rowCount: number
  filteredCount: number
  onRegenerate: () => void
}

export function RCTToolbar({ table, rowCount, filteredCount, onRegenerate }: RCTToolbarProps) {
  const [isAddColumnOpen, setIsAddColumnOpen] = useState(false)

  const hasFilters = filteredCount < rowCount

  return (
    <div className="flex items-center justify-between gap-4 mb-4">
      <div className="flex items-center gap-4">
        <span className="text-text-secondary text-sm">
          {hasFilters ? (
            <>
              <span className="text-text-primary font-medium">{filteredCount}</span>
              <span> of {rowCount} rows</span>
            </>
          ) : (
            <>{rowCount} rows</>
          )}
        </span>

        <button
          onClick={onRegenerate}
          className="flex items-center gap-1.5 px-3 py-1.5 text-sm bg-surface-elevated border border-surface-border rounded hover:bg-surface-overlay transition-colors"
        >
          <RefreshCw size={14} />
          Regenerate
        </button>
      </div>

      <div className="flex items-center gap-2">
        <ColumnVisibilityMenu table={table} />

        <button
          onClick={() => setIsAddColumnOpen(true)}
          className="flex items-center gap-1.5 px-3 py-1.5 text-sm bg-accent-500 text-white rounded hover:bg-accent-600 transition-colors"
        >
          <Plus size={14} />
          Add Column
        </button>
      </div>

      <AddColumnDialog
        isOpen={isAddColumnOpen}
        onClose={() => setIsAddColumnOpen(false)}
      />
    </div>
  )
}
```

Update src/components/rct/RCTTable.tsx to integrate toolbar, filters, and custom columns.

Full replacement of RCTTable.tsx:

```typescript
import { useMemo, useRef, useCallback, useState } from 'react'
import {
  useReactTable,
  getCoreRowModel,
  getFilteredRowModel,
  getFacetedRowModel,
  getFacetedUniqueValues,
  ColumnDef,
  ColumnFiltersState,
  flexRender,
  FilterFn,
} from '@tanstack/react-table'
import { useVirtualizer } from '@tanstack/react-virtual'
import { Settings2 } from 'lucide-react'
import { useRCTStore } from '@/stores/rctStore'
import { useTaxonomyStore } from '@/stores/taxonomyStore'
import { generateRCTRows } from '@/utils/rctGenerator'
import { evaluateFormula } from '@/utils/formulaEngine'
import { ScoreSelector } from './ScoreSelector'
import { HeatmapCell } from './HeatmapCell'
import { ControlPanel } from './ControlPanel'
import { ColumnFilter } from './ColumnFilter'
import { RCTToolbar } from './RCTToolbar'
import type { RCTRow, CustomColumn } from '@/types/rct'

// Custom filter function for multi-select
const multiSelectFilter: FilterFn<RCTRow> = (row, columnId, filterValue: string[]) => {
  if (!filterValue || filterValue.length === 0) return true
  const value = String(row.getValue(columnId) ?? '')
  return filterValue.includes(value)
}

export function RCTTable() {
  const parentRef = useRef<HTMLDivElement>(null)
  const {
    rows,
    setRows,
    updateRow,
    columnVisibility,
    setColumnVisibility,
    customColumns,
  } = useRCTStore()
  const { risks, processes } = useTaxonomyStore()

  // Filter state
  const [columnFilters, setColumnFilters] = useState<ColumnFiltersState>([])

  // Control panel state
  const [selectedRowId, setSelectedRowId] = useState<string | null>(null)
  const [isPanelOpen, setIsPanelOpen] = useState(false)

  const selectedRow = useMemo(
    () => rows.find(r => r.id === selectedRowId) ?? null,
    [rows, selectedRowId]
  )

  const openControlPanel = useCallback((rowId: string) => {
    setSelectedRowId(rowId)
    setIsPanelOpen(true)
  }, [])

  const closeControlPanel = useCallback(() => {
    setIsPanelOpen(false)
  }, [])

  // Check if taxonomies have leaf items
  const hasData = useMemo(() => {
    return risks.length > 0 && processes.length > 0
  }, [risks, processes])

  // Generate rows button handler
  const handleGenerateRows = useCallback(() => {
    const newRows = generateRCTRows(risks, processes)
    setRows(newRows)
  }, [risks, processes, setRows])

  // Handle score changes
  const handleScoreChange = useCallback((
    rowId: string,
    field: 'grossProbability' | 'grossImpact' | 'riskAppetite',
    value: number
  ) => {
    updateRow(rowId, { [field]: value })
  }, [updateRow])

  // Handle custom value changes
  const handleCustomValueChange = useCallback((
    rowId: string,
    columnId: string,
    value: string | number | Date | null
  ) => {
    const row = rows.find(r => r.id === rowId)
    if (row) {
      updateRow(rowId, {
        customValues: { ...row.customValues, [columnId]: value }
      })
    }
  }, [rows, updateRow])

  // Build custom column definitions
  const customColumnDefs = useMemo<ColumnDef<RCTRow>[]>(() => {
    return customColumns.map(col => {
      const baseColumn: ColumnDef<RCTRow> = {
        id: col.id,
        header: col.name,
        size: col.width ?? 120,
        filterFn: multiSelectFilter,
        accessorFn: (row) => {
          if (col.type === 'formula' && col.formula) {
            const result = evaluateFormula(col.formula, row, customColumns)
            return result.error ? `#ERR: ${result.error}` : result.result
          }
          return row.customValues[col.id] ?? ''
        },
      }

      // Cell renderer based on type
      switch (col.type) {
        case 'text':
          baseColumn.cell = ({ row }) => (
            <input
              type="text"
              value={(row.original.customValues[col.id] as string) ?? ''}
              onChange={(e) => handleCustomValueChange(row.original.id, col.id, e.target.value)}
              className="w-full px-2 py-1 bg-transparent border border-transparent hover:border-surface-border focus:border-accent-500 rounded text-sm text-text-primary focus:outline-none"
            />
          )
          break

        case 'number':
          baseColumn.cell = ({ row }) => (
            <input
              type="number"
              value={(row.original.customValues[col.id] as number) ?? ''}
              onChange={(e) => handleCustomValueChange(row.original.id, col.id, e.target.value ? Number(e.target.value) : null)}
              className="w-full px-2 py-1 bg-transparent border border-transparent hover:border-surface-border focus:border-accent-500 rounded text-sm text-text-primary focus:outline-none text-right"
            />
          )
          break

        case 'dropdown':
          baseColumn.cell = ({ row }) => (
            <select
              value={(row.original.customValues[col.id] as string) ?? ''}
              onChange={(e) => handleCustomValueChange(row.original.id, col.id, e.target.value || null)}
              className="w-full px-2 py-1 bg-surface-overlay border border-surface-border rounded text-sm text-text-primary focus:outline-none focus:ring-1 focus:ring-accent-500"
            >
              <option value="">-</option>
              {col.options?.map(opt => (
                <option key={opt} value={opt}>{opt}</option>
              ))}
            </select>
          )
          break

        case 'date':
          baseColumn.cell = ({ row }) => (
            <input
              type="date"
              value={(row.original.customValues[col.id] as string) ?? ''}
              onChange={(e) => handleCustomValueChange(row.original.id, col.id, e.target.value || null)}
              className="w-full px-2 py-1 bg-surface-overlay border border-surface-border rounded text-sm text-text-primary focus:outline-none focus:ring-1 focus:ring-accent-500"
            />
          )
          break

        case 'formula':
          baseColumn.cell = ({ getValue }) => {
            const value = getValue()
            const isError = typeof value === 'string' && value.startsWith('#ERR')
            return (
              <span className={isError ? 'text-red-400' : 'text-text-primary'}>
                {String(value)}
              </span>
            )
          }
          break
      }

      return baseColumn
    })
  }, [customColumns, handleCustomValueChange])

  // Column definitions with interactive cells
  const columns = useMemo<ColumnDef<RCTRow>[]>(() => [
    // Risk hierarchy columns
    { accessorKey: 'riskL1Id', header: 'Risk L1 ID', size: 80, filterFn: multiSelectFilter },
    { accessorKey: 'riskL1Name', header: 'Risk L1 Name', size: 150, filterFn: multiSelectFilter },
    { accessorKey: 'riskL2Id', header: 'Risk L2 ID', size: 80, filterFn: multiSelectFilter },
    { accessorKey: 'riskL2Name', header: 'Risk L2 Name', size: 150, filterFn: multiSelectFilter },
    { accessorKey: 'riskL3Id', header: 'Risk L3 ID', size: 80, filterFn: multiSelectFilter },
    { accessorKey: 'riskL3Name', header: 'Risk L3 Name', size: 150, filterFn: multiSelectFilter },
    { accessorKey: 'riskL4Id', header: 'Risk L4 ID', size: 80, filterFn: multiSelectFilter },
    { accessorKey: 'riskL4Name', header: 'Risk L4 Name', size: 150, filterFn: multiSelectFilter },
    { accessorKey: 'riskL5Id', header: 'Risk L5 ID', size: 80, filterFn: multiSelectFilter },
    { accessorKey: 'riskL5Name', header: 'Risk L5 Name', size: 150, filterFn: multiSelectFilter },
    // Process hierarchy columns
    { accessorKey: 'processL1Id', header: 'Process L1 ID', size: 80, filterFn: multiSelectFilter },
    { accessorKey: 'processL1Name', header: 'Process L1 Name', size: 150, filterFn: multiSelectFilter },
    { accessorKey: 'processL2Id', header: 'Process L2 ID', size: 80, filterFn: multiSelectFilter },
    { accessorKey: 'processL2Name', header: 'Process L2 Name', size: 150, filterFn: multiSelectFilter },
    { accessorKey: 'processL3Id', header: 'Process L3 ID', size: 80, filterFn: multiSelectFilter },
    { accessorKey: 'processL3Name', header: 'Process L3 Name', size: 150, filterFn: multiSelectFilter },
    { accessorKey: 'processL4Id', header: 'Process L4 ID', size: 80, filterFn: multiSelectFilter },
    { accessorKey: 'processL4Name', header: 'Process L4 Name', size: 150, filterFn: multiSelectFilter },
    { accessorKey: 'processL5Id', header: 'Process L5 ID', size: 80, filterFn: multiSelectFilter },
    { accessorKey: 'processL5Name', header: 'Process L5 Name', size: 150, filterFn: multiSelectFilter },
    // Scoring columns with interactive cells
    {
      accessorKey: 'grossProbability',
      header: 'Gross Prob.',
      size: 180,
      filterFn: multiSelectFilter,
      cell: ({ row }) => (
        <ScoreSelector
          value={row.original.grossProbability}
          onChange={(v) => handleScoreChange(row.original.id, 'grossProbability', v)}
          type="probability"
        />
      ),
    },
    {
      accessorKey: 'grossImpact',
      header: 'Gross Impact',
      size: 180,
      filterFn: multiSelectFilter,
      cell: ({ row }) => (
        <ScoreSelector
          value={row.original.grossImpact}
          onChange={(v) => handleScoreChange(row.original.id, 'grossImpact', v)}
          type="impact"
        />
      ),
    },
    {
      accessorKey: 'grossScore',
      header: 'Gross Score',
      size: 100,
      filterFn: multiSelectFilter,
      cell: ({ row }) => <HeatmapCell score={row.original.grossScore} />,
    },
    {
      accessorKey: 'riskAppetite',
      header: 'Appetite',
      size: 80,
      filterFn: multiSelectFilter,
      cell: ({ row }) => (
        <input
          type="number"
          min={1}
          max={25}
          value={row.original.riskAppetite}
          onChange={(e) => handleScoreChange(row.original.id, 'riskAppetite', Number(e.target.value))}
          className="w-16 px-2 py-1 bg-surface-overlay border border-surface-border rounded text-sm text-text-primary text-center focus:outline-none focus:ring-1 focus:ring-accent-500"
        />
      ),
    },
    {
      accessorKey: 'withinAppetite',
      header: 'Within Appetite',
      size: 120,
      filterFn: multiSelectFilter,
      cell: ({ row }) => <HeatmapCell score={row.original.withinAppetite} variant="appetite" />,
    },
    {
      accessorKey: 'netScore',
      header: 'Net Score',
      size: 100,
      filterFn: multiSelectFilter,
      cell: ({ row }) => <HeatmapCell score={row.original.netScore} />,
    },
    // Controls column
    {
      id: 'controls',
      header: 'Controls',
      size: 100,
      cell: ({ row }) => (
        <button
          onClick={() => openControlPanel(row.original.id)}
          className="flex items-center gap-1.5 px-2 py-1 text-xs rounded bg-surface-overlay hover:bg-surface-border transition-colors"
        >
          <Settings2 size={14} />
          <span>{row.original.controls.length}</span>
        </button>
      ),
    },
    // Custom columns appended at end
    ...customColumnDefs,
  ], [handleScoreChange, openControlPanel, customColumnDefs])

  // Table instance with faceted filtering
  const table = useReactTable({
    data: rows,
    columns,
    state: {
      columnVisibility,
      columnFilters,
    },
    onColumnVisibilityChange: setColumnVisibility,
    onColumnFiltersChange: setColumnFilters,
    getCoreRowModel: getCoreRowModel(),
    getFilteredRowModel: getFilteredRowModel(),
    getFacetedRowModel: getFacetedRowModel(),
    getFacetedUniqueValues: getFacetedUniqueValues(),
  })

  // Virtualizer for rows
  const { rows: tableRows } = table.getRowModel()
  const virtualizer = useVirtualizer({
    count: tableRows.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => 56,
    overscan: 10,
  })

  // Empty state - no taxonomies
  if (!hasData) {
    return (
      <div className="bg-surface-elevated rounded-lg p-6 border border-surface-border text-center">
        <p className="text-text-secondary mb-4">
          Build your Risk and Process taxonomies first to generate the Risk Control Table.
        </p>
        <a
          href="/taxonomy"
          className="text-accent-500 hover:text-accent-400 font-medium transition-colors"
        >
          Go to Taxonomies
        </a>
      </div>
    )
  }

  // No rows generated yet
  if (rows.length === 0) {
    return (
      <div className="bg-surface-elevated rounded-lg p-6 border border-surface-border text-center">
        <p className="text-text-secondary mb-4">
          Taxonomies are ready. Generate the Risk Control Table from your risk and process combinations.
        </p>
        <button
          onClick={handleGenerateRows}
          className="px-4 py-2 bg-accent-500 text-white rounded-lg font-medium hover:bg-accent-600 transition-colors"
        >
          Generate RCT
        </button>
      </div>
    )
  }

  return (
    <div className="flex flex-col h-full">
      {/* Toolbar */}
      <RCTToolbar
        table={table}
        rowCount={rows.length}
        filteredCount={tableRows.length}
        onRegenerate={handleGenerateRows}
      />

      {/* Table container */}
      <div
        ref={parentRef}
        className="flex-1 overflow-auto border border-surface-border rounded-lg"
      >
        <table className="w-full border-collapse">
          <thead className="sticky top-0 bg-surface-elevated z-10">
            {table.getHeaderGroups().map(headerGroup => (
              <tr key={headerGroup.id}>
                {headerGroup.headers.map(header => (
                  <th
                    key={header.id}
                    className="px-3 py-2 text-left text-sm font-medium text-text-secondary border-b border-surface-border whitespace-nowrap"
                    style={{ width: header.getSize() }}
                  >
                    <div className="flex items-center gap-1">
                      {header.isPlaceholder
                        ? null
                        : flexRender(header.column.columnDef.header, header.getContext())}
                      {header.column.getCanFilter() && (
                        <ColumnFilter column={header.column} />
                      )}
                    </div>
                  </th>
                ))}
              </tr>
            ))}
          </thead>
          <tbody
            style={{
              height: `${virtualizer.getTotalSize()}px`,
              position: 'relative',
            }}
          >
            {virtualizer.getVirtualItems().map(virtualRow => {
              const row = tableRows[virtualRow.index]
              return (
                <tr
                  key={row.id}
                  className="hover:bg-surface-overlay/50 transition-colors"
                  style={{
                    position: 'absolute',
                    top: 0,
                    left: 0,
                    width: '100%',
                    height: `${virtualRow.size}px`,
                    transform: `translateY(${virtualRow.start}px)`,
                  }}
                >
                  {row.getVisibleCells().map(cell => (
                    <td
                      key={cell.id}
                      className="px-3 py-2 text-sm text-text-primary border-b border-surface-border whitespace-nowrap overflow-hidden text-ellipsis"
                      style={{ width: cell.column.getSize() }}
                    >
                      {flexRender(cell.column.columnDef.cell, cell.getContext())}
                    </td>
                  ))}
                </tr>
              )
            })}
          </tbody>
        </table>
      </div>

      {/* Control Panel */}
      <ControlPanel
        isOpen={isPanelOpen}
        onClose={closeControlPanel}
        row={selectedRow}
      />
    </div>
  )
}
```

Update src/components/rct/index.ts:

```typescript
export { RCTTable } from './RCTTable'
export { ScoreSelector, ScoreDisplay } from './ScoreSelector'
export { HeatmapCell } from './HeatmapCell'
export { ControlPanel } from './ControlPanel'
export { ColumnVisibilityMenu } from './ColumnVisibilityMenu'
export { ColumnFilter } from './ColumnFilter'
export { AddColumnDialog } from './AddColumnDialog'
export { RCTToolbar } from './RCTToolbar'
```
  </action>
  <verify>
Run `npm run dev` and navigate to RCT page.
1. Column visibility: Click "Columns" button, toggle checkboxes, columns hide/show
2. Filters: Click filter icon on any column header, select values, rows filter
3. Filter indicator: Row count updates to show "X of Y rows"
4. Add Column: Click "Add Column", create Text column, appears at end
5. Add Number column, Number column: input type=number works
6. Add Dropdown column with options, Dropdown column: select works
7. Add Date column, Date column: date picker works
8. Add Formula column with `IF(Gross_Score>15,'High','Low')`, Formula column: shows calculated value
9. All changes persist after refresh
  </verify>
  <done>
Full column management: visibility toggles, Excel-like filters with multi-select, and custom columns supporting Text, Number, Dropdown, Date, and Formula types. Covers COL-01, COL-02, COL-03, COL-04.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Column visibility toggle works for all columns
2. Filter icon appears on all column headers
3. Clicking filter shows multi-select dropdown with unique values
4. Selecting filter values filters rows immediately
5. "Clear" button removes filter
6. Row count shows "X of Y rows" when filtered
7. Add Column dialog supports all 5 types
8. Custom columns render appropriate input/display for type
9. Formula columns evaluate expressions correctly
10. All settings persist after refresh
</verification>

<success_criteria>
- User can show/hide any column via visibility toggle (COL-01)
- Excel-like filter dropdown on column headers (COL-02)
- Multi-select filter values with clear option (COL-03)
- User can add custom columns with Text, Number, Dropdown, Date types (COL-04)
- Formula columns with Excel-like expressions work
</success_criteria>

<output>
After completion, create `.planning/phases/03-risk-control-table/03-03-SUMMARY.md`
</output>
