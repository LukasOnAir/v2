---
phase: 05-control-testing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/types/rct.ts
  - src/utils/testScheduling.ts
  - src/stores/rctStore.ts
  - src/hooks/usePermissions.ts
autonomous: true

must_haves:
  truths:
    - "Control interface includes testFrequency, nextTestDate, lastTestDate, testProcedure fields"
    - "ControlTest type exists with result, effectiveness, evidence, findings fields"
    - "Store has controlTests array and actions for recording/scheduling tests"
    - "Next test date calculates correctly from frequency"
  artifacts:
    - path: "src/types/rct.ts"
      provides: "TestFrequency, TestResult types; Control extension; ControlTest interface"
      contains: "TestFrequency"
    - path: "src/utils/testScheduling.ts"
      provides: "calculateNextTestDate, isTestOverdue functions"
      exports: ["calculateNextTestDate", "isTestOverdue"]
    - path: "src/stores/rctStore.ts"
      provides: "controlTests state, recordControlTest, updateControlSchedule actions"
      contains: "controlTests"
    - path: "src/hooks/usePermissions.ts"
      provides: "canRecordTestResults, canEditTestSchedule permissions"
      contains: "canRecordTestResults"
  key_links:
    - from: "src/stores/rctStore.ts"
      to: "src/utils/testScheduling.ts"
      via: "import calculateNextTestDate"
      pattern: "import.*calculateNextTestDate.*from.*testScheduling"
    - from: "src/stores/rctStore.ts"
      to: "src/types/rct.ts"
      via: "import ControlTest type"
      pattern: "import.*ControlTest.*from.*types/rct"
---

<objective>
Add control testing types, store state, and utility functions for test scheduling.

Purpose: Establish the data layer for control testing - types define structure, store persists test records, utility calculates next test dates.
Output: Extended Control interface, ControlTest type, rctStore with test actions, testScheduling utility.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-control-testing/05-RESEARCH.md

# Existing codebase (extend these)
@src/types/rct.ts
@src/stores/rctStore.ts
@src/hooks/usePermissions.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install date-fns and extend types</name>
  <files>
    - package.json
    - src/types/rct.ts
  </files>
  <action>
1. Install date-fns:
   ```bash
   npm install date-fns
   ```

2. In src/types/rct.ts, add BEFORE the Control interface:
   ```typescript
   /**
    * TestFrequency - How often a control should be tested
    */
   export type TestFrequency = 'monthly' | 'quarterly' | 'annually' | 'as-needed'

   /**
    * TestResult - Outcome of a control test
    */
   export type TestResult = 'pass' | 'fail' | 'partial' | 'not-tested'
   ```

3. Extend the Control interface by adding these fields AFTER the existing `comment` field:
   ```typescript
   // Testing schedule
   testFrequency: TestFrequency | null
   nextTestDate: string | null    // ISO date string (yyyy-MM-dd)
   lastTestDate: string | null    // ISO date string (yyyy-MM-dd)
   testProcedure?: string         // How to test this control
   ```

4. Add ControlTest interface AFTER the Control interface:
   ```typescript
   /**
    * ControlTest - Record of a single test execution
    */
   export interface ControlTest {
     id: string
     controlId: string
     rowId: string                  // Link to RCT row for context
     testDate: string               // ISO date string
     result: TestResult
     effectiveness: number | null   // 1-5 scale (optional)
     testerName?: string            // Who performed the test
     evidence?: string              // Text description, URLs, notes
     findings?: string              // Observations, issues found
     recommendations?: string       // Follow-up actions needed
   }
   ```

IMPORTANT: Keep all existing types/interfaces unchanged. Only ADD new types and EXTEND Control.
  </action>
  <verify>
    - `npm ls date-fns` shows date-fns installed
    - `npx tsc --noEmit` passes (no type errors)
  </verify>
  <done>
    - TestFrequency and TestResult types exported from rct.ts
    - Control interface has testFrequency, nextTestDate, lastTestDate, testProcedure fields
    - ControlTest interface exported from rct.ts
  </done>
</task>

<task type="auto">
  <name>Task 2: Create test scheduling utility</name>
  <files>
    - src/utils/testScheduling.ts
  </files>
  <action>
Create new file src/utils/testScheduling.ts:

```typescript
import { addMonths, addYears, format, parseISO, startOfDay, isBefore } from 'date-fns'
import type { TestFrequency } from '@/types/rct'

/**
 * Calculate the next test date based on the last test date and frequency
 */
export function calculateNextTestDate(
  lastTestDate: string,
  frequency: TestFrequency
): string {
  const date = parseISO(lastTestDate)

  switch (frequency) {
    case 'monthly':
      return format(addMonths(date, 1), 'yyyy-MM-dd')
    case 'quarterly':
      return format(addMonths(date, 3), 'yyyy-MM-dd')
    case 'annually':
      return format(addYears(date, 1), 'yyyy-MM-dd')
    case 'as-needed':
      return '' // No automatic scheduling
  }
}

/**
 * Check if a control test is overdue
 */
export function isTestOverdue(nextTestDate: string | null): boolean {
  if (!nextTestDate) return false
  const testDate = startOfDay(parseISO(nextTestDate))
  const today = startOfDay(new Date())
  return isBefore(testDate, today)
}

/**
 * Format a date string for display
 */
export function formatTestDate(dateString: string | null): string {
  if (!dateString) return 'Not scheduled'
  return format(parseISO(dateString), 'MMM d, yyyy')
}
```

Use date-fns for all date operations to avoid timezone issues and edge cases.
  </action>
  <verify>
    - File exists at src/utils/testScheduling.ts
    - `npx tsc --noEmit` passes
  </verify>
  <done>
    - calculateNextTestDate returns correct dates for monthly/quarterly/annually
    - isTestOverdue returns true when date is in the past
    - formatTestDate returns human-readable date string
  </done>
</task>

<task type="auto">
  <name>Task 3: Extend rctStore with test state and actions</name>
  <files>
    - src/stores/rctStore.ts
    - src/hooks/usePermissions.ts
  </files>
  <action>
1. In src/stores/rctStore.ts, add imports at top:
   ```typescript
   import type { RCTRow, Control, CustomColumn, ControlType, ChangeRequest, ControlTest, TestFrequency } from '@/types/rct'
   import { calculateNextTestDate } from '@/utils/testScheduling'
   import { format } from 'date-fns'
   ```

2. Extend RCTState interface (add after changeRequests):
   ```typescript
   controlTests: ControlTest[]
   // Test-related actions
   recordControlTest: (test: Omit<ControlTest, 'id'>) => void
   updateControlSchedule: (
     rowId: string,
     controlId: string,
     frequency: TestFrequency | null,
     procedure?: string
   ) => void
   getTestHistory: (controlId: string) => ControlTest[]
   ```

3. Add initial state (after changeRequests: []):
   ```typescript
   controlTests: [],
   ```

4. Add actions BEFORE the closing of immer callback:

   ```typescript
   recordControlTest: (test) => set((state) => {
     const newTest: ControlTest = {
       ...test,
       id: `test-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`,
     }
     state.controlTests.push(newTest)

     // Update control's lastTestDate and calculate nextTestDate
     const row = state.rows.find(r => r.id === test.rowId)
     if (row) {
       const control = row.controls.find(c => c.id === test.controlId)
       if (control) {
         control.lastTestDate = test.testDate
         if (control.testFrequency && control.testFrequency !== 'as-needed') {
           control.nextTestDate = calculateNextTestDate(test.testDate, control.testFrequency)
         }
       }
     }
   }),

   updateControlSchedule: (rowId, controlId, frequency, procedure) => set((state) => {
     const row = state.rows.find(r => r.id === rowId)
     if (row) {
       const control = row.controls.find(c => c.id === controlId)
       if (control) {
         control.testFrequency = frequency
         if (procedure !== undefined) {
           control.testProcedure = procedure
         }
         // If setting schedule and no lastTestDate, set nextTestDate from today
         if (frequency && frequency !== 'as-needed' && !control.lastTestDate) {
           control.nextTestDate = format(new Date(), 'yyyy-MM-dd')
         }
         // Clear nextTestDate if frequency cleared
         if (!frequency) {
           control.nextTestDate = null
         }
       }
     }
   }),

   getTestHistory: (controlId) => {
     return useRCTStore.getState().controlTests
       .filter(t => t.controlId === controlId)
       .sort((a, b) => new Date(b.testDate).getTime() - new Date(a.testDate).getTime())
   },
   ```

5. Update addControl action to initialize new fields with null:
   In the addControl action, the control object already comes from the caller. No changes needed there - the caller (ControlPanel) will need to include the new fields when creating controls.

6. Update removeControl action to cascade delete test records:
   In removeControl, add at the end of the function:
   ```typescript
   // Cascade delete test records for this control
   state.controlTests = state.controlTests.filter(t => t.controlId !== controlId)
   ```

7. In src/hooks/usePermissions.ts, add test-related permissions (before the return's closing brace):
   ```typescript
   // Test-related permissions
   canRecordTestResults: true,              // Both roles can record tests
   canEditTestSchedule: isRiskManager,      // Only Risk Manager sets schedule
   canViewTestHistory: true,                // Both roles can view
   ```

IMPORTANT:
- Handle null gracefully - existing controls won't have test fields
- Use immer's draft state pattern consistently
- Keep all existing functionality unchanged
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - `npm run dev` starts without errors
  </verify>
  <done>
    - controlTests array in store state
    - recordControlTest action creates test record and updates control dates
    - updateControlSchedule action sets frequency and procedure
    - getTestHistory returns sorted tests for a control
    - removeControl cascades to delete test records
    - usePermissions exports canRecordTestResults, canEditTestSchedule, canViewTestHistory
  </done>
</task>

</tasks>

<verification>
1. Type check passes: `npx tsc --noEmit`
2. Dev server starts: `npm run dev`
3. date-fns installed: `npm ls date-fns`
4. No console errors on page load
</verification>

<success_criteria>
- date-fns ^4.1.0 installed
- Control interface extended with testFrequency, nextTestDate, lastTestDate, testProcedure
- ControlTest interface defined with all required fields
- testScheduling.ts exports calculateNextTestDate, isTestOverdue, formatTestDate
- rctStore has controlTests state and test-related actions
- usePermissions has canRecordTestResults, canEditTestSchedule, canViewTestHistory
- All existing functionality unchanged (app still works)
</success_criteria>

<output>
After completion, create `.planning/phases/05-control-testing/05-01-SUMMARY.md`
</output>
