---
phase: 05-control-testing
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/components/rct/ControlPanel.tsx
  - src/components/rct/ControlTestSection.tsx
  - src/components/rct/ControlTestForm.tsx
autonomous: true

must_haves:
  truths:
    - "User can expand a Testing section in ControlPanel"
    - "User can set test frequency for a control (Risk Manager only)"
    - "User can record a test result with date, outcome, and evidence"
    - "User can view test history sorted by date"
    - "Overdue tests show visual indicator"
  artifacts:
    - path: "src/components/rct/ControlTestSection.tsx"
      provides: "Collapsible testing UI with schedule, history, and form"
      exports: ["ControlTestSection"]
    - path: "src/components/rct/ControlTestForm.tsx"
      provides: "Form to record a new test result"
      exports: ["ControlTestForm"]
    - path: "src/components/rct/ControlPanel.tsx"
      provides: "Integration of ControlTestSection into existing panel"
      contains: "ControlTestSection"
  key_links:
    - from: "src/components/rct/ControlPanel.tsx"
      to: "src/components/rct/ControlTestSection.tsx"
      via: "import and render"
      pattern: "import.*ControlTestSection"
    - from: "src/components/rct/ControlTestSection.tsx"
      to: "src/stores/rctStore.ts"
      via: "useRCTStore for actions"
      pattern: "useRCTStore"
    - from: "src/components/rct/ControlTestSection.tsx"
      to: "src/utils/testScheduling.ts"
      via: "date formatting and overdue check"
      pattern: "import.*from.*testScheduling"
---

<objective>
Add control testing UI components integrated into the existing ControlPanel.

Purpose: Enable users to set test schedules, record test results, and view test history through an intuitive UI that follows existing patterns.
Output: ControlTestSection and ControlTestForm components, ControlPanel integration.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-control-testing/05-RESEARCH.md
@.planning/phases/05-control-testing/05-01-SUMMARY.md

# Existing codebase
@src/components/rct/ControlPanel.tsx
@src/stores/rctStore.ts
@src/hooks/usePermissions.ts
@src/types/rct.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ControlTestForm component</name>
  <files>
    - src/components/rct/ControlTestForm.tsx
  </files>
  <action>
Create new file src/components/rct/ControlTestForm.tsx:

```typescript
import { useState } from 'react'
import { format } from 'date-fns'
import { useRCTStore } from '@/stores/rctStore'
import type { TestResult } from '@/types/rct'

const RESULT_OPTIONS: { value: TestResult; label: string; color: string }[] = [
  { value: 'pass', label: 'Pass', color: 'text-green-400' },
  { value: 'fail', label: 'Fail', color: 'text-red-400' },
  { value: 'partial', label: 'Partially Effective', color: 'text-amber-400' },
  { value: 'not-tested', label: 'Not Tested', color: 'text-text-muted' },
]

const EFFECTIVENESS_OPTIONS = [
  { value: 1, label: '1 - Ineffective' },
  { value: 2, label: '2 - Needs Improvement' },
  { value: 3, label: '3 - Adequate' },
  { value: 4, label: '4 - Good' },
  { value: 5, label: '5 - Excellent' },
]

interface ControlTestFormProps {
  rowId: string
  controlId: string
  onComplete: () => void
}

export function ControlTestForm({ rowId, controlId, onComplete }: ControlTestFormProps) {
  const recordControlTest = useRCTStore((state) => state.recordControlTest)

  const [testDate, setTestDate] = useState(format(new Date(), 'yyyy-MM-dd'))
  const [result, setResult] = useState<TestResult>('pass')
  const [effectiveness, setEffectiveness] = useState<number | ''>('')
  const [testerName, setTesterName] = useState('')
  const [evidence, setEvidence] = useState('')
  const [findings, setFindings] = useState('')
  const [recommendations, setRecommendations] = useState('')

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()

    recordControlTest({
      controlId,
      rowId,
      testDate,
      result,
      effectiveness: effectiveness === '' ? null : effectiveness,
      testerName: testerName.trim() || undefined,
      evidence: evidence.trim() || undefined,
      findings: findings.trim() || undefined,
      recommendations: recommendations.trim() || undefined,
    })

    onComplete()
  }

  return (
    <form onSubmit={handleSubmit} className="space-y-3">
      {/* Test Date */}
      <div>
        <label className="text-xs text-text-muted block mb-1">Test Date</label>
        <input
          type="date"
          value={testDate}
          onChange={(e) => setTestDate(e.target.value)}
          required
          className="w-full px-2 py-1.5 bg-surface-elevated border border-surface-border rounded text-sm text-text-primary focus:outline-none focus:ring-1 focus:ring-accent-500"
        />
      </div>

      {/* Result */}
      <div>
        <label className="text-xs text-text-muted block mb-1">Result</label>
        <select
          value={result}
          onChange={(e) => setResult(e.target.value as TestResult)}
          required
          className="w-full px-2 py-1.5 bg-surface-elevated border border-surface-border rounded text-sm text-text-primary focus:outline-none focus:ring-1 focus:ring-accent-500"
        >
          {RESULT_OPTIONS.map((opt) => (
            <option key={opt.value} value={opt.value}>
              {opt.label}
            </option>
          ))}
        </select>
      </div>

      {/* Effectiveness (optional) */}
      <div>
        <label className="text-xs text-text-muted block mb-1">Effectiveness (optional)</label>
        <select
          value={effectiveness}
          onChange={(e) => setEffectiveness(e.target.value === '' ? '' : Number(e.target.value))}
          className="w-full px-2 py-1.5 bg-surface-elevated border border-surface-border rounded text-sm text-text-primary focus:outline-none focus:ring-1 focus:ring-accent-500"
        >
          <option value="">Not rated</option>
          {EFFECTIVENESS_OPTIONS.map((opt) => (
            <option key={opt.value} value={opt.value}>
              {opt.label}
            </option>
          ))}
        </select>
      </div>

      {/* Tester Name (optional) */}
      <div>
        <label className="text-xs text-text-muted block mb-1">Tester Name (optional)</label>
        <input
          type="text"
          value={testerName}
          onChange={(e) => setTesterName(e.target.value)}
          placeholder="Who performed the test"
          className="w-full px-2 py-1.5 bg-surface-elevated border border-surface-border rounded text-sm text-text-primary placeholder:text-text-muted focus:outline-none focus:ring-1 focus:ring-accent-500"
        />
      </div>

      {/* Evidence */}
      <div>
        <label className="text-xs text-text-muted block mb-1">Evidence (optional)</label>
        <textarea
          value={evidence}
          onChange={(e) => setEvidence(e.target.value)}
          placeholder="Describe evidence or paste links..."
          rows={2}
          className="w-full px-2 py-1.5 bg-surface-elevated border border-surface-border rounded text-sm text-text-primary placeholder:text-text-muted focus:outline-none focus:ring-1 focus:ring-accent-500 resize-y min-h-[48px]"
        />
      </div>

      {/* Findings */}
      <div>
        <label className="text-xs text-text-muted block mb-1">Findings (optional)</label>
        <textarea
          value={findings}
          onChange={(e) => setFindings(e.target.value)}
          placeholder="Observations, issues found..."
          rows={2}
          className="w-full px-2 py-1.5 bg-surface-elevated border border-surface-border rounded text-sm text-text-primary placeholder:text-text-muted focus:outline-none focus:ring-1 focus:ring-accent-500 resize-y min-h-[48px]"
        />
      </div>

      {/* Recommendations */}
      <div>
        <label className="text-xs text-text-muted block mb-1">Recommendations (optional)</label>
        <textarea
          value={recommendations}
          onChange={(e) => setRecommendations(e.target.value)}
          placeholder="Follow-up actions needed..."
          rows={2}
          className="w-full px-2 py-1.5 bg-surface-elevated border border-surface-border rounded text-sm text-text-primary placeholder:text-text-muted focus:outline-none focus:ring-1 focus:ring-accent-500 resize-y min-h-[48px]"
        />
      </div>

      {/* Actions */}
      <div className="flex justify-end gap-2 pt-2">
        <button
          type="button"
          onClick={onComplete}
          className="px-3 py-1.5 text-sm text-text-secondary hover:text-text-primary transition-colors"
        >
          Cancel
        </button>
        <button
          type="submit"
          className="px-3 py-1.5 text-sm bg-accent-500 text-white rounded hover:bg-accent-600 transition-colors"
        >
          Record Test
        </button>
      </div>
    </form>
  )
}
```

The form follows existing patterns from the codebase:
- Uses same input styling as RCT custom columns
- Uses same button styling as ControlPanel
- Text-based evidence (no file uploads per research guidance)
  </action>
  <verify>
    - File exists at src/components/rct/ControlTestForm.tsx
    - `npx tsc --noEmit` passes
  </verify>
  <done>
    - ControlTestForm accepts rowId, controlId, onComplete props
    - Form has date, result, effectiveness, testerName, evidence, findings, recommendations fields
    - Submit calls recordControlTest and triggers onComplete
    - Cancel triggers onComplete without recording
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ControlTestSection component</name>
  <files>
    - src/components/rct/ControlTestSection.tsx
  </files>
  <action>
Create new file src/components/rct/ControlTestSection.tsx:

```typescript
import { useState, useMemo } from 'react'
import { ChevronDown, ChevronRight, Plus, ClipboardCheck, AlertCircle } from 'lucide-react'
import { useRCTStore } from '@/stores/rctStore'
import { usePermissions } from '@/hooks/usePermissions'
import { isTestOverdue, formatTestDate } from '@/utils/testScheduling'
import { ControlTestForm } from './ControlTestForm'
import type { Control, TestFrequency, ControlTest } from '@/types/rct'

const FREQUENCY_OPTIONS: { value: TestFrequency | ''; label: string }[] = [
  { value: '', label: 'Not scheduled' },
  { value: 'monthly', label: 'Monthly' },
  { value: 'quarterly', label: 'Quarterly' },
  { value: 'annually', label: 'Annually' },
  { value: 'as-needed', label: 'As needed' },
]

const RESULT_DISPLAY: Record<string, { label: string; color: string }> = {
  pass: { label: 'Pass', color: 'text-green-400' },
  fail: { label: 'Fail', color: 'text-red-400' },
  partial: { label: 'Partial', color: 'text-amber-400' },
  'not-tested': { label: 'Not Tested', color: 'text-text-muted' },
}

interface ControlTestSectionProps {
  rowId: string
  control: Control
}

export function ControlTestSection({ rowId, control }: ControlTestSectionProps) {
  const [isExpanded, setIsExpanded] = useState(false)
  const [showForm, setShowForm] = useState(false)

  const { updateControlSchedule, controlTests } = useRCTStore()
  const { canEditTestSchedule, canRecordTestResults } = usePermissions()

  // Get test history for this control
  const testHistory = useMemo(() => {
    return controlTests
      .filter((t) => t.controlId === control.id)
      .sort((a, b) => new Date(b.testDate).getTime() - new Date(a.testDate).getTime())
  }, [controlTests, control.id])

  const overdue = isTestOverdue(control.nextTestDate)
  const latestTest = testHistory[0]

  const handleFrequencyChange = (value: string) => {
    updateControlSchedule(
      rowId,
      control.id,
      value === '' ? null : (value as TestFrequency),
      control.testProcedure
    )
  }

  const handleProcedureChange = (value: string) => {
    updateControlSchedule(
      rowId,
      control.id,
      control.testFrequency,
      value
    )
  }

  return (
    <div className="mt-3 pt-3 border-t border-surface-border">
      {/* Header - always visible */}
      <button
        onClick={() => setIsExpanded(!isExpanded)}
        className="flex items-center gap-2 w-full text-left"
      >
        {isExpanded ? (
          <ChevronDown size={16} className="text-text-muted" />
        ) : (
          <ChevronRight size={16} className="text-text-muted" />
        )}
        <ClipboardCheck size={16} className="text-text-muted" />
        <span className="text-sm font-medium text-text-primary">Testing</span>

        {/* Quick status indicators */}
        {overdue && (
          <span className="inline-flex items-center gap-1 px-1.5 py-0.5 rounded text-xs font-medium bg-red-500/20 text-red-400">
            <AlertCircle size={12} />
            Overdue
          </span>
        )}
        {latestTest && !overdue && (
          <span className={`text-xs ${RESULT_DISPLAY[latestTest.result]?.color || 'text-text-muted'}`}>
            Last: {RESULT_DISPLAY[latestTest.result]?.label}
          </span>
        )}
      </button>

      {/* Expanded content */}
      {isExpanded && (
        <div className="mt-3 space-y-4 pl-6">
          {/* Schedule section */}
          <div className="space-y-2">
            <h5 className="text-xs font-medium text-text-muted uppercase tracking-wider">Schedule</h5>

            <div className="grid grid-cols-2 gap-3">
              <div>
                <label className="text-xs text-text-muted block mb-1">Frequency</label>
                <select
                  value={control.testFrequency ?? ''}
                  onChange={(e) => handleFrequencyChange(e.target.value)}
                  disabled={!canEditTestSchedule}
                  className="w-full px-2 py-1.5 bg-surface-elevated border border-surface-border rounded text-sm text-text-primary focus:outline-none focus:ring-1 focus:ring-accent-500 disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  {FREQUENCY_OPTIONS.map((opt) => (
                    <option key={opt.value} value={opt.value}>
                      {opt.label}
                    </option>
                  ))}
                </select>
              </div>

              <div>
                <label className="text-xs text-text-muted block mb-1">Next Test</label>
                <div className={`px-2 py-1.5 text-sm ${overdue ? 'text-red-400' : 'text-text-primary'}`}>
                  {formatTestDate(control.nextTestDate)}
                </div>
              </div>
            </div>

            {/* Test Procedure */}
            <div>
              <label className="text-xs text-text-muted block mb-1">Test Procedure</label>
              <textarea
                value={control.testProcedure ?? ''}
                onChange={(e) => handleProcedureChange(e.target.value)}
                disabled={!canEditTestSchedule}
                placeholder="How to test this control..."
                rows={2}
                className="w-full px-2 py-1.5 bg-surface-elevated border border-surface-border rounded text-sm text-text-primary placeholder:text-text-muted focus:outline-none focus:ring-1 focus:ring-accent-500 resize-y min-h-[48px] disabled:opacity-50 disabled:cursor-not-allowed"
              />
            </div>
          </div>

          {/* Record Test section */}
          {canRecordTestResults && (
            <div className="space-y-2">
              <div className="flex items-center justify-between">
                <h5 className="text-xs font-medium text-text-muted uppercase tracking-wider">Record Test</h5>
                {!showForm && (
                  <button
                    onClick={() => setShowForm(true)}
                    className="flex items-center gap-1 px-2 py-1 text-xs text-accent-400 hover:text-accent-300 transition-colors"
                  >
                    <Plus size={14} />
                    New Test
                  </button>
                )}
              </div>

              {showForm && (
                <div className="p-3 bg-surface-overlay rounded border border-surface-border">
                  <ControlTestForm
                    rowId={rowId}
                    controlId={control.id}
                    onComplete={() => setShowForm(false)}
                  />
                </div>
              )}
            </div>
          )}

          {/* Test History */}
          <div className="space-y-2">
            <h5 className="text-xs font-medium text-text-muted uppercase tracking-wider">
              Test History ({testHistory.length})
            </h5>

            {testHistory.length === 0 ? (
              <p className="text-sm text-text-muted">No tests recorded yet.</p>
            ) : (
              <div className="space-y-2 max-h-[300px] overflow-auto">
                {testHistory.map((test) => (
                  <TestHistoryItem key={test.id} test={test} />
                ))}
              </div>
            )}
          </div>
        </div>
      )}
    </div>
  )
}

function TestHistoryItem({ test }: { test: ControlTest }) {
  const [isExpanded, setIsExpanded] = useState(false)

  return (
    <div className="p-3 bg-surface-overlay rounded border border-surface-border">
      <button
        onClick={() => setIsExpanded(!isExpanded)}
        className="flex items-center justify-between w-full text-left"
      >
        <div className="flex items-center gap-2">
          <span className={`font-medium text-sm ${RESULT_DISPLAY[test.result]?.color || 'text-text-muted'}`}>
            {RESULT_DISPLAY[test.result]?.label}
          </span>
          {test.effectiveness && (
            <span className="text-xs text-text-muted">
              ({test.effectiveness}/5)
            </span>
          )}
        </div>
        <span className="text-xs text-text-muted">
          {formatTestDate(test.testDate)}
        </span>
      </button>

      {isExpanded && (
        <div className="mt-2 pt-2 border-t border-surface-border space-y-2 text-sm">
          {test.testerName && (
            <div>
              <span className="text-text-muted">Tester:</span>{' '}
              <span className="text-text-primary">{test.testerName}</span>
            </div>
          )}
          {test.evidence && (
            <div>
              <span className="text-text-muted">Evidence:</span>{' '}
              <span className="text-text-secondary">{test.evidence}</span>
            </div>
          )}
          {test.findings && (
            <div>
              <span className="text-text-muted">Findings:</span>{' '}
              <span className="text-text-secondary">{test.findings}</span>
            </div>
          )}
          {test.recommendations && (
            <div>
              <span className="text-text-muted">Recommendations:</span>{' '}
              <span className="text-text-secondary">{test.recommendations}</span>
            </div>
          )}
        </div>
      )}
    </div>
  )
}
```

Key design decisions:
- Collapsible by default to avoid UI clutter (per research pitfall 4)
- Shows quick status indicators (overdue badge, last result) when collapsed
- Schedule section: frequency dropdown, next test display, procedure textarea
- Role-based: Only Risk Manager can edit schedule, both can record tests
- Test history shows most recent first, expandable for details
  </action>
  <verify>
    - File exists at src/components/rct/ControlTestSection.tsx
    - `npx tsc --noEmit` passes
  </verify>
  <done>
    - ControlTestSection renders collapsible testing UI
    - Shows overdue badge when test is past due
    - Frequency dropdown disabled for Control Owner
    - Test procedure textarea for test instructions
    - New Test button opens ControlTestForm
    - Test history lists all tests with expandable details
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate ControlTestSection into ControlPanel</name>
  <files>
    - src/components/rct/ControlPanel.tsx
  </files>
  <action>
Modify src/components/rct/ControlPanel.tsx to include the testing section for each control:

1. Add import at top of file:
   ```typescript
   import { ControlTestSection } from './ControlTestSection'
   ```

2. Find the control card section (the div with `key={control.id}` inside the controls list map).

3. Add ControlTestSection AFTER the per-control change request section (the `{canSubmitChangeRequests && (...)}` block), but BEFORE the closing `</div>` of the control card:

   ```tsx
   {/* Control Testing Section */}
   <ControlTestSection rowId={row.id} control={control} />
   ```

The placement ensures:
- Testing section appears at the bottom of each control card
- It's inside the control-specific container
- It's after the change request UI
- It's still inside the scrollable controls list

NO other changes to ControlPanel needed. The component handles its own state and permissions.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - `npm run dev` starts without errors
    - ControlPanel renders ControlTestSection for each control
  </verify>
  <done>
    - ControlTestSection imported in ControlPanel
    - ControlTestSection rendered inside each control card
    - Existing ControlPanel functionality unchanged
  </done>
</task>

</tasks>

<verification>
1. Type check passes: `npx tsc --noEmit`
2. Dev server starts: `npm run dev`
3. Open app, navigate to RCT
4. Click "Controls" on a row that has controls
5. Verify "Testing" section appears in each control card (collapsed by default)
6. Expand Testing section, verify:
   - Frequency dropdown works (Risk Manager only can edit)
   - Test procedure textarea works
   - "New Test" button shows form
   - Form submits and appears in history
   - Overdue indicator shows when nextTestDate is past
</verification>

<success_criteria>
- ControlTestForm renders with all fields and submits correctly
- ControlTestSection shows collapsible testing UI with schedule, form, and history
- ControlPanel integrates ControlTestSection into each control card
- Role-based permissions enforced (Risk Manager for schedule, both for recording)
- Overdue badge shows when test is past due
- Test history displays sorted by date with expandable details
- All existing ControlPanel functionality preserved
</success_criteria>

<output>
After completion, create `.planning/phases/05-control-testing/05-02-SUMMARY.md`
</output>
