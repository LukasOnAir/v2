---
phase: 06-risk-sunburst-visualization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/stores/sunburstStore.ts
  - src/components/sunburst/useSunburstData.ts
  - src/components/sunburst/index.ts
autonomous: true

must_haves:
  truths:
    - "D3 hierarchy/shape/interpolate/scale modules are installed"
    - "save-svg-as-png library is installed for export"
    - "Sunburst store manages view settings and zoom state"
    - "Data hook transforms taxonomy + RCT into D3 hierarchy with aggregated scores"
  artifacts:
    - path: "src/stores/sunburstStore.ts"
      provides: "Zustand store for sunburst UI state"
      exports: ["useSunburstStore"]
    - path: "src/components/sunburst/useSunburstData.ts"
      provides: "Data transformation hook"
      exports: ["useSunburstData", "SunburstNode"]
    - path: "src/components/sunburst/index.ts"
      provides: "Barrel export"
  key_links:
    - from: "useSunburstData"
      to: "taxonomyStore"
      via: "reads risks/processes arrays"
      pattern: "useTaxonomyStore"
    - from: "useSunburstData"
      to: "rctStore"
      via: "reads rows for score aggregation"
      pattern: "useRCTStore"
---

<objective>
Install D3 dependencies and create the data foundation for the sunburst visualization.

Purpose: Establish the store for UI state and the data transformation hook that converts taxonomy + RCT data into D3-ready hierarchical structure with aggregated scores.

Output: D3 packages installed, sunburstStore.ts, useSunburstData.ts hook
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-risk-sunburst-visualization/06-CONTEXT.md
@.planning/phases/06-risk-sunburst-visualization/06-RESEARCH.md

Reference existing patterns:
@src/stores/matrixStore.ts
@src/utils/aggregation.ts
@src/types/taxonomy.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install D3 and export dependencies</name>
  <files>package.json</files>
  <action>
Install the D3 modules and export library required for sunburst visualization:

```bash
npm install d3-hierarchy d3-shape d3-interpolate d3-scale save-svg-as-png
npm install -D @types/d3-hierarchy @types/d3-shape @types/d3-interpolate @types/d3-scale
```

Note: save-svg-as-png does not have a @types package (it has inline types).

These provide:
- d3-hierarchy: partition() layout for sunburst arcs
- d3-shape: arc() generator for SVG paths
- d3-interpolate: smooth zoom transitions between arc states
- d3-scale: scale functions if needed
- save-svg-as-png: SVG to PNG export with CSS preservation
  </action>
  <verify>Run `npm ls d3-hierarchy d3-shape d3-interpolate d3-scale save-svg-as-png` and confirm all packages installed</verify>
  <done>D3 modules and save-svg-as-png are in package.json dependencies</done>
</task>

<task type="auto">
  <name>Task 2: Create sunburstStore for UI state</name>
  <files>src/stores/sunburstStore.ts</files>
  <action>
Create Zustand store following the matrixStore pattern. Store manages:

**View settings (persisted):**
- `taxonomyType: 'risk' | 'process'` - which taxonomy to visualize (default: 'risk')
- `scoreType: 'gross' | 'net'` - which score to aggregate (default: 'net')
- `aggregationMode: 'weighted' | 'max'` - weighted average or maximum (default: 'weighted')
- `visibleLevels: { l1: boolean, l2: boolean, l3: boolean, l4: boolean, l5: boolean }` - per-level visibility toggles (default: all true)
- `hideNoData: boolean` - whether to hide segments with no score (default: false)

**Zoom state (NOT persisted - transient):**
- `zoomPath: string[]` - array of node IDs from root to current center (empty = root view)
- `currentCenterId: string | null` - ID of the segment that is the current center (null = root)

**Actions:**
- `setTaxonomyType(type)`
- `setScoreType(type)`
- `setAggregationMode(mode)`
- `toggleLevel(level: 'l1' | 'l2' | 'l3' | 'l4' | 'l5')`
- `setHideNoData(hide)`
- `zoomTo(nodeId: string, path: string[])` - set new center and path
- `zoomOut()` - go up one level (pop from path)
- `resetZoom()` - return to root

Use zustand persist middleware with immer. Persist name: 'riskguard-sunburst'.
Partialize to exclude zoomPath and currentCenterId from persistence.
  </action>
  <verify>TypeScript compiles without errors: `npx tsc --noEmit`</verify>
  <done>sunburstStore exports useSunburstStore hook with all state and actions</done>
</task>

<task type="auto">
  <name>Task 3: Create useSunburstData hook for data transformation</name>
  <files>src/components/sunburst/useSunburstData.ts, src/components/sunburst/index.ts</files>
  <action>
Create the data transformation hook that converts taxonomy data into D3 hierarchy.

**SunburstNode interface:**
```typescript
export interface SunburstNode {
  id: string                    // UUID
  name: string                  // Display name
  hierarchicalId: string        // "1.2.3" format
  value: number | null          // Aggregated score (null = no data)
  level: number                 // Depth (0 = root, 1 = L1, etc.)
  children?: SunburstNode[]
}
```

**useSunburstData hook:**

Parameters: none (reads from stores)

Implementation:
1. Read taxonomyType, scoreType, aggregationMode from sunburstStore
2. Read risks/processes from taxonomyStore based on taxonomyType
3. Read rows from rctStore
4. Read weights from matrixStore (reuse existing weights)

Transform taxonomy into SunburstNode tree:
- Root node: id='root', name='Enterprise Risk' or 'Enterprise Process', hierarchicalId='', level=0
- Children are L1 nodes from taxonomy
- Recursively transform children

For leaf nodes (no children in taxonomy):
- Find matching RCT rows using matchesHierarchy from aggregation.ts
- Get score based on scoreType ('gross' -> grossScore, 'net' -> netScore)
- If multiple rows match, aggregate based on aggregationMode:
  - 'weighted': weighted average using weights from matrixStore
  - 'max': maximum score

For parent nodes:
- Use d3.hierarchy().eachAfter() to aggregate UP from children
- 'weighted': average of children's values (ignoring nulls)
- 'max': max of children's values

Return: `HierarchyNode<SunburstNode>` from d3-hierarchy

Wrap in useMemo with dependencies: [taxonomy, rows, taxonomyType, scoreType, aggregationMode, weights]

**Create index.ts barrel export:**
```typescript
export { useSunburstData, type SunburstNode } from './useSunburstData'
```
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>useSunburstData hook returns d3 HierarchyNode with aggregated scores at all levels</done>
</task>

</tasks>

<verification>
- `npm ls d3-hierarchy` shows installed version
- `npx tsc --noEmit` passes with no errors
- sunburstStore.ts exports useSunburstStore
- useSunburstData.ts exports useSunburstData and SunburstNode type
- index.ts barrel exports the hook and type
</verification>

<success_criteria>
1. D3 dependencies installed and importable
2. sunburstStore manages taxonomy type, score type, aggregation mode, level visibility, zoom state
3. useSunburstData transforms taxonomy into D3 hierarchy with proper score aggregation
4. All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-risk-sunburst-visualization/06-01-SUMMARY.md`
</output>
