---
phase: 07-weights-configuration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/stores/taxonomyStore.ts
  - src/types/taxonomy.ts
autonomous: true

must_haves:
  truths:
    - "Weight configuration state exists per taxonomy type (risk/process)"
    - "Each taxonomy has level defaults (L1-L5) and node override storage"
    - "Weight state persists across browser sessions"
    - "Default weights are 1.0 for all levels"
  artifacts:
    - path: "src/stores/taxonomyStore.ts"
      provides: "TaxonomyWeights state and weight actions"
      contains: "riskWeights"
    - path: "src/types/taxonomy.ts"
      provides: "TaxonomyWeights interface"
      contains: "TaxonomyWeights"
  key_links:
    - from: "src/stores/taxonomyStore.ts"
      to: "localStorage"
      via: "zustand persist middleware"
      pattern: "persist.*riskWeights"
---

<objective>
Add weight configuration state to taxonomyStore with per-level defaults and per-node override support.

Purpose: Enable users to configure aggregation weights that persist and can later be consumed by Matrix and Sunburst.
Output: Extended taxonomyStore with riskWeights/processWeights state, weight manipulation actions, and effective weight resolution.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-weights-configuration/07-CONTEXT.md
@.planning/phases/07-weights-configuration/07-RESEARCH.md

# Existing files to modify
@src/stores/taxonomyStore.ts
@src/types/taxonomy.ts
@src/stores/matrixStore.ts (for AggregationWeights type reference)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add TaxonomyWeights type and extend taxonomyStore state</name>
  <files>src/types/taxonomy.ts, src/stores/taxonomyStore.ts</files>
  <action>
1. In src/types/taxonomy.ts, add TaxonomyWeights interface:
```typescript
export interface TaxonomyWeights {
  /** Per-level default weights (L1-L5) */
  levelDefaults: {
    l1: number
    l2: number
    l3: number
    l4: number
    l5: number
  }
  /** Per-node weight overrides (nodeId -> weight) */
  nodeOverrides: Record<string, number>
}
```

2. In src/stores/taxonomyStore.ts, extend TaxonomyState interface with:
   - riskWeights: TaxonomyWeights
   - processWeights: TaxonomyWeights

3. Initialize state with DEFAULT_WEIGHTS:
```typescript
const DEFAULT_TAXONOMY_WEIGHTS: TaxonomyWeights = {
  levelDefaults: { l1: 1, l2: 1, l3: 1, l4: 1, l5: 1 },
  nodeOverrides: {},
}
```

4. Add to initial store state:
```typescript
riskWeights: { ...DEFAULT_TAXONOMY_WEIGHTS, nodeOverrides: {} },
processWeights: { ...DEFAULT_TAXONOMY_WEIGHTS, nodeOverrides: {} },
```

Note: Deep clone levelDefaults to avoid shared reference issues.
  </action>
  <verify>TypeScript compiles without errors: `npm run build` (or `npx tsc --noEmit`)</verify>
  <done>TaxonomyWeights type exists and store state includes riskWeights/processWeights with default values</done>
</task>

<task type="auto">
  <name>Task 2: Add weight manipulation actions to taxonomyStore</name>
  <files>src/stores/taxonomyStore.ts</files>
  <action>
Add three actions to TaxonomyState interface and implement them:

1. setLevelWeight(type: 'risk' | 'process', level: 1|2|3|4|5, weight: number): void
   - Updates the level default for the specified taxonomy type
   - Validates weight is between 0.1 and 5.0
   - Rounds to 1 decimal place
   - Implementation:
```typescript
setLevelWeight: (type, level, weight) =>
  set((state) => {
    const clampedWeight = Math.round(Math.max(0.1, Math.min(5.0, weight)) * 10) / 10
    const weightsKey = type === 'risk' ? 'riskWeights' : 'processWeights'
    const levelKey = `l${level}` as keyof TaxonomyWeights['levelDefaults']
    state[weightsKey].levelDefaults[levelKey] = clampedWeight
  }),
```

2. setNodeWeight(type: 'risk' | 'process', nodeId: string, weight: number | null): void
   - If weight is null, removes the override (reverts to level default)
   - If weight is a number, validates and sets the override
   - Implementation:
```typescript
setNodeWeight: (type, nodeId, weight) =>
  set((state) => {
    const weightsKey = type === 'risk' ? 'riskWeights' : 'processWeights'
    if (weight === null) {
      delete state[weightsKey].nodeOverrides[nodeId]
    } else {
      const clampedWeight = Math.round(Math.max(0.1, Math.min(5.0, weight)) * 10) / 10
      state[weightsKey].nodeOverrides[nodeId] = clampedWeight
    }
  }),
```

3. getEffectiveWeight(type: 'risk' | 'process', nodeId: string, level: number): number
   - Returns override if exists, otherwise returns level default
   - This is a selector, not a setter - use get() pattern
   - Implementation:
```typescript
getEffectiveWeight: (type, nodeId, level) => {
  const state = get()
  const weights = type === 'risk' ? state.riskWeights : state.processWeights
  if (nodeId in weights.nodeOverrides) {
    return weights.nodeOverrides[nodeId]
  }
  const levelKey = `l${level}` as keyof TaxonomyWeights['levelDefaults']
  return weights.levelDefaults[levelKey]
},
```

Update TaxonomyState interface to include these three action signatures.
  </action>
  <verify>TypeScript compiles without errors: `npm run build`</verify>
  <done>setLevelWeight, setNodeWeight, and getEffectiveWeight actions exist and work correctly with validation</done>
</task>

<task type="auto">
  <name>Task 3: Ensure weight persistence and cleanup orphaned overrides</name>
  <files>src/stores/taxonomyStore.ts</files>
  <action>
1. Verify persist middleware includes weights in persisted state. If using partialize, ensure riskWeights and processWeights are included:
```typescript
partialize: (state) => ({
  risks: state.risks,
  processes: state.processes,
  riskWeights: state.riskWeights,
  processWeights: state.processWeights,
}),
```

If not using partialize, weights will be persisted automatically.

2. Add cleanup logic to setRisks and setProcesses to remove orphaned node overrides. When taxonomy items are deleted, their nodeOverrides should be cleaned up:

```typescript
setRisks: (items) =>
  set((state) => {
    state.risks = generateHierarchicalIds(items)
    // Clean orphaned weight overrides
    const validIds = new Set(getAllNodeIds(state.risks))
    for (const nodeId of Object.keys(state.riskWeights.nodeOverrides)) {
      if (!validIds.has(nodeId)) {
        delete state.riskWeights.nodeOverrides[nodeId]
      }
    }
  }),
```

3. Add helper function to collect all node IDs from taxonomy tree:
```typescript
function getAllNodeIds(items: TaxonomyItem[]): string[] {
  const ids: string[] = []
  function traverse(nodes: TaxonomyItem[]) {
    for (const node of nodes) {
      ids.push(node.id)
      if (node.children) traverse(node.children)
    }
  }
  traverse(items)
  return ids
}
```

This function should be defined inside the store file (not exported).

4. Apply same cleanup logic to setProcesses for processWeights.nodeOverrides.
  </action>
  <verify>
1. Run `npm run build` to verify TypeScript compiles
2. Manually test in browser:
   - Open app, create a taxonomy item
   - Check localStorage for 'riskguard-taxonomy' - should contain riskWeights and processWeights
   - Refresh browser - weights should persist
  </verify>
  <done>Weights persist to localStorage and orphaned node overrides are cleaned up when taxonomy items are deleted</done>
</task>

</tasks>

<verification>
- `npm run build` completes without errors
- localStorage contains weight configuration after app loads
- Type definitions are correct and exported
</verification>

<success_criteria>
1. TaxonomyWeights interface exists in src/types/taxonomy.ts
2. taxonomyStore has riskWeights and processWeights state initialized to defaults (1.0)
3. setLevelWeight, setNodeWeight, getEffectiveWeight actions exist and function correctly
4. Weight state persists to localStorage
5. Orphaned node overrides are cleaned up when taxonomy items are deleted
</success_criteria>

<output>
After completion, create `.planning/phases/07-weights-configuration/07-01-SUMMARY.md`
</output>
