---
phase: 08-remediation-issue-tracking
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/rct.ts
  - src/stores/rctStore.ts
autonomous: true

must_haves:
  truths:
    - "RemediationPlan type exists with all required fields"
    - "rctStore contains remediationPlans array"
    - "Store actions allow CRUD operations on remediation plans"
    - "Priority is derived from grossScore"
  artifacts:
    - path: "src/types/rct.ts"
      provides: "RemediationPlan, ActionItem, RemediationStatus types"
      contains: "RemediationPlan"
    - path: "src/stores/rctStore.ts"
      provides: "Remediation state and actions"
      contains: "remediationPlans"
  key_links:
    - from: "src/stores/rctStore.ts"
      to: "src/types/rct.ts"
      via: "type imports"
      pattern: "import.*RemediationPlan.*from.*rct"
---

<objective>
Create remediation data layer with types and Zustand store extension

Purpose: Enable persistence and management of remediation plans linked to control test findings
Output: RemediationPlan type definition and rctStore actions for CRUD operations
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-remediation-issue-tracking/08-RESEARCH.md
@src/types/rct.ts
@src/stores/rctStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add remediation types to rct.ts</name>
  <files>src/types/rct.ts</files>
  <action>
Add the following types at the end of src/types/rct.ts:

1. RemediationStatus type:
   ```typescript
   export type RemediationStatus = 'open' | 'in-progress' | 'resolved' | 'closed'
   ```

2. ActionItem interface:
   ```typescript
   export interface ActionItem {
     id: string
     description: string
     completed: boolean
     completedDate?: string  // ISO date when marked complete
   }
   ```

3. RemediationPlan interface:
   ```typescript
   export interface RemediationPlan {
     id: string
     controlTestId: string            // Link to triggering test finding
     controlId: string                // Link to control (for context)
     rowId: string                    // Link to RCT row (for risk context)
     title: string                    // Short description of issue
     description?: string             // Detailed description
     owner: string                    // Person responsible
     deadline: string                 // ISO date string (yyyy-MM-dd)
     status: RemediationStatus
     priority: 'critical' | 'high' | 'medium' | 'low'
     actionItems: ActionItem[]
     createdDate: string              // When remediation was created
     resolvedDate?: string            // When status changed to resolved
     closedDate?: string              // When status changed to closed
     notes?: string                   // Additional notes/updates
   }
   ```

Keep existing types intact. These new types define the remediation data model as documented in the research phase.
  </action>
  <verify>TypeScript compiles without errors: `npm run build`</verify>
  <done>RemediationStatus, ActionItem, and RemediationPlan types are exported from rct.ts</done>
</task>

<task type="auto">
  <name>Task 2: Extend rctStore with remediation state and actions</name>
  <files>src/stores/rctStore.ts</files>
  <action>
Extend the existing rctStore with remediation functionality:

1. Add type imports at the top:
   ```typescript
   import type { ..., RemediationPlan, RemediationStatus, ActionItem } from '@/types/rct'
   import { nanoid } from 'nanoid'
   import { addDays, format, isBefore, startOfDay, parseISO } from 'date-fns'
   ```

2. Add helper function outside the store (before the store definition):
   ```typescript
   // Derive remediation priority from gross risk score
   function derivePriority(grossScore: number | null): RemediationPlan['priority'] {
     if (grossScore === null) return 'medium'
     if (grossScore >= 20) return 'critical'   // 20-25
     if (grossScore >= 12) return 'high'       // 12-19
     if (grossScore >= 6) return 'medium'      // 6-11
     return 'low'                               // 1-5
   }
   ```

3. Extend RCTState interface with:
   ```typescript
   remediationPlans: RemediationPlan[]

   // Remediation actions
   createRemediationPlan: (plan: Omit<RemediationPlan, 'id' | 'createdDate' | 'priority'>, grossScore: number | null) => string
   updateRemediationPlan: (planId: string, updates: Partial<RemediationPlan>) => void
   updateRemediationStatus: (planId: string, status: RemediationStatus) => void
   addActionItem: (planId: string, description: string) => void
   toggleActionItem: (planId: string, actionItemId: string) => void
   removeActionItem: (planId: string, actionItemId: string) => void
   deleteRemediationPlan: (planId: string) => void
   getRemediationForTest: (controlTestId: string) => RemediationPlan | undefined
   getRemediationForControl: (controlId: string) => RemediationPlan[]
   getOverdueRemediations: () => RemediationPlan[]
   getUpcomingRemediations: (days: number) => RemediationPlan[]
   ```

4. Add initial state:
   ```typescript
   remediationPlans: [],
   ```

5. Implement all remediation actions using immer pattern (same as existing actions):

   - createRemediationPlan: Generate ID with nanoid, set createdDate to today, derive priority from grossScore, push to array, return ID
   - updateRemediationPlan: Find by ID, Object.assign updates
   - updateRemediationStatus: Find by ID, set status, set resolvedDate/closedDate when applicable
   - addActionItem: Find plan, push new ActionItem with nanoid ID, completed: false
   - toggleActionItem: Find item, toggle completed, set completedDate if now complete
   - removeActionItem: Filter out the item from actionItems array
   - deleteRemediationPlan: Filter out from remediationPlans array
   - getRemediationForTest: Return from getState().remediationPlans.find()
   - getRemediationForControl: Return from getState().remediationPlans.filter()
   - getOverdueRemediations: Filter plans where status is open/in-progress AND deadline is before startOfDay(today)
   - getUpcomingRemediations: Filter plans where status is open/in-progress AND deadline is within N days of today

6. Also update removeControl action to cascade delete remediation plans:
   ```typescript
   // Existing: state.controlTests = state.controlTests.filter(t => t.controlId !== controlId)
   // Add: Also remove remediation plans for this control's tests
   const testIdsForControl = state.controlTests.filter(t => t.controlId === controlId).map(t => t.id)
   state.remediationPlans = state.remediationPlans.filter(p => !testIdsForControl.includes(p.controlTestId))
   ```

Important: Use nanoid for ID generation (already imported in file for other uses). Use date-fns functions for date operations (already imported for test scheduling).
  </action>
  <verify>
1. TypeScript compiles: `npm run build`
2. Start app and check localStorage key 'riskguard-rct' includes remediationPlans array in browser DevTools
  </verify>
  <done>rctStore has remediationPlans state and all CRUD actions working with proper cascade delete on control removal</done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds without TypeScript errors
2. Types are properly exported and importable
3. Store persists remediationPlans to localStorage
</verification>

<success_criteria>
- RemediationPlan, ActionItem, RemediationStatus types exist in src/types/rct.ts
- rctStore has remediationPlans array in state
- All CRUD actions (create, update, delete) work correctly
- Priority derivation from grossScore functions correctly
- Cascade delete removes remediation plans when control is deleted
</success_criteria>

<output>
After completion, create `.planning/phases/08-remediation-issue-tracking/08-01-SUMMARY.md`
</output>
