---
phase: 09-audit-trail-version-control
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/audit.ts
  - src/stores/auditStore.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Audit entry types exist and are importable"
    - "Audit store can add entries"
    - "Audit store can query entries by entity"
    - "Audit store auto-prunes to prevent localStorage overflow"
    - "Audit data persists across browser refresh"
  artifacts:
    - path: "src/types/audit.ts"
      provides: "AuditEntry, EntityType, ChangeType, FieldChange interfaces"
      exports: ["AuditEntry", "EntityType", "ChangeType", "FieldChange"]
    - path: "src/stores/auditStore.ts"
      provides: "Zustand store with audit entry CRUD and query methods"
      exports: ["useAuditStore"]
  key_links:
    - from: "src/stores/auditStore.ts"
      to: "src/types/audit.ts"
      via: "import type"
      pattern: "import.*AuditEntry.*from.*audit"
---

<objective>
Create audit trail types and storage infrastructure for tracking all data changes.

Purpose: Establish the foundation for comprehensive change logging that captures who/what/when for all entities (risks, processes, controls, RCT rows). This enables compliance tracking and change history viewing.

Output: TypeScript types for audit entries and a Zustand store with persistence, size management, and query methods.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-audit-trail-version-control/09-RESEARCH.md

# Relevant source files
@src/types/rct.ts
@src/stores/rctStore.ts
@src/stores/taxonomyStore.ts
@src/stores/uiStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create audit types</name>
  <files>src/types/audit.ts</files>
  <action>
Create TypeScript types for the audit trail system:

1. `EntityType` - Union type for tracked entities:
   - 'risk' | 'process' | 'control' | 'rctRow' | 'customColumn' | 'controlTest' | 'remediationPlan' | 'weight'

2. `ChangeType` - Union type for change operations:
   - 'create' | 'update' | 'delete'

3. `FieldChange` interface:
   - `field: string` - Field path (e.g., 'grossProbability', 'controls[0].netScore')
   - `oldValue: unknown` - Value before change (null for creates)
   - `newValue: unknown` - Value after change (null for deletes)

4. `AuditEntry` interface:
   - `id: string` - Unique identifier (nanoid)
   - `timestamp: string` - ISO 8601 format
   - `entityType: EntityType` - Type of entity changed
   - `entityId: string` - UUID of changed entity
   - `entityName?: string` - Human-readable name for display (captured at change time for historical accuracy)
   - `changeType: ChangeType` - Type of change operation
   - `fieldChanges: FieldChange[]` - Array of individual field changes
   - `user: string` - Role that made change ('risk-manager' | 'control-owner')
   - `summary?: string` - Optional human-readable summary for bulk operations

Export all types for use by auditStore and UI components.
  </action>
  <verify>Run `npx tsc --noEmit` - no type errors in audit.ts</verify>
  <done>Audit types are defined and exportable with no TypeScript errors</done>
</task>

<task type="auto">
  <name>Task 2: Create audit store with persistence and size management</name>
  <files>src/stores/auditStore.ts</files>
  <action>
Create Zustand store for audit entries with:

1. **Constants:**
   - MAX_AUDIT_ENTRIES = 10000 (approx 500KB at ~50 bytes/entry)
   - PRUNE_AMOUNT = 1000 (remove oldest when limit reached)

2. **State:**
   - `entries: AuditEntry[]` - All audit entries (newest last)

3. **Actions:**
   - `addEntry(entry: Omit<AuditEntry, 'id'>): void`
     - Generate ID with nanoid
     - Push to entries array
     - Auto-prune if exceeding MAX_AUDIT_ENTRIES (keep most recent)

   - `addBulkEntry(summary: string, entityType: EntityType, user: string): void`
     - Create summary entry for bulk operations (e.g., "Deleted risk '1.1' and 5 children")
     - No fieldChanges array needed

4. **Query Methods:**
   - `getEntriesForEntity(entityId: string): AuditEntry[]`
     - Filter by entityId, sort by timestamp descending

   - `getEntriesByDateRange(start: Date, end: Date): AuditEntry[]`
     - Filter entries within date range (inclusive), sort descending

   - `getEntriesByType(entityType: EntityType): AuditEntry[]`
     - Filter by entityType, sort descending

   - `getRecentEntries(limit: number): AuditEntry[]`
     - Get most recent N entries

5. **Persistence:**
   - Use persist middleware with immer
   - Storage name: 'riskguard-audit'
   - Use createJSONStorage(() => localStorage)

Use immer middleware for immutable updates. Follow the pattern from taxonomyStore.ts for structure.

Do NOT integrate with other stores yet - that's Plan 02.
  </action>
  <verify>
1. Run `npx tsc --noEmit` - no type errors
2. Import store in a test file and verify methods exist
  </verify>
  <done>Audit store exists with add, query, and persistence functionality. Size management auto-prunes at 10k entries.</done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: `npx tsc --noEmit`
2. Types are correctly exported from src/types/audit.ts
3. Store is correctly exported from src/stores/auditStore.ts
4. Build succeeds: `npm run build`
</verification>

<success_criteria>
- AuditEntry, EntityType, ChangeType, FieldChange types exist and compile
- useAuditStore exports addEntry, addBulkEntry, and query methods
- Store persists to localStorage under 'riskguard-audit' key
- Auto-pruning logic exists to prevent localStorage overflow
</success_criteria>

<output>
After completion, create `.planning/phases/09-audit-trail-version-control/09-01-SUMMARY.md`
</output>
