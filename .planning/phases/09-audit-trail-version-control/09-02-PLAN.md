---
phase: 09-audit-trail-version-control
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - src/stores/middleware/auditMiddleware.ts
  - src/stores/taxonomyStore.ts
  - src/stores/rctStore.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Taxonomy changes automatically create audit entries"
    - "RCT score changes automatically create audit entries"
    - "Control CRUD operations automatically create audit entries"
    - "Audit entries capture before/after values for updates"
    - "Audit entries capture current user role"
  artifacts:
    - path: "src/stores/middleware/auditMiddleware.ts"
      provides: "Reusable audit middleware for Zustand stores"
      exports: ["createAuditedAction"]
    - path: "src/stores/taxonomyStore.ts"
      provides: "Taxonomy store with audit integration"
      contains: "useAuditStore"
    - path: "src/stores/rctStore.ts"
      provides: "RCT store with audit integration"
      contains: "useAuditStore"
  key_links:
    - from: "src/stores/taxonomyStore.ts"
      to: "src/stores/auditStore.ts"
      via: "useAuditStore.getState().addEntry"
      pattern: "useAuditStore\\.getState\\(\\)"
    - from: "src/stores/rctStore.ts"
      to: "src/stores/auditStore.ts"
      via: "useAuditStore.getState().addEntry"
      pattern: "useAuditStore\\.getState\\(\\)"
---

<objective>
Integrate audit logging into existing stores to automatically capture all data changes.

Purpose: All mutations to taxonomies, RCT rows, controls, tests, and remediation plans should automatically generate audit entries without requiring manual logging calls throughout the codebase.

Output: Audit middleware utilities and integration into taxonomyStore and rctStore, so all state changes are tracked.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-audit-trail-version-control/09-RESEARCH.md
@.planning/phases/09-audit-trail-version-control/09-01-SUMMARY.md

# Relevant source files
@src/types/audit.ts
@src/stores/auditStore.ts
@src/stores/taxonomyStore.ts
@src/stores/rctStore.ts
@src/stores/uiStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create audit middleware utilities</name>
  <files>src/stores/middleware/auditMiddleware.ts</files>
  <action>
Create reusable utility for auditing store actions:

1. **Install deep-object-diff:**
   Run `npm install deep-object-diff`

2. **Create helper function `createAuditedAction`:**
   A higher-order function that wraps store setters to capture state diffs.

```typescript
import { detailedDiff } from 'deep-object-diff'
import { useAuditStore } from '@/stores/auditStore'
import { useUIStore } from '@/stores/uiStore'
import type { EntityType, FieldChange } from '@/types/audit'

interface AuditConfig {
  entityType: EntityType
  getEntityId: (state: any, prevState: any) => string
  getEntityName?: (state: any, prevState: any) => string
  inferChangeType?: (diff: any) => 'create' | 'update' | 'delete'
  excludeFields?: string[]  // Fields to ignore (e.g., computed fields)
}
```

3. **Helper functions:**
   - `diffToFieldChanges(diff: any, excludeFields: string[]): FieldChange[]`
     - Convert detailedDiff output to FieldChange array
     - Filter out excluded fields (computed: grossScore, netScore, withinAppetite)
     - Handle nested paths (e.g., 'controls[0].description')

   - `hasSignificantChanges(fieldChanges: FieldChange[]): boolean`
     - Return true if any non-excluded fields changed

   - `getCurrentUser(): string`
     - Return useUIStore.getState().selectedRole

4. **Key insight from research:**
   - Capture prevState BEFORE calling the original setter
   - Call original setter
   - Capture nextState AFTER
   - Compute diff and log if significant

IMPORTANT: Do NOT create a true Zustand middleware (wraps entire store). Instead, create utility functions that individual store actions can call. This gives more control over what gets logged.

Export: createAuditedAction, diffToFieldChanges, hasSignificantChanges, getCurrentUser
  </action>
  <verify>
1. `npm install deep-object-diff` succeeds
2. `npx tsc --noEmit` compiles without errors
3. Functions are exported correctly
  </verify>
  <done>Audit utilities exist for computing diffs and creating field change arrays</done>
</task>

<task type="auto">
  <name>Task 2: Integrate audit logging into taxonomyStore and rctStore</name>
  <files>src/stores/taxonomyStore.ts, src/stores/rctStore.ts</files>
  <action>
Add audit logging to key mutations in both stores.

**taxonomyStore.ts changes:**

1. Import audit utilities:
   ```typescript
   import { useAuditStore } from '@/stores/auditStore'
   import { useUIStore } from '@/stores/uiStore'
   import type { FieldChange } from '@/types/audit'
   ```

2. Wrap `setRisks` and `setProcesses` to log taxonomy changes:
   - Before mutation: snapshot current state
   - After mutation: compare to find added/removed/updated items
   - Log 'create' for new items, 'delete' for removed, 'update' for changed names/descriptions
   - Use addBulkEntry for cascading deletes (e.g., "Deleted risk '1.1' and 3 children")

3. Wrap `setLevelWeight` and `setNodeWeight`:
   - Log as 'weight' entityType
   - Capture old/new weight values

**rctStore.ts changes:**

1. Import audit utilities and useAuditStore

2. Wrap these actions to capture changes:
   - `updateRow` - Log RCT row score changes (grossProbability, grossImpact, riskAppetite, comments)
     - Exclude computed fields: grossScore, netScore, withinAppetite
   - `addControl` - Log control creation
   - `updateControl` - Log control updates (exclude computed netScore)
   - `removeControl` - Log control deletion
   - `addCustomColumn` / `removeCustomColumn` / `updateCustomColumn` - Log column changes
   - `recordControlTest` - Log test recording
   - `createRemediationPlan` / `updateRemediationPlan` / `updateRemediationStatus` / `deleteRemediationPlan` - Log remediation changes

3. For each action:
   - Get user from useUIStore.getState().selectedRole
   - Get timestamp as new Date().toISOString()
   - Build fieldChanges array showing old/new values
   - Call useAuditStore.getState().addEntry(...)

**Exclude from logging:**
- Column visibility changes (UI preference, not data)
- Column order changes (UI preference)
- Score label changes (configuration, rarely tracked)

**Pattern for integrating:**
```typescript
updateRow: (rowId, updates) => set((state) => {
  const row = state.rows.find(r => r.id === rowId)
  if (!row) return

  // Capture before values for changed fields
  const fieldChanges: FieldChange[] = []
  const trackedFields = ['grossProbability', 'grossImpact', 'riskAppetite', 'grossProbabilityComment', 'grossImpactComment']
  for (const field of trackedFields) {
    if (field in updates && updates[field] !== row[field]) {
      fieldChanges.push({ field, oldValue: row[field], newValue: updates[field] })
    }
  }

  // Apply updates
  Object.assign(row, updates)
  // ... recalculate derived fields ...

  // Log if significant changes
  if (fieldChanges.length > 0) {
    useAuditStore.getState().addEntry({
      timestamp: new Date().toISOString(),
      entityType: 'rctRow',
      entityId: rowId,
      entityName: `${row.riskName} x ${row.processName}`,
      changeType: 'update',
      fieldChanges,
      user: useUIStore.getState().selectedRole,
    })
  }
})
```
  </action>
  <verify>
1. `npx tsc --noEmit` compiles without errors
2. `npm run build` succeeds
3. Make a test change in the UI (e.g., edit a score) and verify audit entry is created:
   - Check localStorage key 'riskguard-audit' for entries
  </verify>
  <done>All key store mutations automatically create audit entries with before/after values</done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: `npx tsc --noEmit`
2. Build succeeds: `npm run build`
3. Manual test: Edit a score in RCT, check that localStorage 'riskguard-audit' has an entry
4. Manual test: Add a taxonomy item, check audit entry is created
</verification>

<success_criteria>
- deep-object-diff is installed
- Audit middleware utilities exist in src/stores/middleware/
- taxonomyStore logs risk/process changes
- rctStore logs row, control, test, and remediation changes
- Audit entries include user role from uiStore
- Computed fields are excluded from logging
</success_criteria>

<output>
After completion, create `.planning/phases/09-audit-trail-version-control/09-02-SUMMARY.md`
</output>
