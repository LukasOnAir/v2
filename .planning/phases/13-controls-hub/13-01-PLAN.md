---
phase: 13-controls-hub
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/rct.ts
  - src/stores/controlsStore.ts
autonomous: true

must_haves:
  truths:
    - "ControlLink type enables many-to-many relationship between controls and RCT rows"
    - "controlsStore holds all controls as first-class entities"
    - "Controls can be queried by ID or by linked row"
    - "Links can be queried by control or by row"
    - "Store persists to localStorage"
  artifacts:
    - path: "src/types/rct.ts"
      provides: "ControlLink interface for many-to-many linking"
      contains: "interface ControlLink"
    - path: "src/stores/controlsStore.ts"
      provides: "Zustand store for controls and control links"
      exports: ["useControlsStore"]
  key_links:
    - from: "src/stores/controlsStore.ts"
      to: "src/types/rct.ts"
      via: "import Control, ControlLink types"
      pattern: "import.*Control.*ControlLink.*from.*@/types/rct"
---

<objective>
Create ControlLink type and controlsStore with first-class control entities.

Purpose: Transform controls from embedded arrays within RCT rows to first-class entities that can be linked to multiple rows. This is the foundation for the Controls Hub feature.

Output: ControlLink type in rct.ts, controlsStore with controls[], controlLinks[], and full CRUD operations.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/13-controls-hub/13-RESEARCH.md

@src/types/rct.ts
@src/stores/rctStore.ts
@src/stores/auditStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ControlLink interface to types</name>
  <files>src/types/rct.ts</files>
  <action>
Add the ControlLink interface to src/types/rct.ts. Place it after the Control interface.

```typescript
/**
 * ControlLink - Links a control to an RCT row (many-to-many junction)
 * Allows one control to cover multiple risk-process combinations
 */
export interface ControlLink {
  id: string
  controlId: string           // Reference to Control
  rowId: string               // Reference to RCTRow
  // Per-link score overrides (row-specific effectiveness)
  netProbability?: number | null
  netImpact?: number | null
  netScore?: number | null    // Computed from above if present
  createdAt: string           // ISO date string
}
```

This junction table pattern enables:
1. One control linked to many rows (control covers multiple risks)
2. One row linked to many controls (risk has multiple controls)
3. Optional per-link score overrides (same control may be more effective for certain risks)
  </action>
  <verify>Run `npx tsc --noEmit` and confirm no type errors.</verify>
  <done>ControlLink interface exists in src/types/rct.ts with id, controlId, rowId, optional score overrides, and createdAt.</done>
</task>

<task type="auto">
  <name>Task 2: Create controlsStore</name>
  <files>src/stores/controlsStore.ts</files>
  <action>
Create src/stores/controlsStore.ts following the pattern from rctStore.ts and auditStore.ts:

**State interface (ControlsState):**
```typescript
interface ControlsState {
  controls: Control[]
  controlLinks: ControlLink[]
  migrationVersion: number  // Track migration state (0 = not migrated, 1 = migrated)

  // Control CRUD
  addControl: (control: Omit<Control, 'id'>) => string
  updateControl: (controlId: string, updates: Partial<Control>) => void
  removeControl: (controlId: string) => void
  getControlById: (controlId: string) => Control | undefined

  // Link CRUD
  linkControl: (controlId: string, rowId: string) => string
  unlinkControl: (linkId: string) => void
  unlinkControlFromRow: (controlId: string, rowId: string) => void
  updateLink: (linkId: string, updates: Partial<ControlLink>) => void

  // Queries
  getControlsForRow: (rowId: string) => Control[]
  getLinksForRow: (rowId: string) => ControlLink[]
  getLinksForControl: (controlId: string) => ControlLink[]
  getRowIdsForControl: (controlId: string) => string[]

  // Migration
  setMigrationVersion: (version: number) => void
  importControls: (controls: Control[], links: ControlLink[]) => void
}
```

**Implementation details:**

1. **addControl:**
   - Generate ID with nanoid()
   - Push control to controls array
   - Log to auditStore with entityType: 'control', changeType: 'create'
   - Return generated ID

2. **updateControl:**
   - Find control by ID
   - Track field changes for audit (name, description, controlType, netProbability, netImpact, testFrequency, testProcedure)
   - Apply updates with Object.assign
   - Recalculate netScore if probability/impact changed
   - Log to auditStore if tracked fields changed

3. **removeControl:**
   - Find control for audit logging
   - Remove control from controls array
   - Remove all links for this control from controlLinks array
   - Log to auditStore with changeType: 'delete'

4. **linkControl:**
   - Generate link ID with nanoid()
   - Create ControlLink with controlId, rowId, createdAt: new Date().toISOString()
   - Push to controlLinks array
   - Log to auditStore with entityType: 'controlLink', changeType: 'create'
   - Return link ID

5. **unlinkControl:**
   - Find link by ID
   - Remove from controlLinks array
   - Log to auditStore with changeType: 'delete'

6. **unlinkControlFromRow:**
   - Find link by controlId AND rowId
   - If found, call unlinkControl with that link's ID

7. **Query methods:**
   - getControlsForRow: Filter controlLinks by rowId, map to controls
   - getLinksForRow: Filter controlLinks by rowId
   - getLinksForControl: Filter controlLinks by controlId
   - getRowIdsForControl: Filter controlLinks by controlId, map to rowId

8. **importControls:**
   - Set state.controls = controls
   - Set state.controlLinks = links
   - Used by migration logic

**Store setup:**
- Use create from zustand
- Wrap with persist middleware (name: 'riskguard-controls')
- Wrap with immer middleware for nested updates
- Use createJSONStorage(() => localStorage)

Export useControlsStore hook.
  </action>
  <verify>
1. Run `npx tsc --noEmit` and confirm no type errors.
2. Verify store imports Control and ControlLink from @/types/rct.
3. Verify store imports useAuditStore from @/stores/auditStore.
4. Verify store imports useUIStore from @/stores/uiStore (for role in audit entries).
  </verify>
  <done>controlsStore exports useControlsStore with full CRUD for controls and links, audit logging, and persistence to 'riskguard-controls' key.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. ControlLink interface exists in src/types/rct.ts
3. controlsStore.ts exports useControlsStore
4. Store has controls[], controlLinks[], migrationVersion in state
5. Store has addControl, updateControl, removeControl, linkControl, unlinkControl
6. Store has getControlsForRow, getLinksForRow, getLinksForControl
7. Audit logging integrated for CRUD operations
</verification>

<success_criteria>
- ControlLink interface has id, controlId, rowId, optional score overrides, createdAt
- controlsStore persists to 'riskguard-controls' key in localStorage
- addControl generates ID with nanoid and returns it
- removeControl also removes all associated links
- linkControl creates ControlLink with timestamp
- Query methods return correct filtered results
- All CRUD operations log to auditStore
</success_criteria>

<output>
After completion, create `.planning/phases/13-controls-hub/13-01-SUMMARY.md`
</output>
