---
phase: 13-controls-hub
plan: 02
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - src/stores/rctStore.ts
  - src/utils/controlMigration.ts
  - src/App.tsx
autonomous: true

must_haves:
  truths:
    - "Existing embedded controls are migrated to controlsStore on app load"
    - "Migration preserves control IDs to maintain test history references"
    - "Migration runs only once (tracked by migrationVersion)"
    - "rctStore netScore calculation reads from controlsStore links"
    - "Migration creates links for each row-control relationship"
  artifacts:
    - path: "src/utils/controlMigration.ts"
      provides: "Migration function to extract embedded controls"
      exports: ["migrateEmbeddedControls", "runMigrationIfNeeded"]
    - path: "src/stores/rctStore.ts"
      provides: "Updated netScore calculation using controlsStore"
      contains: "useControlsStore"
  key_links:
    - from: "src/utils/controlMigration.ts"
      to: "src/stores/controlsStore.ts"
      via: "imports store for migration"
      pattern: "import.*useControlsStore.*from.*@/stores/controlsStore"
    - from: "src/stores/rctStore.ts"
      to: "src/stores/controlsStore.ts"
      via: "reads controls for netScore"
      pattern: "useControlsStore.getState"
---

<objective>
Migrate existing embedded controls to controlsStore and update rctStore to use links for net score calculation.

Purpose: Enable the transition from embedded controls to first-class entities without losing existing data. After migration, controls are the source of truth in controlsStore.

Output: Migration utility that runs on app load, updated rctStore that computes netScore from linked controls.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/13-controls-hub/13-RESEARCH.md
@.planning/phases/13-controls-hub/13-01-SUMMARY.md

@src/stores/rctStore.ts
@src/stores/controlsStore.ts
@src/types/rct.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create migration utility</name>
  <files>src/utils/controlMigration.ts</files>
  <action>
Create src/utils/controlMigration.ts with functions to migrate embedded controls:

```typescript
import { nanoid } from 'nanoid'
import type { Control, ControlLink, RCTRow } from '@/types/rct'
import { useControlsStore } from '@/stores/controlsStore'
import { useRCTStore } from '@/stores/rctStore'

/**
 * Extracts controls from embedded row.controls arrays into separate arrays.
 * Preserves existing control IDs to maintain test history references.
 */
export function migrateEmbeddedControls(
  rows: RCTRow[]
): { controls: Control[]; links: ControlLink[] } {
  const controls: Control[] = []
  const links: ControlLink[] = []
  const seenControlIds = new Set<string>()

  for (const row of rows) {
    for (const embeddedControl of row.controls) {
      // If control ID not seen, add to controls array
      // (handles case where same control might be duplicated - preserve first)
      if (!seenControlIds.has(embeddedControl.id)) {
        controls.push({ ...embeddedControl })
        seenControlIds.add(embeddedControl.id)
      }

      // Create link for this row-control relationship
      links.push({
        id: nanoid(),
        controlId: embeddedControl.id,
        rowId: row.id,
        // Preserve row-specific scores in the link (not typical but safe)
        netProbability: embeddedControl.netProbability,
        netImpact: embeddedControl.netImpact,
        netScore: embeddedControl.netScore,
        createdAt: new Date().toISOString(),
      })
    }
  }

  return { controls, links }
}

/**
 * Run migration if not already done.
 * Checks migrationVersion in controlsStore.
 * Safe to call multiple times - only runs once.
 */
export function runMigrationIfNeeded(): void {
  const controlsState = useControlsStore.getState()
  const rctState = useRCTStore.getState()

  // Already migrated
  if (controlsState.migrationVersion >= 1) {
    return
  }

  // No rows to migrate
  if (rctState.rows.length === 0) {
    // Still mark as migrated so we don't check again
    controlsState.setMigrationVersion(1)
    return
  }

  // Check if any rows have embedded controls
  const hasEmbeddedControls = rctState.rows.some(r => r.controls.length > 0)
  if (!hasEmbeddedControls) {
    controlsState.setMigrationVersion(1)
    return
  }

  // Run migration
  const { controls, links } = migrateEmbeddedControls(rctState.rows)

  // Import to controlsStore
  controlsState.importControls(controls, links)

  // Mark migration complete
  controlsState.setMigrationVersion(1)

  console.log(`[Controls Migration] Migrated ${controls.length} controls with ${links.length} links`)
}
```

Key considerations:
- Preserves existing control IDs (critical for test history)
- Creates one link per row-control pair
- Safe to run multiple times (idempotent)
- Handles empty states gracefully
  </action>
  <verify>Run `npx tsc --noEmit` and confirm no type errors in controlMigration.ts.</verify>
  <done>Migration utility exports migrateEmbeddedControls and runMigrationIfNeeded functions.</done>
</task>

<task type="auto">
  <name>Task 2: Add helper function to rctStore for net score from links</name>
  <files>src/stores/rctStore.ts</files>
  <action>
Update src/stores/rctStore.ts to add a helper function that calculates net score from controlsStore links.

**Add import at top:**
```typescript
import { useControlsStore } from '@/stores/controlsStore'
```

**Add helper function (outside the store, exported):**
```typescript
/**
 * Calculate net score for a row based on linked controls.
 * Net score = minimum net score across all linked controls.
 * Returns null if no controls linked or no controls have scores.
 */
export function calculateNetScoreFromLinks(rowId: string): number | null {
  const { controls, controlLinks } = useControlsStore.getState()

  // Get all links for this row
  const rowLinks = controlLinks.filter(l => l.rowId === rowId)
  if (rowLinks.length === 0) return null

  // Get net scores: prefer link-specific override, fall back to control's score
  const netScores = rowLinks.map(link => {
    // If link has its own score, use it
    if (link.netScore !== null && link.netScore !== undefined) {
      return link.netScore
    }
    // Otherwise get control's score
    const control = controls.find(c => c.id === link.controlId)
    return control?.netScore ?? null
  }).filter((s): s is number => s !== null)

  // Return minimum (best net score means most effective control)
  return netScores.length > 0 ? Math.min(...netScores) : null
}
```

**Update existing control methods to also update netScore:**

In the existing `addControl`, `updateControl`, and `removeControl` methods, after updating the row.controls array, add:
```typescript
// Also recalculate from links (dual-source during transition)
const linkedNetScore = calculateNetScoreFromLinks(rowId)
if (linkedNetScore !== null) {
  row.netScore = linkedNetScore
}
```

This maintains backward compatibility while transitioning to the new system.

**Note:** Do NOT remove the existing embedded control logic yet. We're adding the link-based calculation in parallel. The UI will be updated in Plan 03 to use controlsStore directly.
  </action>
  <verify>
1. Run `npx tsc --noEmit` and confirm no type errors.
2. Verify import of useControlsStore is present at top of file.
3. Verify calculateNetScoreFromLinks function is exported.
  </verify>
  <done>rctStore exports calculateNetScoreFromLinks that computes net score from controlsStore links.</done>
</task>

<task type="auto">
  <name>Task 3: Run migration on app startup</name>
  <files>src/App.tsx</files>
  <action>
Update src/App.tsx to run migration on app startup.

**Add import:**
```typescript
import { useEffect } from 'react'
import { runMigrationIfNeeded } from '@/utils/controlMigration'
```

**Add useEffect inside App component (before return):**
```typescript
function App() {
  // Run migration on app startup
  useEffect(() => {
    runMigrationIfNeeded()
  }, [])

  return (
    // ... existing JSX
  )
}
```

The migration:
1. Checks if already run (migrationVersion >= 1)
2. If not, extracts embedded controls from all RCT rows
3. Creates links for each row-control relationship
4. Imports to controlsStore
5. Marks migration complete

This ensures existing data is migrated before user interacts with the app.
  </action>
  <verify>
1. Run `npx tsc --noEmit` and confirm no type errors.
2. Verify useEffect import is present.
3. Verify runMigrationIfNeeded import is present.
4. Verify useEffect is called inside App component.
  </verify>
  <done>App.tsx runs migration on startup via useEffect, migrating embedded controls to controlsStore.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. src/utils/controlMigration.ts exists and exports migrateEmbeddedControls, runMigrationIfNeeded
3. rctStore.ts imports useControlsStore and exports calculateNetScoreFromLinks
4. App.tsx calls runMigrationIfNeeded in useEffect
5. Migration preserves control IDs (not regenerating with nanoid)
6. Migration creates one link per row-control pair
</verification>

<success_criteria>
- migrateEmbeddedControls extracts controls and creates links
- runMigrationIfNeeded checks migrationVersion before running
- calculateNetScoreFromLinks returns min net score across linked controls
- App.tsx runs migration on mount
- Existing control IDs are preserved for test history continuity
- Migration is idempotent (safe to run multiple times)
</success_criteria>

<output>
After completion, create `.planning/phases/13-controls-hub/13-02-SUMMARY.md`
</output>
