---
phase: 16-four-eye-approval
plan: 03
type: execute
wave: 2
depends_on: ["16-01"]
files_modified:
  - src/hooks/useApprovalAwareTaxonomy.ts
  - src/stores/taxonomyStore.ts
  - src/components/taxonomy/TaxonomyTree.tsx
autonomous: true

must_haves:
  truths:
    - "Risk taxonomy changes route through approval when four-eye enabled"
    - "Process taxonomy changes route through approval when four-eye enabled"
    - "Pending taxonomy items show amber indicator in tree"
    - "Manager can bypass approval and edit directly"
  artifacts:
    - path: "src/hooks/useApprovalAwareTaxonomy.ts"
      provides: "Hook that routes taxonomy updates through approval when required"
      exports: ["useApprovalAwareTaxonomy"]
  key_links:
    - from: "src/hooks/useApprovalAwareTaxonomy.ts"
      to: "src/stores/approvalStore.ts"
      via: "createPendingChange call"
      pattern: "createPendingChange"
    - from: "src/components/taxonomy/TaxonomyTree.tsx"
      to: "src/hooks/useApprovalAwareTaxonomy.ts"
      via: "approval-aware taxonomy hook"
      pattern: "useApprovalAwareTaxonomy"
---

<objective>
Integrate approval workflow into risk and process taxonomy management.

Purpose: Make taxonomy changes go through approval when four-eye is enabled.
Output: Taxonomy items show pending indicators, changes route through approval for non-Manager roles.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/16-four-eye-approval/16-01-SUMMARY.md
@.planning/phases/16-four-eye-approval/16-CONTEXT.md
@src/stores/taxonomyStore.ts
@src/components/taxonomy/TaxonomyTree.tsx
@src/types/taxonomy.ts
@src/types/approval.ts
@src/stores/approvalStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create approval-aware taxonomy hook</name>
  <files>
    src/hooks/useApprovalAwareTaxonomy.ts
  </files>
  <action>
Create `src/hooks/useApprovalAwareTaxonomy.ts`:

```typescript
import { useUIStore } from '@/stores/uiStore'
import { useApprovalStore } from '@/stores/approvalStore'
import { useTaxonomyStore } from '@/stores/taxonomyStore'
import type { TaxonomyItem } from '@/types/taxonomy'
import type { PendingChangeEntityType } from '@/types/approval'

export function useApprovalAwareTaxonomy() {
  const role = useUIStore((state) => state.selectedRole)
  const isApprovalRequired = useApprovalStore((state) => state.isApprovalRequired)
  const createPendingChange = useApprovalStore((state) => state.createPendingChange)
  const settings = useApprovalStore((state) => state.settings)
  const { risks, processes, setRisks, setProcesses } = useTaxonomyStore()

  // Helper to find item in tree by ID
  const findItemInTree = (items: TaxonomyItem[], id: string): TaxonomyItem | null => {
    for (const item of items) {
      if (item.id === id) return item
      if (item.children) {
        const found = findItemInTree(item.children, id)
        if (found) return found
      }
    }
    return null
  }

  // Check if taxonomy changes need approval
  const checkTaxonomyApproval = (
    entityType: 'risk' | 'process',
    itemId: string,
    isNew: boolean
  ): boolean => {
    if (role === 'manager') return false

    if (isNew) {
      return entityType === 'risk'
        ? settings.requireForNewRisks
        : settings.requireForNewProcesses
    }

    return isApprovalRequired(entityType, itemId)
  }

  // Create pending change for taxonomy item rename
  const renameTaxonomyItemWithApproval = (
    type: 'risk' | 'process',
    itemId: string,
    newName: string
  ): { requiresApproval: boolean; pendingId?: string } => {
    const tree = type === 'risk' ? risks : processes
    const item = findItemInTree(tree, itemId)
    if (!item) return { requiresApproval: false }

    const requiresApproval = checkTaxonomyApproval(type, itemId, false)

    if (requiresApproval) {
      const pendingId = createPendingChange({
        entityType: type,
        entityId: itemId,
        entityName: `${item.hierarchicalId} ${item.name}`,
        changeType: 'update',
        proposedValues: { name: newName },
        currentValues: { name: item.name },
        submittedBy: role,
      })
      return { requiresApproval: true, pendingId }
    }

    // Direct update - apply to tree
    const updateTree = (items: TaxonomyItem[]): TaxonomyItem[] => {
      return items.map(i => {
        if (i.id === itemId) {
          return { ...i, name: newName }
        }
        if (i.children) {
          return { ...i, children: updateTree(i.children) }
        }
        return i
      })
    }

    if (type === 'risk') {
      setRisks(updateTree(risks))
    } else {
      setProcesses(updateTree(processes))
    }
    return { requiresApproval: false }
  }

  // Create pending change for taxonomy item deletion
  const deleteTaxonomyItemWithApproval = (
    type: 'risk' | 'process',
    itemId: string
  ): { requiresApproval: boolean; pendingId?: string } => {
    const tree = type === 'risk' ? risks : processes
    const item = findItemInTree(tree, itemId)
    if (!item) return { requiresApproval: false }

    const requiresApproval = checkTaxonomyApproval(type, itemId, false)

    if (requiresApproval) {
      const pendingId = createPendingChange({
        entityType: type,
        entityId: itemId,
        entityName: `${item.hierarchicalId} ${item.name}`,
        changeType: 'delete',
        proposedValues: {},
        currentValues: {
          name: item.name,
          hierarchicalId: item.hierarchicalId,
          children: item.children?.length || 0,
        },
        submittedBy: role,
      })
      return { requiresApproval: true, pendingId }
    }

    // Direct delete - apply to tree
    const removeFromTree = (items: TaxonomyItem[]): TaxonomyItem[] => {
      return items
        .filter(i => i.id !== itemId)
        .map(i => ({
          ...i,
          children: i.children ? removeFromTree(i.children) : undefined,
        }))
    }

    if (type === 'risk') {
      setRisks(removeFromTree(risks))
    } else {
      setProcesses(removeFromTree(processes))
    }
    return { requiresApproval: false }
  }

  // Create pending change for new taxonomy item
  const addTaxonomyItemWithApproval = (
    type: 'risk' | 'process',
    parentId: string | null,
    name: string
  ): { requiresApproval: boolean; pendingId?: string } => {
    const requiresApproval = checkTaxonomyApproval(type, `new-${Date.now()}`, true)

    if (requiresApproval) {
      const pendingId = createPendingChange({
        entityType: type,
        entityId: `new-${Date.now()}`,
        entityName: name,
        changeType: 'create',
        proposedValues: { name, parentId },
        currentValues: {},
        submittedBy: role,
      })
      return { requiresApproval: true, pendingId }
    }

    // Direct add - let the tree component handle normal add flow
    return { requiresApproval: false }
  }

  return {
    renameTaxonomyItemWithApproval,
    deleteTaxonomyItemWithApproval,
    addTaxonomyItemWithApproval,
    isManager: role === 'manager',
    checkTaxonomyApproval,
  }
}
```

This hook mirrors the pattern from useApprovalAwareUpdate.ts but handles tree-based taxonomy operations. The actual tree manipulation for new items is complex (react-arborist handles it), so addTaxonomyItemWithApproval only creates the pending change - actual creation happens when Manager approves.
  </action>
  <verify>
- File exists: `src/hooks/useApprovalAwareTaxonomy.ts`
- TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>
- useApprovalAwareTaxonomy hook routes taxonomy changes through approval
- Handles rename, delete, and create operations
- Checks global and per-entity settings
- Manager bypasses approval
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate approval into TaxonomyTree component</name>
  <files>
    src/components/taxonomy/TaxonomyTree.tsx
  </files>
  <action>
Update `src/components/taxonomy/TaxonomyTree.tsx`:

1. Import the hook and badge:
```typescript
import { useApprovalAwareTaxonomy } from '@/hooks/useApprovalAwareTaxonomy'
import { useApprovalStore } from '@/stores/approvalStore'
import { ApprovalBadge } from '@/components/approval'
```

2. In the component:
- Get approval functions from `useApprovalAwareTaxonomy()`
- Get `getPendingForEntity` from `useApprovalStore`

3. Modify the node renderer to show pending indicator:
- For each node, check if pending changes exist: `getPendingForEntity(node.id)`
- If pending, show small ApprovalBadge (compact mode) next to the node name
- Add subtle amber background tint to nodes with pending changes

4. Intercept edit/delete operations:
- When user renames a node (onRename or similar callback):
  - Call `renameTaxonomyItemWithApproval(type, nodeId, newName)`
  - If `requiresApproval`, show notification "Change submitted for approval"
  - If not, proceed with normal rename

- When user deletes a node (onDelete or similar callback):
  - Call `deleteTaxonomyItemWithApproval(type, nodeId)`
  - If `requiresApproval`, show notification "Deletion submitted for approval"
  - If not, proceed with normal delete

- When user adds a node (if applicable at this level):
  - Call `addTaxonomyItemWithApproval(type, parentId, name)`
  - If `requiresApproval`, show notification "New item submitted for approval"
  - If not, proceed with normal add

5. Note on react-arborist integration:
- react-arborist uses handlers like `onRename`, `onDelete`, `onCreate`
- Intercept these handlers to route through approval-aware functions
- For creates that need approval, you may need to prevent the default behavior and only show notification

6. For pending "create" changes:
- These won't show in the tree yet (item doesn't exist)
- They'll appear in the approval queue (Plan 04) for Manager to action
- When approved, the actual tree insertion happens via applyPendingChange

Styling for pending nodes:
```typescript
// In node render function
const hasPending = getPendingForEntity(node.data.id).length > 0
<div className={clsx(
  'flex items-center gap-2',
  hasPending && 'bg-amber-500/10 rounded px-1'
)}>
  <span>{node.data.name}</span>
  {hasPending && <ApprovalBadge status="pending" compact />}
</div>
```
  </action>
  <verify>
- TypeScript compiles: `npx tsc --noEmit`
- TaxonomyTree shows ApprovalBadge on nodes with pending changes
- Rename/delete operations route through approval when enabled
  </verify>
  <done>
- Taxonomy rename operations create pending changes when four-eye enabled
- Taxonomy delete operations create pending changes when four-eye enabled
- Visual indicator on nodes with pending changes
- Manager can edit directly without approval
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` - TypeScript compiles without errors
2. Enable four-eye for risks in approvalStore
3. As Risk Manager, rename a risk item - change goes to pending, badge appears on node
4. Switch to Manager, item should be editable directly without approval
5. Delete operation as Risk Manager also creates pending change
</verification>

<success_criteria>
1. Risk taxonomy edits route through approval when enabled
2. Process taxonomy edits route through approval when enabled
3. Pending nodes show visual indicator in tree
4. Manager bypasses approval for all taxonomy operations
5. Pending changes properly recorded in approvalStore
</success_criteria>

<output>
After completion, create `.planning/phases/16-four-eye-approval/16-03-SUMMARY.md`
</output>
