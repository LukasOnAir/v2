---
phase: 16-four-eye-approval
plan: 08
type: execute
wave: 1
depends_on: []
files_modified:
  - src/stores/approvalStore.ts
  - src/components/rct/ControlPanel.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Score changes (netProbability, netImpact) on controls go through approval workflow"
    - "Multiple field changes to same entity batch into single pending change"
    - "Per-link score overrides in ControlPanel respect approval settings"
  artifacts:
    - path: "src/stores/approvalStore.ts"
      provides: "Batched pending change creation"
      contains: "findIndex.*entityId.*submittedBy.*pending"
    - path: "src/components/rct/ControlPanel.tsx"
      provides: "Approval-aware per-link score updates"
      contains: "updateControlWithApproval"
  key_links:
    - from: "src/components/rct/ControlPanel.tsx"
      to: "src/stores/approvalStore.ts"
      via: "createPendingChange with merge logic"
      pattern: "createPendingChange"
---

<objective>
Fix two approval workflow gaps discovered during UAT: (1) per-link score changes bypass approval, and (2) multiple field changes create separate pending changes instead of batching.

Purpose: Ensure comprehensive approval coverage for all control modifications and improve UX by consolidating related changes.

Output: Both gaps closed with existing approval infrastructure - no new UI needed.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/stores/approvalStore.ts
@src/components/rct/ControlPanel.tsx
@src/hooks/useApprovalAwareUpdate.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement pending change batching in approvalStore</name>
  <files>src/stores/approvalStore.ts</files>
  <action>
Modify `createPendingChange` function to batch multiple changes to same entity:

1. Before creating a new pending change, check if one already exists for:
   - Same `entityId`
   - Same `submittedBy` (role)
   - Status is 'pending'

2. If existing pending change found:
   - MERGE the new `proposedValues` into the existing `proposedValues` (Object.assign/spread)
   - MERGE the new `currentValues` into the existing `currentValues` (only for fields not already captured)
   - Increment the `version` field
   - Update `submittedAt` to current timestamp
   - Return the existing pending change's ID

3. If no existing pending change found:
   - Create new pending change as before (current behavior)

Implementation approach:
```typescript
createPendingChange: (change) => {
  const role = useUIStore.getState().selectedRole
  const timestamp = new Date().toISOString()

  // Check for existing pending change to merge with
  const existingIdx = get().pendingChanges.findIndex(
    (c) =>
      c.entityId === change.entityId &&
      c.submittedBy === change.submittedBy &&
      c.status === 'pending'
  )

  if (existingIdx !== -1) {
    // Merge into existing pending change
    let mergedId = ''
    set((state) => {
      const existing = state.pendingChanges[existingIdx]
      // Merge proposed values (new values override old)
      state.pendingChanges[existingIdx].proposedValues = {
        ...existing.proposedValues,
        ...change.proposedValues,
      }
      // Merge current values (keep original current values for fields already tracked)
      state.pendingChanges[existingIdx].currentValues = {
        ...change.currentValues,
        ...existing.currentValues, // Original current values take precedence
      }
      state.pendingChanges[existingIdx].version = (existing.version || 1) + 1
      state.pendingChanges[existingIdx].submittedAt = timestamp
      mergedId = existing.id
    })

    // Log merge to audit
    useAuditStore.getState().addEntry({
      timestamp,
      entityType: 'pendingChange',
      entityId: get().pendingChanges[existingIdx].id,
      entityName: `Updated: ${change.entityName}`,
      changeType: 'update',
      fieldChanges: Object.keys(change.proposedValues).map((field) => ({
        field,
        oldValue: null,
        newValue: change.proposedValues[field],
      })),
      user: role,
      summary: `Added fields to pending ${change.changeType} for ${change.entityType}: ${change.entityName}`,
    })

    return mergedId
  }

  // No existing - create new (existing logic)
  const id = nanoid()
  // ... rest of existing implementation
}
```

Note: The merge preserves original currentValues so the diff always shows the true "before" state from when changes started.
  </action>
  <verify>
1. Create control with approval enabled
2. As Risk Manager role, change control name -> creates pending change
3. Without approving, change control description -> should NOT create second pending change
4. Verify single pending change now contains both name AND description in proposedValues
5. Manager approves -> both changes apply in single approval
  </verify>
  <done>Multiple field changes to same entity by same user merge into single pending change instead of creating duplicates</done>
</task>

<task type="auto">
  <name>Task 2: Route per-link score changes through approval in ControlPanel</name>
  <files>src/components/rct/ControlPanel.tsx</files>
  <action>
The per-link score changes (netProbability, netImpact overrides) currently bypass approval by calling `updateLink` directly. Fix this by routing through approval when required.

1. Locate the linked controls section (around line 672-707) where ScoreDropdown onChange handlers directly call `updateLink`.

2. Create an approval-aware handler for per-link score updates. Add near other handlers:

```typescript
// Approval-aware handler for per-link score overrides
const handleLinkedControlScoreChange = useCallback(
  (linkId: string, controlId: string, controlName: string, field: 'netProbability' | 'netImpact', value: number) => {
    // Check if approval is required for this control
    const requiresApproval = isApprovalRequired('control', controlId) && role !== 'manager'

    if (requiresApproval) {
      // Get current link to capture current value
      const link = controlLinks.find(l => l.id === linkId)
      const currentValue = link?.[field]

      // Create pending change for the link score override
      // Use a composite entityId to distinguish link-level from control-level changes
      createPendingChange({
        entityType: 'control', // Still a control change conceptually
        entityId: controlId, // Use control ID so changes batch correctly
        entityName: `${controlName} (per-risk override)`,
        changeType: 'update',
        proposedValues: { [`link_${field}`]: value, _linkId: linkId },
        currentValues: { [`link_${field}`]: currentValue, _linkId: linkId },
        submittedBy: role,
      })
      showNotification('Score override submitted for approval')
      return
    }

    // No approval required - apply directly
    const { updateLink } = useControlsStore.getState()
    updateLink(linkId, { [field]: value })
  },
  [isApprovalRequired, role, createPendingChange, controlLinks, showNotification]
)
```

3. Update the ScoreDropdown onChange handlers in the linked controls section to use this new handler:

From (around lines 672-684):
```typescript
<ScoreDropdown
  value={displayP}
  onChange={(v) => {
    const { updateLink } = useControlsStore.getState()
    updateLink(linkedControl.linkId, { netProbability: v })
  }}
  // ...
/>
```

To:
```typescript
<ScoreDropdown
  value={displayP}
  onChange={(v) => handleLinkedControlScoreChange(
    linkedControl.linkId,
    linkedControl.id,
    linkedControl.name,
    'netProbability',
    v
  )}
  // ...
/>
```

4. Do the same for netImpact ScoreDropdown (around lines 685-699).

5. Update `applyPendingChange` in approvalStore.ts to handle link score overrides:
   - Check if proposedValues contains `link_netProbability` or `link_netImpact` with `_linkId`
   - If so, call `updateLink` with the appropriate values instead of `updateControl`

Add to the control branch in applyPendingChange:
```typescript
if (entityType === 'control') {
  const controlsStore = useControlsStore.getState()

  // Check for per-link score overrides
  if (proposedValues._linkId && (proposedValues.link_netProbability !== undefined || proposedValues.link_netImpact !== undefined)) {
    const linkUpdates: Partial<{ netProbability: number | null; netImpact: number | null }> = {}
    if (proposedValues.link_netProbability !== undefined) {
      linkUpdates.netProbability = proposedValues.link_netProbability as number
    }
    if (proposedValues.link_netImpact !== undefined) {
      linkUpdates.netImpact = proposedValues.link_netImpact as number
    }
    controlsStore.updateLink(proposedValues._linkId as string, linkUpdates)
    return
  }

  // Existing control update logic...
}
```
  </action>
  <verify>
1. Enable approval for a control that has per-risk link overrides
2. As non-Manager, change netProbability on a per-link override in ControlPanel
3. Verify pending change is created with `link_netProbability` field
4. Manager approves the change
5. Verify the per-link override is applied (not the base control value)
  </verify>
  <done>Per-link score overrides in ControlPanel go through approval workflow when approval is enabled for that control</done>
</task>

</tasks>

<verification>
## Manual Testing

1. **Batching Test:**
   - Enable approval globally and for controls
   - Switch to Risk Manager role
   - Edit a control's name, then immediately edit its description
   - Open Pending Changes panel -> should show ONE pending change with both fields
   - Approve -> both changes apply atomically

2. **Per-Link Score Test:**
   - Create a control linked to multiple risks
   - Enable approval for that control
   - Switch to Risk Manager role
   - In ControlPanel, change the per-risk net probability override
   - Verify "Score override submitted for approval" notification
   - Manager approves -> verify the per-link score (not base control) updates

3. **Edge Cases:**
   - Change same field twice before approval -> latest value wins
   - Change base control score AND per-link score -> separate pending changes (different scope)
   - Manager changes scores -> no approval required, applies immediately
</verification>

<success_criteria>
- [ ] Multiple changes to same entity by same submitter merge into single pending change
- [ ] Merged pending change preserves original currentValues for accurate diff
- [ ] Per-link score changes create pending changes when approval required
- [ ] Per-link approved changes apply to link, not base control
- [ ] Manager role bypasses approval for all score changes
- [ ] TypeScript compiles without errors
- [ ] No regressions in existing approval workflow
</success_criteria>

<output>
After completion, create `.planning/phases/16-four-eye-approval/16-08-SUMMARY.md`
</output>
