# Phase 19: Mock Data Loader - Research

**Researched:** 2026-01-24
**Domain:** Mock data generation, Zustand store population, React dialogs
**Confidence:** HIGH

## Summary

Phase 19 requires implementing a "Load Mock Data" button in the application header that populates all Zustand stores with comprehensive demo data. This enables demonstration of all application features without manual data entry.

The implementation involves:
1. A header button with confirmation dialog (using Radix Dialog pattern)
2. A mock data generator module that creates realistic, interconnected data
3. Coordinated store population that respects relationships (taxonomy -> RCT rows -> controls -> tickets -> etc.)

**Primary recommendation:** Create a dedicated `mockDataLoader.ts` utility module that generates all mock data objects, then call store setters in dependency order. Use `nanoid()` for IDs to match existing patterns.

## Standard Stack

The phase uses existing application dependencies - no new libraries needed.

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| @radix-ui/react-dialog | 1.1.15 | Confirmation modal | Already used (AddColumnDialog pattern) |
| zustand | 5.0.10 | State management | All stores use this |
| nanoid | (bundled) | ID generation | Used by all stores |
| date-fns | 4.1.0 | Date generation | Already used throughout |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| lucide-react | 0.562.0 | Button icon | Database/Upload icon for button |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Static JSON files | Generated data | Generation provides consistent IDs and relationships; static files would have stale ID references |
| faker.js | Hand-crafted data | faker.js adds 500KB+ bundle size; hand-crafted data is domain-appropriate for casino risk management |

**Installation:**
No new packages required.

## Architecture Patterns

### Recommended Project Structure
```
src/
├── utils/
│   └── mockDataLoader.ts    # All mock data generation logic
├── components/
│   └── layout/
│       ├── Header.tsx       # Add button + dialog trigger
│       └── LoadMockDataDialog.tsx  # Confirmation dialog (NEW)
```

### Pattern 1: Centralized Mock Data Generator
**What:** Single module with factory functions for each entity type
**When to use:** Always - keeps mock data logic isolated and testable
**Example:**
```typescript
// src/utils/mockDataLoader.ts
import { nanoid } from 'nanoid'
import type { TaxonomyItem } from '@/types/taxonomy'
import type { Control, RCTRow } from '@/types/rct'
// ... other imports

// Factory for taxonomy items (reusable for risks and processes)
function createTaxonomyItem(name: string, description: string, children?: TaxonomyItem[]): TaxonomyItem {
  return {
    id: nanoid(),
    hierarchicalId: '', // Regenerated by setRisks/setProcesses
    name,
    description,
    children: children || [],
  }
}

// Generate 5-level risk taxonomy
export function generateMockRisks(): TaxonomyItem[] {
  return [
    createTaxonomyItem('Operational Risk', 'Risks from business operations', [
      createTaxonomyItem('Process Risk', 'Risks in operational processes', [
        createTaxonomyItem('Gaming Operations', 'Casino floor operations', [
          createTaxonomyItem('Table Games', 'Card and dice games', [
            createTaxonomyItem('Blackjack Procedures', 'Card handling and dealing'),
            createTaxonomyItem('Roulette Operations', 'Wheel and betting procedures'),
          ]),
          createTaxonomyItem('Slot Operations', 'Electronic gaming machines', [
            createTaxonomyItem('Machine Maintenance', 'Physical upkeep'),
            createTaxonomyItem('Payout Verification', 'Jackpot procedures'),
          ]),
        ]),
        // ... more L3-L5 items
      ]),
      // ... more L2 items
    ]),
    // ... more L1 items
  ]
}

// Export main loader function
export function loadMockData(): void {
  // Generate in dependency order
  const risks = generateMockRisks()
  const processes = generateMockProcesses()

  // Set taxonomies (regenerates hierarchical IDs)
  useTaxonomyStore.getState().setRisks(risks)
  useTaxonomyStore.getState().setProcesses(processes)

  // Generate RCT rows from taxonomies
  const rows = generateRCTRows(
    useTaxonomyStore.getState().risks,
    useTaxonomyStore.getState().processes
  )
  // ... populate with scores
  useRCTStore.getState().setRows(rows)

  // Create controls and link to rows
  // ... etc
}
```

### Pattern 2: Store Population Order
**What:** Load stores in dependency order to maintain referential integrity
**When to use:** Always - prevents orphaned references
**Order:**
1. `taxonomyStore` - risks and processes (foundational)
2. `rctStore.setRows()` - RCT rows (derived from taxonomies)
3. `controlsStore` - controls and links (references rows)
4. `rctStore` - control tests, remediation plans (references controls)
5. `ticketsStore` - tickets and entity links (references controls, rows)
6. `collaborationStore` - comments and KB articles (references entities)
7. `approvalStore` - pending changes (references entities)
8. `auditStore` - audit entries (references all entity types)

### Pattern 3: Confirmation Dialog
**What:** Radix Dialog warning user about data overwrite
**When to use:** Before loading mock data
**Example:**
```typescript
// src/components/layout/LoadMockDataDialog.tsx
import * as Dialog from '@radix-ui/react-dialog'
import { AlertTriangle, X } from 'lucide-react'
import { loadMockData } from '@/utils/mockDataLoader'

interface Props {
  isOpen: boolean
  onClose: () => void
}

export function LoadMockDataDialog({ isOpen, onClose }: Props) {
  const handleConfirm = () => {
    loadMockData()
    onClose()
  }

  return (
    <Dialog.Root open={isOpen} onOpenChange={(open) => !open && onClose()}>
      <Dialog.Portal>
        <Dialog.Overlay className="fixed inset-0 bg-black/60 z-40" />
        <Dialog.Content className="fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-[440px] bg-surface-elevated border border-surface-border rounded-lg shadow-xl z-50">
          {/* Warning icon + title */}
          <div className="flex items-center gap-3 p-4 border-b border-surface-border">
            <div className="p-2 bg-amber-500/10 rounded-lg">
              <AlertTriangle className="w-5 h-5 text-amber-500" />
            </div>
            <Dialog.Title className="text-lg font-semibold text-text-primary">
              Load Demo Data
            </Dialog.Title>
            <Dialog.Close asChild>
              <button className="ml-auto p-2 rounded-lg hover:bg-surface-overlay">
                <X size={20} className="text-text-secondary" />
              </button>
            </Dialog.Close>
          </div>

          {/* Warning message */}
          <div className="p-4">
            <p className="text-text-secondary">
              This will replace all existing data with demonstration data.
              This action cannot be undone.
            </p>
            <p className="mt-2 text-text-secondary text-sm">
              The demo data includes sample risks, processes, controls, tickets,
              and other items to showcase all application features.
            </p>
          </div>

          {/* Action buttons */}
          <div className="flex justify-end gap-2 p-4 border-t border-surface-border">
            <button
              onClick={onClose}
              className="px-4 py-2 text-sm text-text-secondary hover:text-text-primary"
            >
              Cancel
            </button>
            <button
              onClick={handleConfirm}
              className="px-4 py-2 bg-amber-500 text-white rounded-lg text-sm font-medium hover:bg-amber-600"
            >
              Load Demo Data
            </button>
          </div>
        </Dialog.Content>
      </Dialog.Portal>
    </Dialog.Root>
  )
}
```

### Anti-Patterns to Avoid
- **Random IDs without tracking:** Generate IDs with `nanoid()` and store references for linking
- **Parallel store updates:** Update stores sequentially in dependency order
- **Hardcoded hierarchical IDs:** Let `setRisks`/`setProcesses` regenerate them
- **Missing audit suppression:** Mock data load should NOT generate thousands of audit entries

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| RCT row generation | Manual row creation | `generateRCTRows()` from rctGenerator.ts | Handles all L1-L5 hierarchy extraction |
| ID generation | `Math.random()` | `nanoid()` | Consistent with existing codebase |
| Date formatting | Manual string concat | `date-fns format()` | Handles timezone edge cases |
| Hierarchical ID assignment | Manual path building | `setRisks()`/`setProcesses()` | Auto-regenerates on setter call |

**Key insight:** The existing `generateRCTRows()` utility creates proper RCT rows from taxonomies. Generate taxonomies first, then use this utility for rows.

## Common Pitfalls

### Pitfall 1: Audit Log Explosion
**What goes wrong:** Loading mock data triggers audit logging for every entity, creating thousands of entries
**Why it happens:** Store actions (addControl, setRisks, etc.) have inline audit logging
**How to avoid:** Either:
- Clear audit store after loading mock data, OR
- Add a `skipAudit` flag to relevant store actions, OR
- Use `auditStore.getState().entries = []` after load completes
**Warning signs:** Audit log shows 100+ entries after mock data load

### Pitfall 2: Orphaned Control Links
**What goes wrong:** Controls linked to row IDs that don't exist
**Why it happens:** Generating controls before rows, or using wrong row references
**How to avoid:**
1. Generate taxonomies
2. Call `generateRCTRows()` to create rows
3. Set rows in store
4. Create controls with links to actual row IDs from step 3
**Warning signs:** Controls Hub shows "0 risks" for all controls

### Pitfall 3: Invalid Date Ranges
**What goes wrong:** Test dates in future, deadlines in past
**Why it happens:** Not considering realistic date sequences
**How to avoid:** Use date-fns for relative dates:
```typescript
import { subDays, addDays, format } from 'date-fns'

const today = new Date()
const lastWeek = format(subDays(today, 7), 'yyyy-MM-dd')
const nextMonth = format(addDays(today, 30), 'yyyy-MM-dd')
```
**Warning signs:** Overdue indicators showing for items that shouldn't be overdue

### Pitfall 4: Missing Approval Workflow Data
**What goes wrong:** No pending changes to demonstrate four-eye approval
**Why it happens:** Forgetting to create PendingChange entries
**How to avoid:** Explicitly create a few pending changes:
```typescript
approvalStore.getState().pendingChanges.push({
  id: nanoid(),
  entityType: 'control',
  entityId: someControlId,
  entityName: 'Risk Assessment Control',
  changeType: 'update',
  proposedValues: { name: 'Enhanced Risk Assessment' },
  currentValues: { name: 'Risk Assessment Control' },
  status: 'pending',
  submittedBy: 'risk-manager',
  submittedAt: new Date().toISOString(),
  version: 1,
})
```
**Warning signs:** Approval page shows empty queue

### Pitfall 5: Score Distribution Too Uniform
**What goes wrong:** All risk scores are similar, matrix/sunburst looks flat
**Why it happens:** Using same probability/impact for all rows
**How to avoid:** Deliberately create score variety:
- Some high-risk items (P:4-5, I:4-5) for red heatmap cells
- Some low-risk items (P:1-2, I:1-2) for green cells
- Some medium items for yellow/orange range
- Some items without controls (gross = net)
- Some items with effective controls (net << gross)
**Warning signs:** Matrix is single color, sunburst shows uniform segments

## Code Examples

Verified patterns from existing codebase:

### Confirmation Dialog Pattern
```typescript
// Source: src/components/rct/AddColumnDialog.tsx
<Dialog.Root open={isOpen} onOpenChange={(open) => !open && handleClose()}>
  <Dialog.Portal>
    <Dialog.Overlay className="fixed inset-0 bg-black/60 z-40" />
    <Dialog.Content className="fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-[440px] bg-surface-elevated border border-surface-border rounded-lg shadow-xl z-50">
      {/* Content */}
    </Dialog.Content>
  </Dialog.Portal>
</Dialog.Root>
```

### Store Access Pattern
```typescript
// Source: src/stores/approvalStore.ts (line 98-99)
const role = useUIStore.getState().selectedRole
const timestamp = new Date().toISOString()
```

### Taxonomy Item Creation
```typescript
// Source: src/stores/approvalStore.ts (line 424-429)
const newItem: TaxonomyItem = {
  id: nanoid(),
  name,
  hierarchicalId: '', // Will be regenerated by setTree
  description: '',
  children: [],
}
```

### RCT Row Generation
```typescript
// Source: src/utils/rctGenerator.ts (line 72-133)
export function generateRCTRows(
  risks: TaxonomyItem[],
  processes: TaxonomyItem[]
): RCTRow[]
```

### Header Button Pattern
```typescript
// Source: src/components/layout/Header.tsx (line 43-52)
<button
  onClick={() => { /* action */ }}
  className="p-2 rounded-lg hover:bg-surface-overlay text-text-secondary hover:text-text-primary transition-colors"
  title="Button Title"
>
  <Icon className="w-5 h-5" />
</button>
```

## Data Requirements Summary

Based on success criteria, mock data must include:

### Taxonomies (5 levels each)
- **Risks:** At least 3 L1 categories, branching to 5 levels deep
- **Processes:** At least 3 L1 categories, branching to 5 levels deep
- Total leaf items: ~20-30 each for meaningful matrix/sunburst

### RCT Rows
- Generated from taxonomy leaves (automatic via `generateRCTRows`)
- Populated with varied scores:
  - ~30% high risk (gross score 15-25)
  - ~40% medium risk (gross score 6-14)
  - ~30% low risk (gross score 1-5)
- Some with comments on probability/impact

### Controls (controlsStore)
- 15-20 first-class controls
- Various control types (Preventative, Detective, etc.)
- Some linked to multiple rows (demonstrates multi-risk controls)
- Test schedules set (monthly, quarterly, annually)
- Some with overdue next test dates (for testing indicators)

### Control Tests (rctStore.controlTests)
- 20-30 test records across controls
- Mix of pass/fail/partial results
- Dates spanning last 6 months

### Remediation Plans (rctStore.remediationPlans)
- 5-10 remediation plans
- Various statuses: open, in-progress, resolved
- Some overdue (deadline in past)
- Some with action items (completed and pending)

### Tickets (ticketsStore)
- 10-15 tickets across categories
- Various statuses: todo, in-progress, review, done
- Some linked to controls
- Some linked to risks/processes/rctRows
- 1-2 recurring tickets
- Some overdue (for indicator testing)

### Comments (collaborationStore)
- 10-20 comments
- Attached to various entity types (risk, process, control, rctRow)
- Some with replies (threaded)

### Knowledge Base Articles
- 5-8 articles
- Various categories: testing-procedure, best-practice, policy, template
- With tags for filtering

### Audit Entries (auditStore)
- Could be empty (cleared after load) or include 20-50 representative entries
- Recommendation: Clear after load, or add minimal entries manually

### Pending Approvals (approvalStore)
- 3-5 pending changes for demonstration
- Mix of entity types (control, risk, process)
- Mix of change types (create, update)

### Settings
- `approvalStore.settings.globalEnabled = true` (to show approval features)
- Weight overrides for some taxonomy nodes

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Controls embedded in RCT rows | First-class controls with links | Phase 13 | Must use controlsStore, not rctStore.rows[].controls |
| Single control per row | Multi-row control linking | Phase 13 | One control can link to multiple rows |
| Per-row net scores | Calculated from control links | Phase 14 | Net score = min(probability) * min(impact) from all links |
| Manual approval | Four-eye workflow | Phase 16 | Can demonstrate pending changes |

**Deprecated/outdated:**
- `rctStore.rows[].controls`: Migration runs on load, but new controls should use controlsStore
- `ticketsStore.ticketControlLinks`: Replaced by `ticketEntityLinks`

## Open Questions

Things that couldn't be fully resolved:

1. **Audit entry handling**
   - What we know: Store actions create audit entries automatically
   - What's unclear: Should mock data load create audit history, or clear it?
   - Recommendation: Clear audit store after load to start fresh; alternatively, manually add 10-20 representative entries

2. **Holland Casino-specific content**
   - What we know: App is for Holland Casino
   - What's unclear: How domain-specific should risk/process names be?
   - Recommendation: Use generic casino/gaming terminology that's realistic but not proprietary (Blackjack, Roulette, Slots, Cage Operations, etc.)

## Sources

### Primary (HIGH confidence)
- src/stores/taxonomyStore.ts - Taxonomy structure and setters
- src/stores/rctStore.ts - RCT rows, control tests, remediation plans
- src/stores/controlsStore.ts - First-class controls and links
- src/stores/ticketsStore.ts - Tickets and entity links
- src/stores/collaborationStore.ts - Comments and knowledge base
- src/stores/approvalStore.ts - Pending changes and settings
- src/stores/auditStore.ts - Audit entries
- src/types/*.ts - All type definitions
- src/utils/rctGenerator.ts - RCT row generation utility
- src/components/rct/AddColumnDialog.tsx - Dialog pattern reference
- src/components/layout/Header.tsx - Header button placement

### Secondary (MEDIUM confidence)
- .planning/STATE.md - Accumulated decisions and patterns

### Tertiary (LOW confidence)
- None

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - all libraries already in use
- Architecture: HIGH - follows established patterns in codebase
- Pitfalls: HIGH - derived from code analysis of store interactions

**Research date:** 2026-01-24
**Valid until:** 2026-02-24 (stable, internal patterns)
