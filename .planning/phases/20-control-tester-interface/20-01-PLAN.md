---
phase: 20-control-tester-interface
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/stores/uiStore.ts
  - src/types/rct.ts
  - src/hooks/usePermissions.ts
  - src/components/layout/Header.tsx
  - src/components/layout/Sidebar.tsx
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Control Tester role exists in the role selector dropdown"
    - "Control Tester has most restricted permissions (cannot edit definitions, taxonomies, etc.)"
    - "Controls can have an assigned tester ID"
    - "Demo mode allows selecting which tester the user is impersonating"
  artifacts:
    - path: "src/stores/uiStore.ts"
      provides: "AppRole union with control-tester, currentTesterId state"
      contains: "control-tester"
    - path: "src/types/rct.ts"
      provides: "Control interface with assignedTesterId field"
      contains: "assignedTesterId"
    - path: "src/hooks/usePermissions.ts"
      provides: "Tester-specific permissions (most restrictive)"
      contains: "isControlTester"
    - path: "src/components/layout/Header.tsx"
      provides: "Control Tester option in role selector"
      contains: "Control Tester"
  key_links:
    - from: "src/hooks/usePermissions.ts"
      to: "src/stores/uiStore.ts"
      via: "useUIStore for role state"
      pattern: "role === 'control-tester'"
---

<objective>
Add Control Tester role infrastructure and permissions

Purpose: Establish the foundation for a first-line tester role with the most restricted permissions in the hierarchy. Control Testers can only view their assigned controls and record test results - they cannot modify control definitions, view taxonomies, or access analytics.

Output: Extended role system with Control Tester as fourth role option, assignedTesterId field on controls, and updated permissions hook with tester-specific restrictions.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-control-tester-interface/20-RESEARCH.md

@src/stores/uiStore.ts
@src/types/rct.ts
@src/hooks/usePermissions.ts
@src/components/layout/Header.tsx
@src/components/layout/Sidebar.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend AppRole type and add tester state to uiStore</name>
  <files>src/stores/uiStore.ts</files>
  <action>
    Update the AppRole type to include 'control-tester' as the fourth role option:
    ```typescript
    export type AppRole = 'manager' | 'risk-manager' | 'control-owner' | 'control-tester'
    ```

    Add currentTesterId state for demo mode (allows selecting which tester user is impersonating):
    ```typescript
    interface UIState {
      // ... existing fields ...
      currentTesterId: string
      setCurrentTesterId: (testerId: string) => void
    }
    ```

    Initialize currentTesterId to 'tester-1' as default demo value.

    Add the setter implementation:
    ```typescript
    currentTesterId: 'tester-1',
    setCurrentTesterId: (testerId) => set({ currentTesterId: testerId }),
    ```
  </action>
  <verify>TypeScript compiles without errors: `npm run build`</verify>
  <done>AppRole includes 'control-tester', uiStore has currentTesterId state with getter/setter</done>
</task>

<task type="auto">
  <name>Task 2: Add assignedTesterId field to Control interface</name>
  <files>src/types/rct.ts</files>
  <action>
    Add assignedTesterId field to the Control interface:
    ```typescript
    export interface Control {
      id: string
      name: string
      // ... existing fields ...

      // Tester assignment
      assignedTesterId: string | null  // null = unassigned
    }
    ```

    Place the field near the end of the interface, grouped with test-related fields (testFrequency, nextTestDate, etc.).
  </action>
  <verify>TypeScript compiles without errors: `npm run build`</verify>
  <done>Control interface has assignedTesterId field with null default</done>
</task>

<task type="auto">
  <name>Task 3: Update usePermissions hook with tester-specific permissions</name>
  <files>src/hooks/usePermissions.ts</files>
  <action>
    Add Control Tester as the most restrictive role. Control Tester:
    - CANNOT edit gross scores, net scores, control definitions, control assessments
    - CANNOT edit taxonomies, manage custom columns, submit change requests
    - CANNOT edit test schedules (Risk Manager sets those)
    - CAN record test results (their primary function)
    - CAN view test history
    - CANNOT approve/reject changes, toggle four-eye, regenerate RCT

    Update the hook:
    ```typescript
    export function usePermissions() {
      const role = useUIStore((state) => state.selectedRole)
      const isManager = role === 'manager'
      const isRiskManager = role === 'risk-manager' || isManager
      const isControlOwner = role === 'control-owner'
      const isControlTester = role === 'control-tester'

      return {
        // Edit permissions - Risk Manager and Manager only
        canEditGrossScores: isRiskManager,
        canEditNetScores: isRiskManager,
        canEditControlDefinitions: isRiskManager,
        canEditControlAssessments: isRiskManager,
        canEditTaxonomies: isRiskManager,
        canManageCustomColumns: isRiskManager,
        canEditCustomColumnValues: isRiskManager,

        // View permissions - Tester has restricted view
        canViewAll: !isControlTester,

        // Change request - Control Owner only (not tester)
        canSubmitChangeRequests: isControlOwner,

        // Test-related permissions
        canRecordTestResults: true,              // All roles including tester
        canEditTestSchedule: isRiskManager,      // Risk Manager and Manager sets schedule
        canViewTestHistory: true,                // All roles can view

        // Manager-only permissions
        canApproveChanges: isManager,
        canRejectChanges: isManager,
        canToggleFourEye: isManager,
        canRegenerateRCT: isManager,

        // Tester-specific view restrictions
        isControlTester,
        canViewTaxonomies: !isControlTester,
        canViewRCT: !isControlTester,
        canViewControlsHub: !isControlTester,
        canViewMatrix: !isControlTester,
        canViewSunburst: !isControlTester,
        canViewRemediation: !isControlTester,
        canViewTickets: !isControlTester,
        canViewAudit: !isControlTester,
        canViewApproval: isManager,
        canViewAnalytics: !isControlTester,
        canViewKnowledgeBase: !isControlTester,

        // Utility
        role,
        isManager,
        isRiskManager,
        isControlOwner,
      }
    }
    ```

    Important: Control Tester does NOT inherit from anyone - they are the most restrictive role.
  </action>
  <verify>TypeScript compiles: `npm run build`</verify>
  <done>usePermissions returns isControlTester and all tester-specific view permissions</done>
</task>

<task type="auto">
  <name>Task 4: Update Header with Control Tester role option and tester selector</name>
  <files>src/components/layout/Header.tsx</files>
  <action>
    Add Control Tester option to the role selector dropdown:
    ```tsx
    <select
      value={selectedRole}
      onChange={(e) => setSelectedRole(e.target.value as AppRole)}
      className="..."
    >
      <option value="manager">Manager</option>
      <option value="risk-manager">Risk Manager</option>
      <option value="control-owner">Control Owner</option>
      <option value="control-tester">Control Tester</option>
    </select>
    ```

    Add a tester ID selector that only appears when Control Tester role is selected:
    ```tsx
    {isControlTester && (
      <select
        value={currentTesterId}
        onChange={(e) => setCurrentTesterId(e.target.value)}
        className="bg-surface-elevated text-text-primary border border-surface-border rounded-md px-3 py-1.5 text-sm focus:outline-none focus:ring-2 focus:ring-accent-500"
      >
        <option value="tester-1">Tester 1</option>
        <option value="tester-2">Tester 2</option>
        <option value="tester-3">Tester 3</option>
      </select>
    )}
    ```

    Get currentTesterId and setCurrentTesterId from useUIStore.
    Get isControlTester from usePermissions.

    Hide notification bell and mock data button for Control Tester (they have minimal interface):
    - Bell is already Manager-only
    - Mock data button: wrap in `{!isControlTester && ...}`
  </action>
  <verify>Run dev server, verify Control Tester appears in dropdown and tester selector appears when selected</verify>
  <done>Header shows Control Tester role option and conditional tester ID selector</done>
</task>

<task type="auto">
  <name>Task 5: Update Sidebar to filter navigation items by permission</name>
  <files>src/components/layout/Sidebar.tsx</files>
  <action>
    Add permission property to navItems array:
    ```typescript
    const navItems = [
      { to: '/taxonomy', icon: Folders, label: 'Taxonomies', permission: 'canViewTaxonomies' },
      { to: '/rct', icon: Table, label: 'Risk Control Table', permission: 'canViewRCT' },
      { to: '/controls', icon: Shield, label: 'Controls', permission: 'canViewControlsHub' },
      { to: '/matrix', icon: Grid3x3, label: 'Matrix', permission: 'canViewMatrix' },
      { to: '/sunburst', icon: Sun, label: 'Sunburst', permission: 'canViewSunburst' },
      { to: '/remediation', icon: ClipboardList, label: 'Remediation', permission: 'canViewRemediation' },
      { to: '/tickets', icon: Ticket, label: 'Tickets', permission: 'canViewTickets' },
      { to: '/audit', icon: History, label: 'Audit Trail', permission: 'canViewAudit' },
      { to: '/approval', icon: CheckCircle2, label: 'Approvals', permission: 'canViewApproval' },
      { to: '/analytics', icon: BarChart3, label: 'Analytics', permission: 'canViewAnalytics' },
      { to: '/knowledge-base', icon: BookOpen, label: 'Knowledge Base', permission: 'canViewKnowledgeBase' },
    ] as const
    ```

    Type the navItems correctly to allow permission lookup:
    ```typescript
    type PermissionKey = keyof ReturnType<typeof usePermissions>

    interface NavItem {
      to: string
      icon: LucideIcon
      label: string
      permission?: PermissionKey
    }
    ```

    Filter nav items based on permissions:
    ```tsx
    {navItems
      .filter((item) => !item.permission || permissions[item.permission])
      .map((item) => (
        <li key={item.to}>...</li>
      ))}
    ```

    When Control Tester is selected, the sidebar should show NO navigation items (empty sidebar). The tester will use a dedicated dashboard route instead.

    Add a link to /tester for Control Tester role only at the bottom of the nav:
    ```tsx
    {permissions.isControlTester && (
      <li>
        <NavLink to="/tester" ...>
          <ClipboardCheck className="w-5 h-5 flex-shrink-0" />
          {!isCollapsed && <span className="text-sm font-medium truncate flex-1">My Controls</span>}
        </NavLink>
      </li>
    )}
    ```

    Import ClipboardCheck from lucide-react.
  </action>
  <verify>Run dev server, select Control Tester role, verify sidebar shows only "My Controls" link</verify>
  <done>Sidebar conditionally renders navigation items based on role permissions, Control Tester sees only "My Controls"</done>
</task>

</tasks>

<verification>
1. Run `npm run build` - no TypeScript errors
2. Run `npm run dev`
3. Select "Control Tester" from role dropdown
4. Verify tester ID selector appears
5. Verify sidebar shows only "My Controls" link
6. Verify notification bell and mock data button are hidden for Control Tester
</verification>

<success_criteria>
- AppRole type includes 'control-tester'
- uiStore has currentTesterId state
- Control interface has assignedTesterId field
- usePermissions returns isControlTester and all view permission flags
- Header shows Control Tester in role selector with conditional tester ID dropdown
- Sidebar filters navigation to show only "My Controls" for Control Tester
</success_criteria>

<output>
After completion, create `.planning/phases/20-control-tester-interface/20-01-SUMMARY.md`
</output>
