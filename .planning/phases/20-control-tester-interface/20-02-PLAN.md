---
phase: 20-control-tester-interface
plan: 02
type: execute
wave: 2
depends_on: [20-01]
files_modified:
  - src/components/layout/TesterHeader.tsx
  - src/components/layout/TesterLayout.tsx
  - src/components/tester/TesterControlCard.tsx
  - src/components/tester/index.ts
  - src/pages/TesterDashboardPage.tsx
  - src/App.tsx
  - src/stores/controlsStore.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Control Tester sees only their assigned controls"
    - "Control Tester can record test results for assigned controls"
    - "Control Tester can view test schedule and due dates"
    - "Dashboard shows due/overdue status for each control"
    - "Selecting Control Tester role redirects to /tester route"
  artifacts:
    - path: "src/pages/TesterDashboardPage.tsx"
      provides: "Main tester interface with assigned controls"
      contains: "TesterDashboardPage"
    - path: "src/components/layout/TesterLayout.tsx"
      provides: "Simplified layout for testers"
      contains: "TesterLayout"
    - path: "src/components/tester/TesterControlCard.tsx"
      provides: "Control card with test actions"
      contains: "TesterControlCard"
    - path: "src/App.tsx"
      provides: "Tester route configuration"
      contains: "/tester"
  key_links:
    - from: "src/pages/TesterDashboardPage.tsx"
      to: "src/stores/controlsStore.ts"
      via: "useControlsStore for controls filtering"
      pattern: "assignedTesterId === currentTesterId"
    - from: "src/App.tsx"
      to: "src/components/layout/TesterLayout.tsx"
      via: "Route element"
      pattern: "element={<TesterLayout />}"
---

<objective>
Create dedicated Control Tester dashboard with simplified interface

Purpose: Provide a focused interface where first-line control testers see only their assigned controls, can view test schedules, and record test results. This creates a distraction-free environment for testers who don't need access to risk matrices, taxonomies, or analytics.

Output: TesterDashboardPage showing assigned controls with due/overdue status, TesterLayout with minimal chrome, TesterControlCard for individual control display with test recording capability.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-control-tester-interface/20-RESEARCH.md
@.planning/phases/20-control-tester-interface/20-01-SUMMARY.md

@src/App.tsx
@src/stores/controlsStore.ts
@src/stores/rctStore.ts
@src/components/rct/ControlTestSection.tsx
@src/components/rct/ControlTestForm.tsx
@src/utils/testScheduling.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TesterHeader and TesterLayout components</name>
  <files>src/components/layout/TesterHeader.tsx, src/components/layout/TesterLayout.tsx</files>
  <action>
    Create TesterHeader.tsx - a simplified header for the tester interface:
    ```tsx
    import { useNavigate } from 'react-router'
    import { LogOut, User } from 'lucide-react'
    import { useUIStore, type AppRole } from '@/stores/uiStore'
    import { usePermissions } from '@/hooks/usePermissions'

    export function TesterHeader() {
      const { selectedRole, setSelectedRole, currentTesterId, setCurrentTesterId, logout } = useUIStore()
      const navigate = useNavigate()
      const { isControlTester } = usePermissions()

      return (
        <header className="h-14 bg-surface-elevated border-b border-surface-border flex items-center justify-between px-4">
          <h1 className="text-lg font-semibold text-text-primary">
            RiskGuard - Control Testing
          </h1>

          <div className="flex items-center gap-4">
            {/* Tester ID display */}
            <div className="flex items-center gap-2 text-sm text-text-secondary">
              <User size={16} />
              <select
                value={currentTesterId}
                onChange={(e) => setCurrentTesterId(e.target.value)}
                className="bg-surface-elevated text-text-primary border border-surface-border rounded-md px-2 py-1 text-sm focus:outline-none focus:ring-2 focus:ring-accent-500"
              >
                <option value="tester-1">Tester 1</option>
                <option value="tester-2">Tester 2</option>
                <option value="tester-3">Tester 3</option>
              </select>
            </div>

            {/* Role selector - allows switching back to other roles */}
            <select
              value={selectedRole}
              onChange={(e) => {
                setSelectedRole(e.target.value as AppRole)
                // Redirect to main app when switching away from tester
                if (e.target.value !== 'control-tester') {
                  navigate('/taxonomy')
                }
              }}
              className="bg-surface-elevated text-text-primary border border-surface-border rounded-md px-3 py-1.5 text-sm focus:outline-none focus:ring-2 focus:ring-accent-500"
            >
              <option value="manager">Manager</option>
              <option value="risk-manager">Risk Manager</option>
              <option value="control-owner">Control Owner</option>
              <option value="control-tester">Control Tester</option>
            </select>

            {/* Logout */}
            <button
              onClick={() => {
                logout()
                navigate('/login')
              }}
              className="p-2 rounded-lg hover:bg-surface-overlay text-text-secondary hover:text-text-primary transition-colors"
              title="Logout"
            >
              <LogOut className="w-5 h-5" />
            </button>
          </div>
        </header>
      )
    }
    ```

    Create TesterLayout.tsx - simplified layout without sidebar:
    ```tsx
    import { Outlet } from 'react-router'
    import { TesterHeader } from './TesterHeader'

    export function TesterLayout() {
      return (
        <div className="h-screen flex flex-col bg-surface-base">
          <TesterHeader />
          <main className="flex-1 overflow-auto">
            <Outlet />
          </main>
        </div>
      )
    }
    ```
  </action>
  <verify>TypeScript compiles: `npm run build`</verify>
  <done>TesterHeader and TesterLayout components created with minimal interface</done>
</task>

<task type="auto">
  <name>Task 2: Create TesterControlCard component</name>
  <files>src/components/tester/TesterControlCard.tsx, src/components/tester/index.ts</files>
  <action>
    Create the tester components directory and TesterControlCard.tsx:
    ```tsx
    import { useState } from 'react'
    import { ChevronDown, ChevronRight, AlertCircle, Clock, CheckCircle, XCircle, AlertTriangle } from 'lucide-react'
    import { clsx } from 'clsx'
    import type { Control } from '@/types/rct'
    import { useRCTStore } from '@/stores/rctStore'
    import { useControlsStore } from '@/stores/controlsStore'
    import { isTestOverdue, formatTestDate, getDaysUntilDue } from '@/utils/testScheduling'
    import { ControlTestForm } from '@/components/rct/ControlTestForm'

    const RESULT_DISPLAY: Record<string, { label: string; icon: typeof CheckCircle; color: string }> = {
      pass: { label: 'Pass', icon: CheckCircle, color: 'text-green-400' },
      fail: { label: 'Fail', icon: XCircle, color: 'text-red-400' },
      partial: { label: 'Partial', icon: AlertTriangle, color: 'text-amber-400' },
      'not-tested': { label: 'Not Tested', icon: Clock, color: 'text-text-muted' },
    }

    interface TesterControlCardProps {
      control: Control
    }

    export function TesterControlCard({ control }: TesterControlCardProps) {
      const [isExpanded, setIsExpanded] = useState(false)
      const [showTestForm, setShowTestForm] = useState(false)

      const controlTests = useRCTStore((state) => state.controlTests)
      const controlLinks = useControlsStore((state) => state.getLinksForControl(control.id))

      // Get test history for this control
      const testHistory = controlTests
        .filter((t) => t.controlId === control.id)
        .sort((a, b) => new Date(b.testDate).getTime() - new Date(a.testDate).getTime())

      const latestTest = testHistory[0]
      const overdue = isTestOverdue(control.nextTestDate)
      const daysUntilDue = getDaysUntilDue(control.nextTestDate)

      // Use first linked row for test recording (control may be linked to multiple rows)
      const primaryRowId = controlLinks[0]?.rowId

      return (
        <div
          className={clsx(
            'border rounded-lg p-4 transition-colors',
            overdue
              ? 'border-red-500/50 bg-red-500/5'
              : daysUntilDue !== null && daysUntilDue <= 7
                ? 'border-amber-500/30 bg-amber-500/5'
                : 'border-surface-border bg-surface-elevated'
          )}
        >
          {/* Header */}
          <div className="flex items-start justify-between gap-4">
            <div className="flex-1 min-w-0">
              <div className="flex items-center gap-2">
                <h3 className="text-base font-medium text-text-primary truncate">
                  {control.name}
                </h3>
                {overdue && (
                  <span className="inline-flex items-center gap-1 px-2 py-0.5 rounded text-xs font-medium bg-red-500/20 text-red-400">
                    <AlertCircle size={12} />
                    Overdue
                  </span>
                )}
                {!overdue && daysUntilDue !== null && daysUntilDue <= 7 && (
                  <span className="inline-flex items-center gap-1 px-2 py-0.5 rounded text-xs font-medium bg-amber-500/20 text-amber-400">
                    <Clock size={12} />
                    Due Soon
                  </span>
                )}
              </div>
              {control.description && (
                <p className="text-sm text-text-secondary mt-1 line-clamp-2">
                  {control.description}
                </p>
              )}
            </div>

            {/* Status indicators */}
            <div className="flex items-center gap-3 flex-shrink-0">
              {latestTest && (
                <div className={clsx('flex items-center gap-1 text-sm', RESULT_DISPLAY[latestTest.result]?.color)}>
                  {(() => {
                    const ResultIcon = RESULT_DISPLAY[latestTest.result]?.icon || Clock
                    return <ResultIcon size={16} />
                  })()}
                  <span>{RESULT_DISPLAY[latestTest.result]?.label}</span>
                </div>
              )}
            </div>
          </div>

          {/* Quick info row */}
          <div className="flex items-center gap-6 mt-3 text-sm text-text-secondary">
            <div>
              <span className="text-text-muted">Frequency:</span>{' '}
              <span className="text-text-primary capitalize">
                {control.testFrequency || 'Not set'}
              </span>
            </div>
            <div>
              <span className="text-text-muted">Next Test:</span>{' '}
              <span className={overdue ? 'text-red-400' : 'text-text-primary'}>
                {formatTestDate(control.nextTestDate)}
              </span>
            </div>
            <div>
              <span className="text-text-muted">Last Test:</span>{' '}
              <span className="text-text-primary">
                {formatTestDate(control.lastTestDate)}
              </span>
            </div>
          </div>

          {/* Expand/Collapse */}
          <button
            onClick={() => setIsExpanded(!isExpanded)}
            className="flex items-center gap-1 mt-3 text-sm text-accent-400 hover:text-accent-300 transition-colors"
          >
            {isExpanded ? (
              <>
                <ChevronDown size={16} />
                Hide Details
              </>
            ) : (
              <>
                <ChevronRight size={16} />
                Show Details
              </>
            )}
          </button>

          {/* Expanded content */}
          {isExpanded && (
            <div className="mt-4 pt-4 border-t border-surface-border space-y-4">
              {/* Test Procedure */}
              {control.testProcedure && (
                <div>
                  <h4 className="text-xs font-medium text-text-muted uppercase tracking-wider mb-2">
                    Test Procedure
                  </h4>
                  <p className="text-sm text-text-secondary whitespace-pre-wrap">
                    {control.testProcedure}
                  </p>
                </div>
              )}

              {/* Record Test */}
              <div>
                <div className="flex items-center justify-between mb-2">
                  <h4 className="text-xs font-medium text-text-muted uppercase tracking-wider">
                    Record Test
                  </h4>
                  {!showTestForm && primaryRowId && (
                    <button
                      onClick={() => setShowTestForm(true)}
                      className="px-3 py-1.5 text-sm font-medium text-white bg-accent-500 hover:bg-accent-600 rounded transition-colors"
                    >
                      Record Test Result
                    </button>
                  )}
                </div>

                {showTestForm && primaryRowId && (
                  <div className="p-3 bg-surface-overlay rounded border border-surface-border">
                    <ControlTestForm
                      rowId={primaryRowId}
                      controlId={control.id}
                      onComplete={() => setShowTestForm(false)}
                    />
                  </div>
                )}

                {!primaryRowId && (
                  <p className="text-sm text-text-muted">
                    This control is not linked to any risk. Contact your Risk Manager.
                  </p>
                )}
              </div>

              {/* Test History */}
              <div>
                <h4 className="text-xs font-medium text-text-muted uppercase tracking-wider mb-2">
                  Test History ({testHistory.length})
                </h4>

                {testHistory.length === 0 ? (
                  <p className="text-sm text-text-muted">No tests recorded yet.</p>
                ) : (
                  <div className="space-y-2 max-h-[200px] overflow-auto">
                    {testHistory.slice(0, 5).map((test) => (
                      <div
                        key={test.id}
                        className="p-2 bg-surface-overlay rounded border border-surface-border text-sm"
                      >
                        <div className="flex items-center justify-between">
                          <span className={RESULT_DISPLAY[test.result]?.color || 'text-text-muted'}>
                            {RESULT_DISPLAY[test.result]?.label}
                            {test.effectiveness && ` (${test.effectiveness}/5)`}
                          </span>
                          <span className="text-text-muted text-xs">
                            {formatTestDate(test.testDate)}
                          </span>
                        </div>
                        {test.testerName && (
                          <div className="text-text-muted text-xs mt-1">
                            By: {test.testerName}
                          </div>
                        )}
                      </div>
                    ))}
                    {testHistory.length > 5 && (
                      <p className="text-xs text-text-muted">
                        +{testHistory.length - 5} more tests
                      </p>
                    )}
                  </div>
                )}
              </div>
            </div>
          )}
        </div>
      )
    }
    ```

    Create index.ts barrel export:
    ```typescript
    export { TesterControlCard } from './TesterControlCard'
    ```

    Note: Need to create getDaysUntilDue utility function in testScheduling.ts:
    ```typescript
    export function getDaysUntilDue(nextTestDate: string | null): number | null {
      if (!nextTestDate) return null
      const next = parseISO(nextTestDate)
      if (!isValid(next)) return null
      const today = startOfDay(new Date())
      return differenceInDays(next, today)
    }
    ```
    Add this to src/utils/testScheduling.ts.
  </action>
  <verify>TypeScript compiles: `npm run build`</verify>
  <done>TesterControlCard component created with test recording and history display</done>
</task>

<task type="auto">
  <name>Task 3: Create TesterDashboardPage</name>
  <files>src/pages/TesterDashboardPage.tsx</files>
  <action>
    Create the main dashboard page for Control Testers:
    ```tsx
    import { useMemo } from 'react'
    import { AlertCircle, Clock, CheckCircle, ListChecks } from 'lucide-react'
    import { useUIStore } from '@/stores/uiStore'
    import { useControlsStore } from '@/stores/controlsStore'
    import { isTestOverdue, getDaysUntilDue } from '@/utils/testScheduling'
    import { TesterControlCard } from '@/components/tester'

    export function TesterDashboardPage() {
      const currentTesterId = useUIStore((state) => state.currentTesterId)
      const controls = useControlsStore((state) => state.controls)

      // Filter to only controls assigned to current tester
      const assignedControls = useMemo(
        () => controls.filter((c) => c.assignedTesterId === currentTesterId),
        [controls, currentTesterId]
      )

      // Categorize controls by status
      const overdueControls = useMemo(
        () => assignedControls.filter((c) => isTestOverdue(c.nextTestDate)),
        [assignedControls]
      )

      const dueSoonControls = useMemo(
        () =>
          assignedControls.filter((c) => {
            const days = getDaysUntilDue(c.nextTestDate)
            return days !== null && days >= 0 && days <= 7 && !isTestOverdue(c.nextTestDate)
          }),
        [assignedControls]
      )

      const upToDateControls = useMemo(
        () =>
          assignedControls.filter((c) => {
            const days = getDaysUntilDue(c.nextTestDate)
            return days === null || days > 7
          }),
        [assignedControls]
      )

      return (
        <div className="h-full flex flex-col">
          {/* Header */}
          <div className="p-6 border-b border-surface-border">
            <h1 className="text-2xl font-semibold text-text-primary">My Controls</h1>
            <p className="text-sm text-text-secondary mt-1">
              {assignedControls.length} control{assignedControls.length !== 1 ? 's' : ''} assigned to you
            </p>
          </div>

          {/* Stats Cards */}
          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 p-6">
            <StatCard
              title="Total Assigned"
              value={assignedControls.length}
              icon={ListChecks}
              color="text-text-primary"
              bgColor="bg-surface-elevated"
            />
            <StatCard
              title="Overdue"
              value={overdueControls.length}
              icon={AlertCircle}
              color="text-red-400"
              bgColor={overdueControls.length > 0 ? 'bg-red-500/10' : 'bg-surface-elevated'}
            />
            <StatCard
              title="Due This Week"
              value={dueSoonControls.length}
              icon={Clock}
              color="text-amber-400"
              bgColor={dueSoonControls.length > 0 ? 'bg-amber-500/10' : 'bg-surface-elevated'}
            />
            <StatCard
              title="Up to Date"
              value={upToDateControls.length}
              icon={CheckCircle}
              color="text-green-400"
              bgColor="bg-surface-elevated"
            />
          </div>

          {/* Controls List */}
          <div className="flex-1 overflow-auto p-6 pt-0">
            {assignedControls.length === 0 ? (
              <EmptyState />
            ) : (
              <div className="space-y-4">
                {/* Overdue section */}
                {overdueControls.length > 0 && (
                  <section>
                    <h2 className="text-sm font-medium text-red-400 uppercase tracking-wider mb-3 flex items-center gap-2">
                      <AlertCircle size={16} />
                      Overdue ({overdueControls.length})
                    </h2>
                    <div className="space-y-3">
                      {overdueControls.map((control) => (
                        <TesterControlCard key={control.id} control={control} />
                      ))}
                    </div>
                  </section>
                )}

                {/* Due Soon section */}
                {dueSoonControls.length > 0 && (
                  <section className={overdueControls.length > 0 ? 'mt-6' : ''}>
                    <h2 className="text-sm font-medium text-amber-400 uppercase tracking-wider mb-3 flex items-center gap-2">
                      <Clock size={16} />
                      Due This Week ({dueSoonControls.length})
                    </h2>
                    <div className="space-y-3">
                      {dueSoonControls.map((control) => (
                        <TesterControlCard key={control.id} control={control} />
                      ))}
                    </div>
                  </section>
                )}

                {/* Up to Date section */}
                {upToDateControls.length > 0 && (
                  <section className={overdueControls.length > 0 || dueSoonControls.length > 0 ? 'mt-6' : ''}>
                    <h2 className="text-sm font-medium text-text-muted uppercase tracking-wider mb-3 flex items-center gap-2">
                      <CheckCircle size={16} />
                      Up to Date ({upToDateControls.length})
                    </h2>
                    <div className="space-y-3">
                      {upToDateControls.map((control) => (
                        <TesterControlCard key={control.id} control={control} />
                      ))}
                    </div>
                  </section>
                )}
              </div>
            )}
          </div>
        </div>
      )
    }

    interface StatCardProps {
      title: string
      value: number
      icon: React.ElementType
      color: string
      bgColor: string
    }

    function StatCard({ title, value, icon: Icon, color, bgColor }: StatCardProps) {
      return (
        <div className={`${bgColor} rounded-lg p-4 border border-surface-border`}>
          <div className="flex items-center justify-between">
            <div>
              <p className="text-sm text-text-muted">{title}</p>
              <p className={`text-2xl font-bold mt-1 ${color}`}>{value}</p>
            </div>
            <Icon className={`w-8 h-8 ${color} opacity-50`} />
          </div>
        </div>
      )
    }

    function EmptyState() {
      return (
        <div className="flex flex-col items-center justify-center h-full text-center py-12">
          <ListChecks className="w-16 h-16 text-text-muted mb-4" />
          <h3 className="text-lg font-medium text-text-primary mb-2">
            No Controls Assigned
          </h3>
          <p className="text-sm text-text-secondary max-w-md">
            You don't have any controls assigned to you yet.
            Contact your Risk Manager to get controls assigned for testing.
          </p>
        </div>
      )
    }
    ```
  </action>
  <verify>TypeScript compiles: `npm run build`</verify>
  <done>TesterDashboardPage created with assigned controls, status categorization, and empty state</done>
</task>

<task type="auto">
  <name>Task 4: Update App.tsx routing and add role-based redirect</name>
  <files>src/App.tsx, src/utils/testScheduling.ts</files>
  <action>
    First, add the getDaysUntilDue utility function to testScheduling.ts:
    ```typescript
    import { differenceInDays } from 'date-fns'

    // Add to existing file:
    export function getDaysUntilDue(nextTestDate: string | null): number | null {
      if (!nextTestDate) return null
      const next = parseISO(nextTestDate)
      if (!isValid(next)) return null
      const today = startOfDay(new Date())
      return differenceInDays(next, today)
    }
    ```

    Then update App.tsx to add tester routes:
    ```tsx
    import { useEffect } from 'react'
    import { BrowserRouter, Routes, Route, Navigate } from 'react-router'
    import { Toaster } from 'sonner'
    import { Layout } from './components/layout/Layout'
    import { TesterLayout } from './components/layout/TesterLayout'
    import { ProtectedRoute } from '@/components/auth/ProtectedRoute'
    import { TaxonomyPage } from './pages/TaxonomyPage'
    import { RCTPage } from './pages/RCTPage'
    import { MatrixPage } from './pages/MatrixPage'
    import { SunburstPage } from './pages/SunburstPage'
    import { RemediationPage } from './pages/RemediationPage'
    import { TicketsPage } from './pages/TicketsPage'
    import { AuditPage } from './pages/AuditPage'
    import { AnalyticsPage } from './pages/AnalyticsPage'
    import { KnowledgeBasePage } from './pages/KnowledgeBasePage'
    import { ControlsPage } from './pages/ControlsPage'
    import { ApprovalPage } from './pages/ApprovalPage'
    import { LoginPage } from './pages/LoginPage'
    import { TesterDashboardPage } from './pages/TesterDashboardPage'
    import { runMigrationIfNeeded } from '@/utils/controlMigration'

    function App() {
      useEffect(() => {
        runMigrationIfNeeded()
      }, [])

      return (
        <>
          <BrowserRouter>
            <Routes>
              {/* Login route - outside protected area */}
              <Route path="login" element={<LoginPage />} />

              {/* Protected routes wrapped with ProtectedRoute */}
              <Route element={<ProtectedRoute />}>
                {/* Main app for Manager, Risk Manager, Control Owner */}
                <Route element={<Layout />}>
                  <Route index element={<Navigate to="/taxonomy" replace />} />
                  <Route path="taxonomy" element={<TaxonomyPage />} />
                  <Route path="rct" element={<RCTPage />} />
                  <Route path="controls" element={<ControlsPage />} />
                  <Route path="matrix" element={<MatrixPage />} />
                  <Route path="sunburst" element={<SunburstPage />} />
                  <Route path="remediation" element={<RemediationPage />} />
                  <Route path="tickets" element={<TicketsPage />} />
                  <Route path="audit" element={<AuditPage />} />
                  <Route path="approval" element={<ApprovalPage />} />
                  <Route path="analytics" element={<AnalyticsPage />} />
                  <Route path="knowledge-base" element={<KnowledgeBasePage />} />
                </Route>

                {/* Simplified interface for Control Tester */}
                <Route element={<TesterLayout />}>
                  <Route path="tester" element={<TesterDashboardPage />} />
                </Route>
              </Route>
            </Routes>
          </BrowserRouter>
          <Toaster
            theme="dark"
            position="bottom-right"
            toastOptions={{
              className: 'bg-surface-elevated border-surface-border',
            }}
          />
        </>
      )
    }

    export default App
    ```

    Important: The routing allows all roles to access all routes. The navigation filtering in Sidebar handles showing appropriate links. This allows easy switching between roles without route restrictions.
  </action>
  <verify>Run dev server: `npm run dev`, navigate to /tester route</verify>
  <done>App.tsx has TesterLayout and TesterDashboardPage routes configured</done>
</task>

<task type="auto">
  <name>Task 5: Update controlsStore to initialize assignedTesterId</name>
  <files>src/stores/controlsStore.ts</files>
  <action>
    Update the addControl action to include assignedTesterId:
    ```typescript
    addControl: (control) => {
      const id = nanoid()
      const role = useUIStore.getState().selectedRole

      set((state) => {
        const newControl: Control = {
          ...control,
          id,
          assignedTesterId: control.assignedTesterId ?? null,  // Add this line
          netScore:
            control.netProbability && control.netImpact
              ? control.netProbability * control.netImpact
              : null,
        }
        state.controls.push(newControl)
      })
      // ... rest of audit logging
    }
    ```

    Add assignedTesterId to TRACKED_CONTROL_FIELDS for audit logging:
    ```typescript
    const TRACKED_CONTROL_FIELDS = [
      'name',
      'description',
      'controlType',
      'netProbability',
      'netImpact',
      'testFrequency',
      'testProcedure',
      'assignedTesterId',  // Add this
    ] as const
    ```

    This ensures:
    1. New controls get assignedTesterId: null by default
    2. Tester assignment changes are tracked in audit log
  </action>
  <verify>TypeScript compiles: `npm run build`</verify>
  <done>controlsStore handles assignedTesterId field with audit logging</done>
</task>

</tasks>

<verification>
1. Run `npm run build` - no TypeScript errors
2. Run `npm run dev`
3. Select "Control Tester" role
4. Navigate to /tester route
5. Verify empty state is shown (no controls assigned yet)
6. Switch to Risk Manager, manually assign a control to "tester-1" (via store or future UI)
7. Switch back to Control Tester, verify assigned control appears
8. Verify can record test results
</verification>

<success_criteria>
- TesterLayout provides simplified header without sidebar
- TesterDashboardPage shows only controls assigned to current tester
- Dashboard categorizes controls: Overdue, Due This Week, Up to Date
- TesterControlCard shows control details, test procedure, test history
- Control Tester can record test results via ControlTestForm
- Empty state shown when no controls assigned
- getDaysUntilDue utility function works correctly
</success_criteria>

<output>
After completion, create `.planning/phases/20-control-tester-interface/20-02-SUMMARY.md`
</output>
