---
phase: 21-database-auth-foundation
plan: 02
type: execute
wave: 2
depends_on: [21-01]
files_modified:
  - supabase/migrations/00001_tenants.sql
  - supabase/migrations/00002_profiles.sql
  - supabase/migrations/00003_rls_helper_functions.sql
  - supabase/migrations/00004_audit_log.sql
  - supabase/migrations/00005_auth_events.sql
  - supabase/config.toml
autonomous: true

must_haves:
  truths:
    - "Tenants table exists with id, name, slug columns"
    - "Profiles table links auth.users to tenants via tenant_id"
    - "auth.tenant_id() function returns tenant_id from JWT app_metadata"
    - "All tables have RLS enabled with tenant isolation policies"
    - "Audit log captures entity changes with tenant isolation"
  artifacts:
    - path: "supabase/migrations/00001_tenants.sql"
      provides: "Tenants table (root of multi-tenancy)"
      contains: "CREATE TABLE public.tenants"
    - path: "supabase/migrations/00002_profiles.sql"
      provides: "User profiles with tenant_id and role"
      contains: "ENABLE ROW LEVEL SECURITY"
    - path: "supabase/migrations/00003_rls_helper_functions.sql"
      provides: "auth.tenant_id() helper function"
      contains: "CREATE OR REPLACE FUNCTION auth.tenant_id()"
    - path: "supabase/migrations/00004_audit_log.sql"
      provides: "Audit trail table for entity changes"
      contains: "model audit_log"
    - path: "supabase/migrations/00005_auth_events.sql"
      provides: "Authentication event logging table"
      contains: "CREATE TABLE public.auth_events"
  key_links:
    - from: "supabase/migrations/00002_profiles.sql"
      to: "supabase/migrations/00001_tenants.sql"
      via: "Foreign key reference"
      pattern: "REFERENCES public.tenants"
    - from: "All RLS policies"
      to: "supabase/migrations/00003_rls_helper_functions.sql"
      via: "auth.tenant_id() function call"
      pattern: "auth\\.tenant_id\\(\\)"
---

<objective>
Create database schema for multi-tenant architecture with Row-Level Security.

Purpose: Establish the database foundation with proper tenant isolation. This is the security backbone - RLS ensures users only see their tenant's data.
Output: SQL migrations ready to run that create tenants, profiles, audit tables, and RLS policies.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/21-database-auth-foundation/21-RESEARCH.md

# Research patterns for RLS
# See RESEARCH.md Pattern 1 (Migration Template), Pattern 2 (Tenant ID Helper), Pattern 4 (Audit Trail)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize Supabase migrations directory</name>
  <files>
    supabase/config.toml
  </files>
  <action>
Create `supabase/` directory structure for migrations.

Create `supabase/config.toml` with minimal config:
```toml
[api]
enabled = true
port = 54321

[db]
port = 54322

[studio]
enabled = true
port = 54323
```

Create `supabase/migrations/` directory.

Note: We're creating migrations as SQL files. They will be applied via `supabase db push` (for remote) or `supabase migration up` (for local).
  </action>
  <verify>Directory `supabase/migrations/` exists</verify>
  <done>supabase/config.toml and supabase/migrations/ directory created</done>
</task>

<task type="auto">
  <name>Task 2: Create core schema migrations</name>
  <files>
    supabase/migrations/00001_tenants.sql
    supabase/migrations/00002_profiles.sql
    supabase/migrations/00003_rls_helper_functions.sql
  </files>
  <action>
Create migration files following RESEARCH.md patterns. CRITICAL: Each table MUST have RLS enabled AND policies in the SAME migration file.

**00001_tenants.sql:**
```sql
-- Tenants table (root of multi-tenancy)
-- No RLS on tenants - access controlled via profiles

CREATE TABLE public.tenants (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  slug TEXT UNIQUE NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Comment for documentation
COMMENT ON TABLE public.tenants IS 'Root table for multi-tenant isolation';
```

**00002_profiles.sql:**
```sql
-- User profiles extending auth.users
-- Links users to tenants and stores role

CREATE TABLE public.profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  tenant_id UUID NOT NULL REFERENCES public.tenants(id) ON DELETE CASCADE,
  full_name TEXT,
  role TEXT NOT NULL DEFAULT 'control-owner' CHECK (role IN (
    'director', 'manager', 'risk-manager', 'control-owner', 'control-tester'
  )),
  is_active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Index for RLS performance (CRITICAL)
CREATE INDEX idx_profiles_tenant_id ON public.profiles(tenant_id);
CREATE INDEX idx_profiles_user_id ON public.profiles(id);

-- Enable RLS
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Users can read profiles in their tenant
CREATE POLICY "profiles_tenant_read" ON public.profiles
  FOR SELECT TO authenticated
  USING (tenant_id = (SELECT auth.tenant_id()));

-- Users can update their own profile (not role or tenant_id)
CREATE POLICY "profiles_self_update" ON public.profiles
  FOR UPDATE TO authenticated
  USING (id = auth.uid())
  WITH CHECK (id = auth.uid() AND tenant_id = (SELECT auth.tenant_id()));

-- Grant permissions
GRANT SELECT, UPDATE ON public.profiles TO authenticated;

COMMENT ON TABLE public.profiles IS 'User profiles with tenant and role assignment';
```

**00003_rls_helper_functions.sql:**
```sql
-- RLS helper function to extract tenant_id from JWT
-- Uses app_metadata (NOT user_metadata - security critical)

CREATE OR REPLACE FUNCTION auth.tenant_id()
RETURNS UUID AS $$
  SELECT COALESCE(
    (current_setting('request.jwt.claims', true)::json -> 'app_metadata' ->> 'tenant_id')::uuid,
    NULL
  );
$$ LANGUAGE sql STABLE;

COMMENT ON FUNCTION auth.tenant_id() IS 'Extract tenant_id from JWT app_metadata for RLS policies';

-- Helper to get current user role
CREATE OR REPLACE FUNCTION auth.user_role()
RETURNS TEXT AS $$
  SELECT COALESCE(
    (current_setting('request.jwt.claims', true)::json -> 'app_metadata' ->> 'role'),
    NULL
  );
$$ LANGUAGE sql STABLE;

COMMENT ON FUNCTION auth.user_role() IS 'Extract role from JWT app_metadata for RLS policies';
```
  </action>
  <verify>All three SQL files exist and contain CREATE TABLE/FUNCTION statements</verify>
  <done>
- 00001_tenants.sql creates tenants table
- 00002_profiles.sql creates profiles with RLS policies
- 00003_rls_helper_functions.sql creates auth.tenant_id() and auth.user_role()
  </done>
</task>

<task type="auto">
  <name>Task 3: Create audit and auth event tables</name>
  <files>
    supabase/migrations/00004_audit_log.sql
    supabase/migrations/00005_auth_events.sql
  </files>
  <action>
Create audit tables for SEC-01 (audit trail) and SEC-02 (auth events).

**00004_audit_log.sql:**
```sql
-- Audit log for entity changes (SEC-01)
-- Records create/update/delete on multi-tenant tables

CREATE TABLE public.audit_log (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES public.tenants(id) ON DELETE CASCADE,
  entity_type TEXT NOT NULL,
  entity_id UUID,
  entity_name TEXT,
  change_type TEXT NOT NULL CHECK (change_type IN ('create', 'update', 'delete')),
  old_data JSONB,
  new_data JSONB,
  user_id UUID REFERENCES auth.users(id),
  user_email TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes for efficient queries
CREATE INDEX idx_audit_log_tenant_id ON public.audit_log(tenant_id);
CREATE INDEX idx_audit_log_entity_type ON public.audit_log(entity_type);
CREATE INDEX idx_audit_log_created_at ON public.audit_log(created_at DESC);
CREATE INDEX idx_audit_log_entity_id ON public.audit_log(entity_id);

-- Enable RLS
ALTER TABLE public.audit_log ENABLE ROW LEVEL SECURITY;

-- Users can only see their tenant's audit logs
CREATE POLICY "audit_log_tenant_read" ON public.audit_log
  FOR SELECT TO authenticated
  USING (tenant_id = (SELECT auth.tenant_id()));

-- Insert allowed for authenticated users (triggers will use this)
CREATE POLICY "audit_log_insert" ON public.audit_log
  FOR INSERT TO authenticated
  WITH CHECK (tenant_id = (SELECT auth.tenant_id()));

-- Grant permissions
GRANT SELECT, INSERT ON public.audit_log TO authenticated;

COMMENT ON TABLE public.audit_log IS 'Audit trail for entity changes - immutable log';

-- Generic audit trigger function
CREATE OR REPLACE FUNCTION audit_changes()
RETURNS TRIGGER AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    INSERT INTO public.audit_log (
      tenant_id, entity_type, entity_id, entity_name, change_type, new_data, user_id, user_email
    ) VALUES (
      NEW.tenant_id,
      TG_TABLE_NAME,
      NEW.id,
      COALESCE(NEW.name, NEW.id::text),
      'create',
      to_jsonb(NEW),
      auth.uid(),
      (SELECT email FROM auth.users WHERE id = auth.uid())
    );
    RETURN NEW;
  ELSIF TG_OP = 'UPDATE' THEN
    INSERT INTO public.audit_log (
      tenant_id, entity_type, entity_id, entity_name, change_type, old_data, new_data, user_id, user_email
    ) VALUES (
      NEW.tenant_id,
      TG_TABLE_NAME,
      NEW.id,
      COALESCE(NEW.name, NEW.id::text),
      'update',
      to_jsonb(OLD),
      to_jsonb(NEW),
      auth.uid(),
      (SELECT email FROM auth.users WHERE id = auth.uid())
    );
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    INSERT INTO public.audit_log (
      tenant_id, entity_type, entity_id, entity_name, change_type, old_data, user_id, user_email
    ) VALUES (
      OLD.tenant_id,
      TG_TABLE_NAME,
      OLD.id,
      COALESCE(OLD.name, OLD.id::text),
      'delete',
      to_jsonb(OLD),
      auth.uid(),
      (SELECT email FROM auth.users WHERE id = auth.uid())
    );
    RETURN OLD;
  END IF;
  RETURN NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION audit_changes() IS 'Generic trigger function for audit logging';
```

**00005_auth_events.sql:**
```sql
-- Authentication event logging (SEC-02)
-- Records login, logout, failed attempts, password resets

CREATE TABLE public.auth_events (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID REFERENCES public.tenants(id) ON DELETE CASCADE,
  user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
  event_type TEXT NOT NULL CHECK (event_type IN (
    'login', 'logout', 'login_failed', 'signup',
    'password_reset_request', 'password_reset_complete',
    'email_verified'
  )),
  email TEXT,
  ip_address TEXT,
  user_agent TEXT,
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_auth_events_tenant_id ON public.auth_events(tenant_id);
CREATE INDEX idx_auth_events_user_id ON public.auth_events(user_id);
CREATE INDEX idx_auth_events_created_at ON public.auth_events(created_at DESC);
CREATE INDEX idx_auth_events_event_type ON public.auth_events(event_type);

-- Enable RLS
ALTER TABLE public.auth_events ENABLE ROW LEVEL SECURITY;

-- Directors and managers can view auth events for their tenant
CREATE POLICY "auth_events_tenant_read" ON public.auth_events
  FOR SELECT TO authenticated
  USING (tenant_id = (SELECT auth.tenant_id()));

-- Insert allowed for authenticated users (frontend logs events)
CREATE POLICY "auth_events_insert" ON public.auth_events
  FOR INSERT TO authenticated
  WITH CHECK (true);  -- Allow any insert, tenant_id can be null for failed logins

-- Grant permissions
GRANT SELECT, INSERT ON public.auth_events TO authenticated;

COMMENT ON TABLE public.auth_events IS 'Authentication event log for security auditing';
```
  </action>
  <verify>Both SQL files exist with CREATE TABLE statements</verify>
  <done>
- 00004_audit_log.sql creates audit_log table with trigger function
- 00005_auth_events.sql creates auth_events table for SEC-02
  </done>
</task>

</tasks>

<verification>
- [ ] supabase/config.toml exists
- [ ] supabase/migrations/ directory contains 5 SQL files (00001-00005)
- [ ] All tables with tenant data have `ENABLE ROW LEVEL SECURITY`
- [ ] All RLS policies use `auth.tenant_id()` function (not hardcoded)
- [ ] Indexes exist on tenant_id columns
- [ ] audit_changes() trigger function created
</verification>

<success_criteria>
Database schema migrations are ready to apply. All multi-tenant tables have RLS policies that enforce tenant isolation using auth.tenant_id() helper function.
</success_criteria>

<output>
After completion, create `.planning/phases/21-database-auth-foundation/21-02-SUMMARY.md`
</output>
