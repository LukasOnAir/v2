---
phase: 21-database-auth-foundation
plan: 03
type: execute
wave: 2
depends_on: [21-01]
files_modified:
  - src/contexts/AuthContext.tsx
  - src/components/auth/ProtectedRoute.tsx
  - src/App.tsx
  - src/main.tsx
autonomous: true

must_haves:
  truths:
    - "AuthContext provides session, user, tenantId to entire app"
    - "Session persists across browser refresh"
    - "Auth state changes trigger re-renders in consuming components"
    - "Protected routes redirect to login when unauthenticated"
  artifacts:
    - path: "src/contexts/AuthContext.tsx"
      provides: "Auth state management via React Context"
      exports: ["AuthProvider", "useAuth"]
      min_lines: 80
    - path: "src/components/auth/ProtectedRoute.tsx"
      provides: "Route protection with email verification check"
      exports: ["ProtectedRoute"]
  key_links:
    - from: "src/contexts/AuthContext.tsx"
      to: "src/lib/supabase/client.ts"
      via: "Supabase auth methods"
      pattern: "supabase\\.auth\\."
    - from: "src/App.tsx"
      to: "src/contexts/AuthContext.tsx"
      via: "AuthProvider wrapper"
      pattern: "<AuthProvider>"
    - from: "src/components/auth/ProtectedRoute.tsx"
      to: "src/contexts/AuthContext.tsx"
      via: "useAuth hook"
      pattern: "useAuth\\(\\)"
---

<objective>
Create authentication context and update route protection for Supabase Auth.

Purpose: Centralize auth state management so any component can access session, user, and tenantId. Replace the mock auth in uiStore with real Supabase Auth.
Output: AuthProvider that wraps the app, useAuth hook for consuming auth state, updated ProtectedRoute that checks email verification.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/21-database-auth-foundation/21-RESEARCH.md

# Existing files to update
@src/components/auth/ProtectedRoute.tsx
@src/App.tsx
@src/main.tsx
@src/stores/uiStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AuthContext with Supabase integration</name>
  <files>src/contexts/AuthContext.tsx</files>
  <action>
Create `src/contexts/` directory if not exists.

Create `src/contexts/AuthContext.tsx` following RESEARCH.md Pattern 3:

```typescript
import { createContext, useContext, useEffect, useState, type ReactNode } from 'react'
import type { Session, User, AuthError } from '@supabase/supabase-js'
import { supabase } from '@/lib/supabase/client'

interface AuthContextType {
  session: Session | null
  user: User | null
  tenantId: string | null
  role: string | null
  isLoading: boolean
  signIn: (email: string, password: string) => Promise<{ error: AuthError | null }>
  signUp: (email: string, password: string) => Promise<{ error: AuthError | null }>
  signOut: () => Promise<void>
  resetPassword: (email: string) => Promise<{ error: AuthError | null }>
  updatePassword: (newPassword: string) => Promise<{ error: AuthError | null }>
}

const AuthContext = createContext<AuthContextType | undefined>(undefined)

export function AuthProvider({ children }: { children: ReactNode }) {
  const [session, setSession] = useState<Session | null>(null)
  const [isLoading, setIsLoading] = useState(true)

  // Extract tenant_id and role from app_metadata (NOT user_metadata - security critical)
  const tenantId = session?.user?.app_metadata?.tenant_id ?? null
  const role = session?.user?.app_metadata?.role ?? null

  useEffect(() => {
    // Get initial session
    supabase.auth.getSession().then(({ data: { session } }) => {
      setSession(session)
      setIsLoading(false)
    })

    // Subscribe to auth changes
    const { data: { subscription } } = supabase.auth.onAuthStateChange(
      (_event, session) => {
        setSession(session)
      }
    )

    return () => subscription.unsubscribe()
  }, [])

  const signIn = async (email: string, password: string) => {
    const { error } = await supabase.auth.signInWithPassword({ email, password })
    return { error }
  }

  const signUp = async (email: string, password: string) => {
    const { error } = await supabase.auth.signUp({
      email,
      password,
      options: {
        emailRedirectTo: `${window.location.origin}/auth/confirm`,
      },
    })
    return { error }
  }

  const signOut = async () => {
    await supabase.auth.signOut()
  }

  const resetPassword = async (email: string) => {
    const { error } = await supabase.auth.resetPasswordForEmail(email, {
      redirectTo: `${window.location.origin}/auth/reset-password`,
    })
    return { error }
  }

  const updatePassword = async (newPassword: string) => {
    const { error } = await supabase.auth.updateUser({ password: newPassword })
    return { error }
  }

  return (
    <AuthContext.Provider value={{
      session,
      user: session?.user ?? null,
      tenantId,
      role,
      isLoading,
      signIn,
      signUp,
      signOut,
      resetPassword,
      updatePassword,
    }}>
      {children}
    </AuthContext.Provider>
  )
}

export function useAuth() {
  const context = useContext(AuthContext)
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider')
  }
  return context
}
```

Key points:
- Uses app_metadata for tenant_id and role (NOT user_metadata)
- Handles session persistence automatically via Supabase
- Uses window.location.origin for redirect URLs (no hardcoded localhost)
- Exports both AuthProvider and useAuth
  </action>
  <verify>File exists and exports AuthProvider and useAuth</verify>
  <done>src/contexts/AuthContext.tsx created with full Supabase Auth integration</done>
</task>

<task type="auto">
  <name>Task 2: Update ProtectedRoute for Supabase Auth</name>
  <files>src/components/auth/ProtectedRoute.tsx</files>
  <action>
Replace the existing mock ProtectedRoute with Supabase-based version.

The existing ProtectedRoute uses `useUIStore.isAuthenticated`. Replace with `useAuth()` from AuthContext.

Add email verification check (AUTH-02):
- If user exists but `email_confirmed_at` is null, redirect to /verify-email
- This enforces email verification before app access

```typescript
import { Navigate, Outlet, useLocation } from 'react-router'
import { useAuth } from '@/contexts/AuthContext'

export function ProtectedRoute() {
  const { user, isLoading } = useAuth()
  const location = useLocation()

  // Show loading state while checking auth
  if (isLoading) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-surface-base">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-accent-500" />
      </div>
    )
  }

  // Not authenticated - redirect to login
  if (!user) {
    return <Navigate to="/login" state={{ from: location }} replace />
  }

  // AUTH-02: Require email verification before app access
  if (!user.email_confirmed_at) {
    return <Navigate to="/verify-email" state={{ email: user.email }} replace />
  }

  return <Outlet />
}
```

Keep the existing loading spinner style consistent with the app's design.
  </action>
  <verify>File imports useAuth from AuthContext, not useUIStore</verify>
  <done>ProtectedRoute uses Supabase Auth and checks email verification</done>
</task>

<task type="auto">
  <name>Task 3: Wrap App with AuthProvider</name>
  <files>
    src/App.tsx
    src/main.tsx
  </files>
  <action>
Update App.tsx to wrap routes with AuthProvider.

In App.tsx:
1. Import AuthProvider from '@/contexts/AuthContext'
2. Wrap BrowserRouter with AuthProvider (AuthProvider should be INSIDE BrowserRouter so auth components can use router hooks)

Actually, AuthProvider doesn't need router hooks, so it can wrap BrowserRouter. But conventionally it wraps inside for consistency.

Updated App.tsx structure:
```typescript
import { AuthProvider } from '@/contexts/AuthContext'
// ... other imports ...

function App() {
  return (
    <AuthProvider>
      <BrowserRouter>
        {/* existing Routes */}
      </BrowserRouter>
      <Toaster ... />
    </AuthProvider>
  )
}
```

Note: Keep the existing useEffect for runMigrationIfNeeded - that's for v1.0 LocalStorage migration, still needed.

Do NOT remove the uiStore usage yet - it still manages sidebar state and role selection for the demo. The auth part will be replaced gradually.
  </action>
  <verify>App.tsx has AuthProvider wrapping the content</verify>
  <done>AuthProvider wraps the application, auth context available everywhere</done>
</task>

</tasks>

<verification>
- [ ] src/contexts/AuthContext.tsx exports AuthProvider and useAuth
- [ ] AuthContext uses supabase.auth methods (not mock)
- [ ] tenantId extracted from app_metadata (not user_metadata)
- [ ] ProtectedRoute uses useAuth() hook
- [ ] ProtectedRoute checks email_confirmed_at for AUTH-02
- [ ] App.tsx wraps content with AuthProvider
- [ ] TypeScript compiles without errors: `npx tsc --noEmit`
</verification>

<success_criteria>
Auth context provides session state throughout the app. Protected routes enforce authentication and email verification.
</success_criteria>

<output>
After completion, create `.planning/phases/21-database-auth-foundation/21-03-SUMMARY.md`
</output>
