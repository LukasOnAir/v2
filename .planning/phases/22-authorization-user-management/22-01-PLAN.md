---
phase: 22-authorization-user-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/00008_pending_invitations.sql
  - supabase/migrations/00009_is_user_active.sql
  - supabase/migrations/00010_director_profile_policies.sql
autonomous: true

must_haves:
  truths:
    - "Pending invitations table exists with 7-day expiry default"
    - "Directors can insert and view invitations in their tenant"
    - "is_user_active() helper returns false for deactivated users"
    - "Directors can update is_active for users in their tenant (but not their own)"
  artifacts:
    - path: "supabase/migrations/00008_pending_invitations.sql"
      provides: "Invitation storage with 7-day expiry"
      contains: "INTERVAL '7 days'"
    - path: "supabase/migrations/00009_is_user_active.sql"
      provides: "RLS helper for deactivation check"
      contains: "is_user_active()"
    - path: "supabase/migrations/00010_director_profile_policies.sql"
      provides: "Director can manage user active status"
      contains: "director"
  key_links:
    - from: "pending_invitations"
      to: "profiles"
      via: "email matches on acceptance"
      pattern: "email.*tenant_id"
    - from: "director_profile_policies"
      to: "public.user_role()"
      via: "RLS policy check"
      pattern: "user_role.*director"
---

<objective>
Create database schema for user invitation flow and Director management capabilities.

Purpose: Enable Directors to invite users with 7-day expiring tokens and deactivate users without data deletion. This establishes the database foundation for USER-01, USER-02, USER-03, USER-04 requirements.

Output: Three SQL migrations - pending_invitations table, is_user_active() helper, and Director profile management policies.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-authorization-user-management/22-RESEARCH.md

# Existing migrations to understand naming/patterns
@supabase/migrations/00003_profiles.sql
@supabase/migrations/00002_rls_helper_functions.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create pending_invitations table migration</name>
  <files>supabase/migrations/00008_pending_invitations.sql</files>
  <action>
Create migration for pending_invitations table that stores invitation tokens with 7-day expiry.

Table structure:
- id: UUID PRIMARY KEY DEFAULT gen_random_uuid()
- tenant_id: UUID NOT NULL REFERENCES public.tenants(id) ON DELETE CASCADE
- email: TEXT NOT NULL (email of invited user)
- role: TEXT NOT NULL CHECK (role IN ('manager', 'risk-manager', 'control-owner', 'control-tester')) -- Directors cannot invite Directors
- token: UUID NOT NULL DEFAULT gen_random_uuid() (unique invitation token)
- invited_by: UUID NOT NULL REFERENCES auth.users(id) (who sent the invite)
- expires_at: TIMESTAMPTZ NOT NULL DEFAULT (NOW() + INTERVAL '7 days')
- accepted_at: TIMESTAMPTZ (null until accepted)
- created_at: TIMESTAMPTZ DEFAULT NOW()

Constraints:
- UNIQUE (tenant_id, email) to prevent duplicate invites
- CHECK role does NOT include 'director' (Directors bootstrap via other means)

Indexes:
- idx_pending_invitations_token ON (token) -- for acceptance lookup
- idx_pending_invitations_tenant ON (tenant_id) -- for RLS performance

RLS policies:
- Enable RLS on table
- "directors_manage_invitations" policy: Directors in same tenant can SELECT, INSERT, UPDATE, DELETE
  - USING: tenant_id = public.tenant_id() AND public.user_role() = 'director'
  - WITH CHECK: same conditions

Grant SELECT, INSERT, UPDATE, DELETE on pending_invitations TO authenticated.

Add table comment explaining purpose.
  </action>
  <verify>
Migration file exists at supabase/migrations/00008_pending_invitations.sql with:
- CREATE TABLE public.pending_invitations
- INTERVAL '7 days' for expires_at default
- RLS policy checking user_role() = 'director'
- Index on token column
  </verify>
  <done>pending_invitations table migration ready with 7-day expiry, Director-only RLS policy, and proper indexes</done>
</task>

<task type="auto">
  <name>Task 2: Create is_user_active() helper function migration</name>
  <files>supabase/migrations/00009_is_user_active.sql</files>
  <action>
Create migration for is_user_active() function that checks if current user is active in profiles table.

Function specification:
```sql
CREATE OR REPLACE FUNCTION public.is_user_active()
RETURNS BOOLEAN AS $$
  SELECT COALESCE(
    (SELECT is_active FROM public.profiles WHERE id = auth.uid()),
    FALSE
  );
$$ LANGUAGE sql STABLE SECURITY DEFINER;
```

Use SECURITY DEFINER so RLS policies can call this even when user's access is restricted.
Use STABLE because result doesn't change within a transaction.
Return FALSE if no profile found (fail-safe).

Add function comment explaining purpose: "Returns TRUE if current user's profile is_active, FALSE otherwise. Used in RLS policies to block deactivated users."

This function will be used in RLS policies to enforce the deactivation at database level (Pitfall 3 from research: deactivated user JWT is still valid until expiry, so must check at DB level).
  </action>
  <verify>
Migration file exists at supabase/migrations/00009_is_user_active.sql with:
- CREATE OR REPLACE FUNCTION public.is_user_active()
- RETURNS BOOLEAN
- SECURITY DEFINER
- Checks profiles.is_active
  </verify>
  <done>is_user_active() helper function ready for use in RLS policies</done>
</task>

<task type="auto">
  <name>Task 3: Create Director profile management policies migration</name>
  <files>supabase/migrations/00010_director_profile_policies.sql</files>
  <action>
Create migration that adds Director-specific policies to the profiles table for user management.

Policy 1 - Directors can update is_active for users in their tenant:
```sql
CREATE POLICY "directors_update_user_status" ON public.profiles
  FOR UPDATE TO authenticated
  USING (
    tenant_id = public.tenant_id()
    AND public.user_role() = 'director'
    AND id != auth.uid()  -- Cannot deactivate self (Pitfall 5 from research)
  )
  WITH CHECK (
    tenant_id = public.tenant_id()
    AND public.user_role() = 'director'
    AND id != auth.uid()
  );
```

The existing "profiles_self_update" policy handles users updating their own profile (name). This new policy allows Directors to update OTHER users' is_active status only.

Important: The existing policy allows self-update. This new policy ONLY handles Director -> other user updates. The id != auth.uid() check prevents Directors from modifying their own is_active status or role.

Add comments explaining the policy purpose and security consideration about self-modification prevention.
  </action>
  <verify>
Migration file exists at supabase/migrations/00010_director_profile_policies.sql with:
- CREATE POLICY "directors_update_user_status"
- user_role() = 'director' check
- id != auth.uid() check (prevents self-deactivation)
  </verify>
  <done>Director can deactivate/reactivate users in their tenant except themselves</done>
</task>

</tasks>

<verification>
All migrations follow established naming pattern (00008_, 00009_, 00010_).
Each migration is self-contained with CREATE statements, indexes, policies, grants, and comments.
RLS policies use existing helper functions (public.tenant_id(), public.user_role()).
No syntax errors in SQL (verify basic structure).
</verification>

<success_criteria>
1. Three migration files exist in supabase/migrations/
2. pending_invitations table has 7-day expiry default and Director-only RLS
3. is_user_active() function exists and returns boolean
4. Directors can update is_active for other users but not themselves
5. All files have proper comments explaining purpose
</success_criteria>

<output>
After completion, create `.planning/phases/22-authorization-user-management/22-01-SUMMARY.md`
</output>
