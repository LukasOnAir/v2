---
phase: 22-authorization-user-management
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/permissions.ts
  - src/hooks/usePermissions.ts
autonomous: true

must_haves:
  truths:
    - "Permission constants define all 5 roles with their capabilities"
    - "usePermissions returns real role from AuthContext when authenticated"
    - "usePermissions falls back to selectedRole for demo mode (no auth)"
    - "Director-specific permissions (canInviteUsers, canDeactivateUsers) are exposed"
  artifacts:
    - path: "src/lib/permissions.ts"
      provides: "Role constants and permission definitions"
      contains: "director"
      min_lines: 40
    - path: "src/hooks/usePermissions.ts"
      provides: "Role-based permission hook"
      contains: "useAuth"
  key_links:
    - from: "src/hooks/usePermissions.ts"
      to: "@/contexts/AuthContext"
      via: "useAuth import"
      pattern: "import.*useAuth.*AuthContext"
    - from: "src/hooks/usePermissions.ts"
      to: "src/lib/permissions.ts"
      via: "permission constants import"
      pattern: "import.*permissions"
---

<objective>
Establish the permission system with centralized role definitions and connect usePermissions to real authenticated role.

Purpose: Create a single source of truth for role capabilities (ROLE-01 through ROLE-07) and enable production mode where permissions come from JWT app_metadata. This is the foundation for role-based UI rendering (ROLE-07).

Output: Permission constants file and updated usePermissions hook that uses AuthContext role in production, falling back to demo role selector.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-authorization-user-management/22-RESEARCH.md

# Current implementations to update
@src/hooks/usePermissions.ts
@src/contexts/AuthContext.tsx
@src/stores/uiStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create permission constants file</name>
  <files>src/lib/permissions.ts</files>
  <action>
Create a new file that defines role constants and permission mappings as the single source of truth.

Content:

```typescript
/**
 * Role-based permission constants
 *
 * Role Hierarchy (most to least permissions):
 * Director > Manager > Risk Manager > Control Owner > Control Tester
 *
 * Director: Full organization management (users, roles) + Manager permissions
 * Manager: Approval authority + Risk Manager permissions
 * Risk Manager: Full ERM access (edit all entities)
 * Control Owner: View-only + can submit change requests
 * Control Tester: Most restricted - only assigned tests
 */

export const ROLES = {
  DIRECTOR: 'director',
  MANAGER: 'manager',
  RISK_MANAGER: 'risk-manager',
  CONTROL_OWNER: 'control-owner',
  CONTROL_TESTER: 'control-tester',
} as const

export type Role = (typeof ROLES)[keyof typeof ROLES]

// Roles that can be assigned to invited users (Director excluded - bootstrap only)
export const INVITABLE_ROLES: Role[] = [
  ROLES.MANAGER,
  ROLES.RISK_MANAGER,
  ROLES.CONTROL_OWNER,
  ROLES.CONTROL_TESTER,
]

// Human-readable role names for UI
export const ROLE_LABELS: Record<Role, string> = {
  [ROLES.DIRECTOR]: 'Director',
  [ROLES.MANAGER]: 'Manager',
  [ROLES.RISK_MANAGER]: 'Risk Manager',
  [ROLES.CONTROL_OWNER]: 'Control Owner',
  [ROLES.CONTROL_TESTER]: 'Control Tester',
}

// Role descriptions for UI tooltips/help text
export const ROLE_DESCRIPTIONS: Record<Role, string> = {
  [ROLES.DIRECTOR]: 'Full organization management: invite users, assign roles, manage settings',
  [ROLES.MANAGER]: 'Approve changes in four-eye workflow, all Risk Manager permissions',
  [ROLES.RISK_MANAGER]: 'Full ERM access: edit risks, controls, taxonomies, schedules',
  [ROLES.CONTROL_OWNER]: 'View-only access, can submit change requests for approval',
  [ROLES.CONTROL_TESTER]: 'Execute assigned control tests only',
}

/**
 * Check if role has Director-level permissions
 */
export function isDirectorRole(role: Role | null): boolean {
  return role === ROLES.DIRECTOR
}

/**
 * Check if role has Manager-level permissions (Manager or Director)
 */
export function isManagerRole(role: Role | null): boolean {
  return role === ROLES.MANAGER || role === ROLES.DIRECTOR
}

/**
 * Check if role has Risk Manager-level permissions (Risk Manager, Manager, or Director)
 */
export function isRiskManagerRole(role: Role | null): boolean {
  return role === ROLES.RISK_MANAGER || isManagerRole(role)
}
```
  </action>
  <verify>
File exists at src/lib/permissions.ts with:
- ROLES constant with all 5 roles
- Role type export
- INVITABLE_ROLES array (excludes director)
- ROLE_LABELS for UI
- isDirectorRole, isManagerRole, isRiskManagerRole helpers
  </verify>
  <done>Centralized permission constants ready for use across codebase</done>
</task>

<task type="auto">
  <name>Task 2: Update usePermissions hook to use AuthContext</name>
  <files>src/hooks/usePermissions.ts</files>
  <action>
Update the existing usePermissions hook to:
1. Import useAuth from AuthContext
2. Use real role from AuthContext when authenticated
3. Fall back to selectedRole from uiStore for demo mode
4. Add Director-specific permissions

Updated implementation:

```typescript
import { useAuth } from '@/contexts/AuthContext'
import { useUIStore } from '@/stores/uiStore'
import {
  Role,
  ROLES,
  isDirectorRole,
  isManagerRole,
  isRiskManagerRole
} from '@/lib/permissions'

/**
 * Role-based permissions hook
 *
 * In production: Uses role from AuthContext (JWT app_metadata)
 * In demo mode: Uses selectedRole from uiStore (role selector)
 *
 * Role hierarchy (most to least permissions):
 * Director > Manager > Risk Manager > Control Owner > Control Tester
 */
export function usePermissions() {
  const { role: authRole } = useAuth()
  const selectedRole = useUIStore((state) => state.selectedRole)

  // Use real auth role in production, fall back to selectedRole for demo
  // Demo mode detected when no authenticated role (user not logged in or no role assigned)
  const isDemoMode = !authRole
  const role = (isDemoMode ? selectedRole : authRole) as Role | null

  const isDirector = isDirectorRole(role)
  const isManager = isManagerRole(role)  // Director inherits Manager
  const isRiskManager = isRiskManagerRole(role)  // Manager inherits Risk Manager
  const isControlOwner = role === ROLES.CONTROL_OWNER
  const isControlTester = role === ROLES.CONTROL_TESTER

  return {
    // === Director-only permissions (USER MANAGEMENT) ===
    canInviteUsers: isDirector,
    canDeactivateUsers: isDirector,
    canAssignRoles: isDirector,
    canViewUserList: isDirector,

    // === Edit permissions - Risk Manager and above ===
    canEditGrossScores: isRiskManager,
    canEditNetScores: isRiskManager,
    canEditControlDefinitions: isRiskManager,
    canEditControlAssessments: isRiskManager,
    canEditTaxonomies: isRiskManager,
    canManageCustomColumns: isRiskManager,
    canEditCustomColumnValues: isRiskManager,

    // === View permissions - Tester most restricted ===
    canViewAll: !isControlTester,

    // === Change request - Control Owner only ===
    canSubmitChangeRequests: isControlOwner,

    // === Test-related permissions ===
    canRecordTestResults: true,  // All roles including tester
    canEditTestSchedule: isRiskManager,
    canViewTestHistory: true,

    // === Manager-only permissions (four-eye approval) ===
    canApproveChanges: isManager,
    canRejectChanges: isManager,
    canToggleFourEye: isManager,
    canRegenerateRCT: isManager,

    // === Page visibility (Control Tester sees only My Controls) ===
    isControlTester,
    canViewTaxonomies: !isControlTester,
    canViewRCT: !isControlTester,
    canViewControlsHub: !isControlTester,
    canViewMatrix: !isControlTester,
    canViewSunburst: !isControlTester,
    canViewRemediation: !isControlTester,
    canViewTickets: !isControlTester,
    canViewAudit: !isControlTester,
    canViewApproval: isManager,
    canViewAnalytics: !isControlTester,
    canViewKnowledgeBase: !isControlTester,
    canViewUserManagement: isDirector,  // NEW: Director-only admin page

    // === Profile permissions ===
    canEditOwnProfile: true,  // All users can edit their own name/password

    // === Utility ===
    role,
    isDirector,
    isManager,
    isRiskManager,
    isControlOwner,
    isDemoMode,
  }
}
```

Key changes from existing:
- Import useAuth and permission helpers
- Add isDemoMode detection logic
- Add Director-specific permissions (canInviteUsers, canDeactivateUsers, canAssignRoles, canViewUserList, canViewUserManagement)
- Add canEditOwnProfile for profile page access
- Export isDemoMode for components that need to know
  </action>
  <verify>
File updated at src/hooks/usePermissions.ts with:
- import { useAuth } from '@/contexts/AuthContext'
- import from '@/lib/permissions'
- isDemoMode logic (checks if authRole is null)
- canInviteUsers, canDeactivateUsers, canViewUserManagement permissions
- canEditOwnProfile permission
  </verify>
  <done>usePermissions hook connected to AuthContext with Director permissions and demo mode fallback</done>
</task>

</tasks>

<verification>
Both files compile without TypeScript errors (check with tsc --noEmit if available).
Permission constants are properly typed with Role type.
usePermissions hook imports both useAuth and uiStore.
Demo mode logic correctly falls back to selectedRole when no authRole.
All existing permission flags preserved (backwards compatible).
</verification>

<success_criteria>
1. src/lib/permissions.ts exists with ROLES, Role type, INVITABLE_ROLES, ROLE_LABELS
2. src/hooks/usePermissions.ts imports useAuth from AuthContext
3. usePermissions returns real role when authenticated, selectedRole when in demo mode
4. Director-specific permissions (canInviteUsers, canDeactivateUsers, canViewUserManagement) are exposed
5. Existing permission flags (canEditGrossScores, canApproveChanges, etc.) still work
</success_criteria>

<output>
After completion, create `.planning/phases/22-authorization-user-management/22-02-SUMMARY.md`
</output>
