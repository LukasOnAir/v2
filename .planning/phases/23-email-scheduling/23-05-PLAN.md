---
phase: 23-email-scheduling
plan: 05
type: execute
wave: 3
depends_on: [23-02, 23-04]
files_modified:
  - src/stores/approvalStore.ts
  - src/hooks/useSendNotification.ts
  - src/components/controls/ControlDetailPanel.tsx
autonomous: true

must_haves:
  truths:
    - "Creating a pending change triggers notification to Managers"
    - "Approving/rejecting a change triggers notification to submitter"
    - "Assigning a tester to a control triggers notification to tester"
  artifacts:
    - path: "src/hooks/useSendNotification.ts"
      provides: "Hook for calling send-notification Edge Function"
      min_lines: 30
      exports: ["useSendNotification"]
    - path: "src/stores/approvalStore.ts"
      provides: "Approval store with notification triggers"
      contains: "sendNotification"
    - path: "src/components/controls/ControlDetailPanel.tsx"
      provides: "Control panel with tester assignment notification"
      contains: "sendNotification"
  key_links:
    - from: "src/stores/approvalStore.ts"
      to: "src/hooks/useSendNotification.ts"
      via: "Hook call on approval events"
      pattern: "sendNotification.*approval"
    - from: "src/components/controls/ControlDetailPanel.tsx"
      to: "src/hooks/useSendNotification.ts"
      via: "Hook call on tester assignment"
      pattern: "sendNotification.*test-assigned"
---

<objective>
Wire frontend to send-notification Edge Function: trigger notifications on approval requests, approval results, and tester assignments.

Purpose: Complete the notification flow by connecting frontend events to the notification Edge Function. Fulfills EMAIL-05, EMAIL-06, EMAIL-07 integration.

Output: useSendNotification hook and integration points in approval store and control detail panel.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/23-email-scheduling/23-02-SUMMARY.md
@.planning/phases/23-email-scheduling/23-04-SUMMARY.md

# Existing patterns
@src/stores/approvalStore.ts
@src/components/controls/ControlDetailPanel.tsx
@src/contexts/AuthContext.tsx
@src/lib/supabase/client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useSendNotification Hook</name>
  <files>src/hooks/useSendNotification.ts</files>
  <action>
Create a hook to call the send-notification Edge Function:

```typescript
import { useCallback } from 'react'
import { supabase } from '@/lib/supabase/client'

type NotificationType = 'approval-request' | 'approval-result' | 'test-assigned'

interface NotificationData {
  // For approval-request
  entityType?: string
  entityName?: string
  changeType?: string
  submitterName?: string
  // For approval-result
  result?: 'approved' | 'rejected'
  reviewerName?: string
  rejectionReason?: string
  // For test-assigned
  controlName?: string
  dueDate?: string
}

interface SendNotificationOptions {
  type: NotificationType
  recipientId: string
  data: NotificationData
}

export function useSendNotification() {
  const sendNotification = useCallback(async (options: SendNotificationOptions) => {
    try {
      // Get current session for auth header
      const { data: { session } } = await supabase.auth.getSession()
      if (!session) {
        console.warn('No session available for notification')
        return { success: false, error: 'Not authenticated' }
      }

      const response = await fetch(
        `${import.meta.env.VITE_SUPABASE_URL}/functions/v1/send-notification`,
        {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${session.access_token}`,
          },
          body: JSON.stringify(options),
        }
      )

      const result = await response.json()

      if (!response.ok) {
        console.error('Notification failed:', result)
        return { success: false, error: result.error }
      }

      return { success: true, emailSent: result.emailSent }
    } catch (error) {
      console.error('Notification error:', error)
      return { success: false, error: 'Network error' }
    }
  }, [])

  return { sendNotification }
}
```

Key points:
- Uses Supabase session token for authentication
- Non-blocking (doesn't throw, returns result object)
- Logs errors but doesn't interrupt user flow
- Uses VITE_SUPABASE_URL environment variable
  </action>
  <verify>
1. File exists at src/hooks/useSendNotification.ts
2. Contains sendNotification function with type, recipientId, data parameters
3. Uses supabase.auth.getSession() for authentication
4. Returns { success, emailSent } result object
  </verify>
  <done>
Hook created for calling send-notification Edge Function with authentication.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire Approval Store to Send Notifications</name>
  <files>src/stores/approvalStore.ts</files>
  <action>
The approval store uses Zustand and can't directly use React hooks. Instead, create a notification helper that can be called from the store:

1. Create a notification utility function at the top of the file or in a separate utility:

```typescript
// Can be called from non-React context (Zustand store)
async function sendApprovalNotification(
  type: 'approval-request' | 'approval-result',
  recipientId: string,
  data: Record<string, unknown>
) {
  try {
    // Direct fetch without React hooks
    const { data: { session } } = await supabase.auth.getSession()
    if (!session) return

    await fetch(
      `${import.meta.env.VITE_SUPABASE_URL}/functions/v1/send-notification`,
      {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${session.access_token}`,
        },
        body: JSON.stringify({ type, recipientId, data }),
      }
    )
  } catch (error) {
    console.error('Notification failed:', error)
  }
}
```

2. In `createPendingChange`:
   - After successfully creating/merging the pending change
   - Find all Managers in the tenant (need to query profiles)
   - Send 'approval-request' notification to each Manager
   - Data: { entityType, entityName, changeType, submitterName }

3. In `approveChange`:
   - After updating status to 'approved'
   - Send 'approval-result' notification to `change.submittedBy`
   - Data: { entityName, result: 'approved', reviewerName }

4. In `rejectChange`:
   - After updating status to 'rejected'
   - Send 'approval-result' notification to `change.submittedBy`
   - Data: { entityName, result: 'rejected', reviewerName, rejectionReason }

Note: For finding Managers, query profiles table with role='manager'. This requires adding Supabase client import.

IMPORTANT: Notifications are fire-and-forget. Don't await or block the main approval flow.
  </action>
  <verify>
1. approvalStore.ts contains notification utility function
2. createPendingChange calls sendApprovalNotification
3. approveChange calls sendApprovalNotification with result: 'approved'
4. rejectChange calls sendApprovalNotification with result: 'rejected'
5. No await blocks the main approval flow
  </verify>
  <done>
Approval store wired to send notifications on:
- New pending change (to Managers)
- Approval (to submitter)
- Rejection (to submitter with reason)
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire Control Detail Panel for Tester Assignment</name>
  <files>src/components/controls/ControlDetailPanel.tsx</files>
  <action>
Add notification trigger when tester is assigned to a control:

1. Read ControlDetailPanel.tsx to find where assignedTesterId is updated
2. Import the useSendNotification hook
3. When assignedTesterId changes to a non-null value (new assignment):
   - Send 'test-assigned' notification to the new tester
   - Data: { controlName, dueDate: nextTestDate }

Look for:
- onChange handler for tester dropdown/select
- useEffect that reacts to assignedTesterId changes
- A save/update function that persists the assignment

Add notification call AFTER the assignment is saved to the store/database.

Example integration:
```typescript
const { sendNotification } = useSendNotification()

// In the assignment handler or save function:
if (newTesterId && newTesterId !== previousTesterId) {
  sendNotification({
    type: 'test-assigned',
    recipientId: newTesterId,
    data: {
      controlName: control.name,
      dueDate: control.nextTestDate || undefined,
    },
  })
}
```

Note: Only send notification when:
- A tester is being assigned (not cleared)
- The tester is different from before (not re-saving same tester)
  </action>
  <verify>
1. ControlDetailPanel.tsx imports useSendNotification
2. Contains sendNotification call when tester assigned
3. Only triggers for new assignments (not clears or re-saves)
4. Passes controlName and dueDate in notification data
  </verify>
  <done>
ControlDetailPanel wired to send test-assigned notifications when tester is assigned.
  </done>
</task>

</tasks>

<verification>
- [ ] src/hooks/useSendNotification.ts exists with sendNotification function
- [ ] src/stores/approvalStore.ts calls notifications on create/approve/reject
- [ ] src/components/controls/ControlDetailPanel.tsx calls notification on tester assignment
- [ ] No notification calls block user interactions (fire-and-forget pattern)
</verification>

<success_criteria>
- useSendNotification hook provides authenticated Edge Function calls
- Approval store triggers notifications for all approval workflow events
- Control detail panel triggers notification on tester assignment
- All notifications are non-blocking (don't interrupt user flow on failure)
</success_criteria>

<output>
After completion, create `.planning/phases/23-email-scheduling/23-05-SUMMARY.md`

Document:
- Integration points for each notification type
- How notifications are triggered (which user actions)
- Error handling approach (fire-and-forget)
- How to test each notification type
</output>
