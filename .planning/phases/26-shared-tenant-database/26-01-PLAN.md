---
phase: 26-shared-tenant-database
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/00013_taxonomy_nodes.sql
  - supabase/migrations/00014_taxonomy_weights.sql
  - supabase/migrations/00015_controls.sql
  - supabase/migrations/00016_control_links.sql
  - supabase/migrations/00017_rct_rows.sql
autonomous: true

must_haves:
  truths:
    - "taxonomy_nodes table exists with RLS policy for tenant isolation"
    - "taxonomy_weights table exists with RLS policy for tenant isolation"
    - "controls table exists with RLS policy for tenant isolation"
    - "control_links table exists with RLS policy for tenant isolation"
    - "rct_rows table exists with RLS policy for tenant isolation"
  artifacts:
    - path: "supabase/migrations/00013_taxonomy_nodes.sql"
      provides: "Taxonomy nodes table with hierarchical structure"
      contains: "CREATE TABLE public.taxonomy_nodes"
    - path: "supabase/migrations/00014_taxonomy_weights.sql"
      provides: "Taxonomy weights table for level and node weights"
      contains: "CREATE TABLE public.taxonomy_weights"
    - path: "supabase/migrations/00015_controls.sql"
      provides: "Controls table for global control definitions"
      contains: "CREATE TABLE public.controls"
    - path: "supabase/migrations/00016_control_links.sql"
      provides: "Control-to-RCT-row junction table"
      contains: "CREATE TABLE public.control_links"
    - path: "supabase/migrations/00017_rct_rows.sql"
      provides: "RCT rows table for risk-process combinations"
      contains: "CREATE TABLE public.rct_rows"
  key_links:
    - from: "supabase/migrations/00013_taxonomy_nodes.sql"
      to: "public.tenant_id()"
      via: "RLS policy using tenant isolation helper"
      pattern: "tenant_id = \\(SELECT public\\.tenant_id\\(\\)\\)"
---

<objective>
Create the core database schema migrations for taxonomy nodes, weights, controls, control links, and RCT rows.

Purpose: These are the foundational tables that store the primary application data - risk/process taxonomies and the Risk Control Table matrix. Without these tables, no shared tenant data can be persisted.

Output: 5 SQL migration files that create tables with proper indexes, RLS policies, and grants.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-shared-tenant-database/26-RESEARCH.md

# Existing migrations for reference
@supabase/migrations/00002_rls_helper_functions.sql
@supabase/migrations/00001_tenants.sql
@supabase/migrations/00003_profiles.sql

# Type definitions for schema alignment
@src/types/taxonomy.ts
@src/types/rct.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create taxonomy_nodes migration</name>
  <files>supabase/migrations/00013_taxonomy_nodes.sql</files>
  <action>
Create migration for taxonomy_nodes table following the schema from 26-RESEARCH.md:

```sql
-- TAXONOMY: Hierarchical tree with adjacency list + path cache
-- Stores both risk and process taxonomies in single table
CREATE TABLE public.taxonomy_nodes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES public.tenants(id) ON DELETE CASCADE,
  type TEXT NOT NULL CHECK (type IN ('risk', 'process')),
  parent_id UUID REFERENCES public.taxonomy_nodes(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  description TEXT DEFAULT '',
  hierarchical_id TEXT NOT NULL DEFAULT '',
  path UUID[] DEFAULT '{}',
  sort_order INT DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes (use subquery pattern for RLS performance)
CREATE INDEX idx_taxonomy_tenant_type ON public.taxonomy_nodes(tenant_id, type);
CREATE INDEX idx_taxonomy_parent ON public.taxonomy_nodes(parent_id);
CREATE INDEX idx_taxonomy_path ON public.taxonomy_nodes USING GIN(path);

-- RLS
ALTER TABLE public.taxonomy_nodes ENABLE ROW LEVEL SECURITY;

CREATE POLICY "taxonomy_tenant_isolation" ON public.taxonomy_nodes
  FOR ALL TO authenticated
  USING (tenant_id = (SELECT public.tenant_id()))
  WITH CHECK (tenant_id = (SELECT public.tenant_id()));

GRANT SELECT, INSERT, UPDATE, DELETE ON public.taxonomy_nodes TO authenticated;
```

Also add the trigger function for auto-generating hierarchical IDs:

```sql
-- Generate hierarchical ID based on sibling count and parent path
CREATE OR REPLACE FUNCTION generate_hierarchical_id()
RETURNS TRIGGER AS $$
DECLARE
  parent_hid TEXT;
  sibling_count INT;
BEGIN
  -- Get parent's hierarchical_id
  IF NEW.parent_id IS NULL THEN
    parent_hid := '';
  ELSE
    SELECT hierarchical_id INTO parent_hid
    FROM public.taxonomy_nodes
    WHERE id = NEW.parent_id;
  END IF;

  -- Count siblings (same parent, same tenant, same type)
  SELECT COUNT(*) INTO sibling_count
  FROM public.taxonomy_nodes
  WHERE tenant_id = NEW.tenant_id
    AND type = NEW.type
    AND COALESCE(parent_id::text, '') = COALESCE(NEW.parent_id::text, '')
    AND id != NEW.id;

  -- Generate hierarchical_id
  IF parent_hid = '' OR parent_hid IS NULL THEN
    NEW.hierarchical_id := (sibling_count + 1)::TEXT;
  ELSE
    NEW.hierarchical_id := parent_hid || '.' || (sibling_count + 1)::TEXT;
  END IF;

  -- Update path array
  IF NEW.parent_id IS NULL THEN
    NEW.path := ARRAY[NEW.id];
  ELSE
    SELECT path || NEW.id INTO NEW.path
    FROM public.taxonomy_nodes
    WHERE id = NEW.parent_id;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_taxonomy_hierarchical_id
  BEFORE INSERT ON public.taxonomy_nodes
  FOR EACH ROW
  EXECUTE FUNCTION generate_hierarchical_id();
```

Include COMMENT statements for documentation.
  </action>
  <verify>Run `npx supabase migration list` and verify 00013 is listed. Run `npx supabase db push --dry-run` to validate syntax.</verify>
  <done>taxonomy_nodes table migration file exists with table, indexes, RLS policy, trigger, and grants</done>
</task>

<task type="auto">
  <name>Task 2: Create taxonomy_weights, controls, control_links, and rct_rows migrations</name>
  <files>
    supabase/migrations/00014_taxonomy_weights.sql
    supabase/migrations/00015_controls.sql
    supabase/migrations/00016_control_links.sql
    supabase/migrations/00017_rct_rows.sql
  </files>
  <action>
Create four migration files following the schemas from 26-RESEARCH.md:

**00014_taxonomy_weights.sql:**
- Table for per-node and per-level weight configuration
- Columns: id, tenant_id, type (risk/process), node_id (nullable for level defaults), level (1-5), weight
- UNIQUE constraint on (tenant_id, type, node_id, level)
- RLS policy using (SELECT public.tenant_id()) pattern
- Index on (tenant_id, type)

**00015_controls.sql:**
- Global control definitions within tenant
- Columns from Control type in src/types/rct.ts: id, tenant_id, name, description, control_type, net_probability, net_impact, net_score (GENERATED), test_frequency, next_test_date, last_test_date, test_procedure, assigned_tester_id (FK to profiles), comment, created_at, updated_at
- RLS policy with tenant isolation
- Indexes on tenant_id and assigned_tester_id

**00016_control_links.sql:**
- Junction table for many-to-many between controls and RCT rows
- Columns from ControlLink type: id, tenant_id, control_id (FK), rct_row_id (FK), net_probability, net_impact, net_score (GENERATED), created_at
- UNIQUE constraint on (control_id, rct_row_id)
- RLS policy with tenant isolation
- Indexes on tenant_id, control_id, rct_row_id

**00017_rct_rows.sql:**
- Risk-Process combinations with scores
- Columns from RCTRow type: id, tenant_id, row_id (composite text key), risk_id (FK to taxonomy_nodes), process_id (FK to taxonomy_nodes), gross_probability, gross_impact, gross_score (GENERATED), gross_probability_comment, gross_impact_comment, risk_appetite, within_appetite (GENERATED), custom_values (JSONB), created_at, updated_at
- UNIQUE constraint on (tenant_id, row_id)
- RLS policy with tenant isolation
- Indexes on tenant_id, row_id, risk_id, process_id, and GIN index on custom_values

Use proper foreign key constraints with ON DELETE CASCADE where appropriate. Add COMMENT statements for documentation.
  </action>
  <verify>Run `npx supabase migration list` and verify 00014-00017 are listed. Run `npx supabase db push --dry-run` to validate syntax and foreign key references.</verify>
  <done>All four migration files exist with tables, indexes, RLS policies, and grants. Foreign key relationships correctly reference parent tables.</done>
</task>

<task type="auto">
  <name>Task 3: Push migrations to Supabase and generate types</name>
  <files>src/types/database.types.ts</files>
  <action>
Run the Supabase migrations and regenerate TypeScript types:

1. Push migrations to database:
   ```bash
   npx supabase db push
   ```

2. Regenerate TypeScript types:
   ```bash
   npx supabase gen types typescript --local > src/types/database.types.ts
   ```

3. Verify the generated types include:
   - `taxonomy_nodes` table with all columns
   - `taxonomy_weights` table
   - `controls` table
   - `control_links` table
   - `rct_rows` table

If there are any migration errors, fix them and re-run. Common issues:
- Missing foreign key targets (ensure migrations run in order)
- Type mismatches in GENERATED columns
- Invalid CHECK constraints
  </action>
  <verify>Run `npx supabase db push` successfully with no errors. Verify database.types.ts contains interfaces for taxonomy_nodes, taxonomy_weights, controls, control_links, and rct_rows.</verify>
  <done>Migrations applied to database, TypeScript types regenerated with all new table types</done>
</task>

</tasks>

<verification>
- [ ] All 5 migration files exist in supabase/migrations/
- [ ] `npx supabase db push` completes without errors
- [ ] database.types.ts includes all new table types
- [ ] RLS policies use (SELECT public.tenant_id()) pattern for performance
- [ ] GENERATED columns correctly compute scores
- [ ] Foreign keys reference correct parent tables
</verification>

<success_criteria>
- 5 migration files created (00013-00017)
- Migrations apply successfully to local Supabase
- TypeScript types regenerated with new tables
- taxonomy_nodes trigger auto-generates hierarchical_id on insert
</success_criteria>

<output>
After completion, create `.planning/phases/26-shared-tenant-database/26-01-SUMMARY.md`
</output>
