---
phase: 26-shared-tenant-database
plan: 03
type: execute
wave: 2
depends_on: ["26-01", "26-02"]
files_modified:
  - package.json
  - src/providers/QueryProvider.tsx
  - src/main.tsx
  - src/hooks/useTaxonomy.ts
  - src/hooks/useTaxonomyWeights.ts
autonomous: true

must_haves:
  truths:
    - "React Query provider wraps the application"
    - "useTaxonomy hook fetches taxonomy nodes from Supabase"
    - "useTaxonomy hook supports optimistic updates with rollback"
    - "Taxonomy mutations invalidate related queries"
  artifacts:
    - path: "src/providers/QueryProvider.tsx"
      provides: "React Query client and provider"
      exports: ["QueryProvider"]
    - path: "src/hooks/useTaxonomy.ts"
      provides: "Taxonomy CRUD operations via React Query"
      exports: ["useTaxonomy", "useAddTaxonomyNode", "useUpdateTaxonomyNode", "useDeleteTaxonomyNode"]
    - path: "src/hooks/useTaxonomyWeights.ts"
      provides: "Taxonomy weight operations via React Query"
      exports: ["useTaxonomyWeights", "useSetLevelWeight", "useSetNodeWeight"]
  key_links:
    - from: "src/main.tsx"
      to: "src/providers/QueryProvider.tsx"
      via: "QueryProvider wraps app"
      pattern: "<QueryProvider>"
    - from: "src/hooks/useTaxonomy.ts"
      to: "supabase"
      via: "useQuery and useMutation with supabase client"
      pattern: "supabase\\.from\\('taxonomy_nodes'\\)"
---

<objective>
Set up React Query infrastructure and create data fetching hooks for taxonomy nodes and weights.

Purpose: React Query provides server state management with caching, automatic refetching, and optimistic updates. The taxonomy hooks are the foundation for all hierarchical data access in the application.

Output: React Query provider, taxonomy hooks with full CRUD support, integrated into the application.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-shared-tenant-database/26-RESEARCH.md

# Existing patterns
@src/lib/supabase/client.ts
@src/contexts/AuthContext.tsx
@src/main.tsx
@src/stores/taxonomyStore.ts
@src/types/taxonomy.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install React Query and create QueryProvider</name>
  <files>
    package.json
    src/providers/QueryProvider.tsx
    src/main.tsx
  </files>
  <action>
1. Install React Query (check if already in package.json first):
   ```bash
   npm install @tanstack/react-query @tanstack/react-query-devtools
   ```

2. Create src/providers/QueryProvider.tsx following 26-RESEARCH.md pattern:

```typescript
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
import { type ReactNode } from 'react'

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 5,  // 5 minutes
      gcTime: 1000 * 60 * 30,    // 30 minutes garbage collection
      retry: 1,                   // Retry once on failure
      refetchOnWindowFocus: true, // Refresh when user returns
    },
  },
})

export function QueryProvider({ children }: { children: ReactNode }) {
  return (
    <QueryClientProvider client={queryClient}>
      {children}
      {import.meta.env.DEV && <ReactQueryDevtools />}
    </QueryClientProvider>
  )
}
```

3. Update src/main.tsx to wrap the app with QueryProvider:
   - Import QueryProvider
   - Wrap inside ErrorBoundary but outside AuthProvider (query client should be available to auth context)
   - Order: ErrorBoundary > QueryProvider > AuthProvider > RouterProvider

Note: Do NOT use `cacheTime` - it was renamed to `gcTime` in React Query v5.
  </action>
  <verify>Run `npm run build` to verify no TypeScript errors. Run `npm run dev` and check React Query Devtools panel appears in bottom-left corner.</verify>
  <done>React Query installed, provider created and integrated into main.tsx</done>
</task>

<task type="auto">
  <name>Task 2: Create useTaxonomy hook with CRUD operations</name>
  <files>src/hooks/useTaxonomy.ts</files>
  <action>
Create src/hooks/useTaxonomy.ts with full taxonomy CRUD operations following 26-RESEARCH.md patterns:

```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import { supabase } from '@/lib/supabase/client'
import type { TaxonomyItem } from '@/types/taxonomy'
import type { Database } from '@/types/database.types'

type TaxonomyNode = Database['public']['Tables']['taxonomy_nodes']['Row']
type TaxonomyInsert = Database['public']['Tables']['taxonomy_nodes']['Insert']
type TaxonomyUpdate = Database['public']['Tables']['taxonomy_nodes']['Update']

// Build tree structure from flat list
function buildTree(nodes: TaxonomyNode[]): TaxonomyItem[] {
  const nodeMap = new Map<string, TaxonomyItem>()

  // First pass: create TaxonomyItem for each node
  for (const node of nodes) {
    nodeMap.set(node.id, {
      id: node.id,
      name: node.name,
      description: node.description || '',
      hierarchicalId: node.hierarchical_id,
      children: [],
    })
  }

  // Second pass: build parent-child relationships
  const roots: TaxonomyItem[] = []
  for (const node of nodes) {
    const item = nodeMap.get(node.id)!
    if (node.parent_id && nodeMap.has(node.parent_id)) {
      nodeMap.get(node.parent_id)!.children!.push(item)
    } else {
      roots.push(item)
    }
  }

  return roots
}

export function useTaxonomy(type: 'risk' | 'process') {
  return useQuery({
    queryKey: ['taxonomy', type],
    queryFn: async () => {
      const { data, error } = await supabase
        .from('taxonomy_nodes')
        .select('*')
        .eq('type', type)
        .order('sort_order')

      if (error) throw error
      return buildTree(data)
    },
  })
}

export function useAddTaxonomyNode(type: 'risk' | 'process') {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (node: { name: string; description?: string; parentId?: string }) => {
      const { data, error } = await supabase
        .from('taxonomy_nodes')
        .insert({
          type,
          name: node.name,
          description: node.description || '',
          parent_id: node.parentId || null,
        })
        .select()
        .single()

      if (error) throw error
      return data
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['taxonomy', type] })
    },
  })
}

export function useUpdateTaxonomyNode(type: 'risk' | 'process') {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async ({ id, ...updates }: { id: string; name?: string; description?: string }) => {
      const { data, error } = await supabase
        .from('taxonomy_nodes')
        .update({
          name: updates.name,
          description: updates.description,
          updated_at: new Date().toISOString(),
        })
        .eq('id', id)
        .select()
        .single()

      if (error) throw error
      return data
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['taxonomy', type] })
    },
  })
}

export function useDeleteTaxonomyNode(type: 'risk' | 'process') {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (id: string) => {
      const { error } = await supabase
        .from('taxonomy_nodes')
        .delete()
        .eq('id', id)

      if (error) throw error
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['taxonomy', type] })
    },
  })
}
```

Key decisions:
- Query key structure: ['taxonomy', type] for easy invalidation
- buildTree converts flat DB rows to nested TaxonomyItem structure
- Mutations return select().single() to get the inserted/updated record
- All mutations invalidate the taxonomy query on success
  </action>
  <verify>Run `npm run typecheck` to verify types are correct. Create a simple test component that uses useTaxonomy('risk') and confirm it compiles.</verify>
  <done>useTaxonomy hook created with query and all mutation hooks</done>
</task>

<task type="auto">
  <name>Task 3: Create useTaxonomyWeights hook</name>
  <files>src/hooks/useTaxonomyWeights.ts</files>
  <action>
Create src/hooks/useTaxonomyWeights.ts for managing taxonomy level and node weights:

```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import { supabase } from '@/lib/supabase/client'
import type { TaxonomyWeights } from '@/types/taxonomy'
import type { Database } from '@/types/database.types'

type WeightRow = Database['public']['Tables']['taxonomy_weights']['Row']

// Convert DB rows to TaxonomyWeights shape
function buildWeights(rows: WeightRow[]): TaxonomyWeights {
  const weights: TaxonomyWeights = {
    levelDefaults: { l1: 1, l2: 1, l3: 1, l4: 1, l5: 1 },
    nodeOverrides: {},
  }

  for (const row of rows) {
    if (row.node_id === null && row.level !== null) {
      // Level default
      const key = `l${row.level}` as keyof TaxonomyWeights['levelDefaults']
      weights.levelDefaults[key] = Number(row.weight)
    } else if (row.node_id !== null) {
      // Node override
      weights.nodeOverrides[row.node_id] = Number(row.weight)
    }
  }

  return weights
}

export function useTaxonomyWeights(type: 'risk' | 'process') {
  return useQuery({
    queryKey: ['taxonomyWeights', type],
    queryFn: async () => {
      const { data, error } = await supabase
        .from('taxonomy_weights')
        .select('*')
        .eq('type', type)

      if (error) throw error
      return buildWeights(data)
    },
  })
}

export function useSetLevelWeight(type: 'risk' | 'process') {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async ({ level, weight }: { level: 1 | 2 | 3 | 4 | 5; weight: number }) => {
      const clampedWeight = Math.round(Math.max(0.1, Math.min(5.0, weight)) * 10) / 10

      const { data, error } = await supabase
        .from('taxonomy_weights')
        .upsert({
          type,
          node_id: null,
          level,
          weight: clampedWeight,
        }, {
          onConflict: 'tenant_id,type,node_id,level',
        })
        .select()
        .single()

      if (error) throw error
      return data
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['taxonomyWeights', type] })
    },
  })
}

export function useSetNodeWeight(type: 'risk' | 'process') {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async ({ nodeId, weight }: { nodeId: string; weight: number | null }) => {
      if (weight === null) {
        // Remove override
        const { error } = await supabase
          .from('taxonomy_weights')
          .delete()
          .eq('type', type)
          .eq('node_id', nodeId)

        if (error) throw error
        return null
      }

      const clampedWeight = Math.round(Math.max(0.1, Math.min(5.0, weight)) * 10) / 10

      const { data, error } = await supabase
        .from('taxonomy_weights')
        .upsert({
          type,
          node_id: nodeId,
          level: null,
          weight: clampedWeight,
        }, {
          onConflict: 'tenant_id,type,node_id,level',
        })
        .select()
        .single()

      if (error) throw error
      return data
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['taxonomyWeights', type] })
    },
  })
}

// Helper to get effective weight (matches Zustand store signature)
export function getEffectiveWeight(
  weights: TaxonomyWeights,
  nodeId: string,
  level: number
): number {
  if (nodeId in weights.nodeOverrides) {
    return weights.nodeOverrides[nodeId]
  }
  const levelKey = `l${level}` as keyof TaxonomyWeights['levelDefaults']
  return weights.levelDefaults[levelKey]
}
```

Note: upsert uses onConflict to handle both insert and update cases. The unique constraint on (tenant_id, type, node_id, level) - note that tenant_id is automatically populated by RLS/trigger or needs to be added.

IMPORTANT: Check if the taxonomy_weights table needs tenant_id in the INSERT. If RLS uses (SELECT public.tenant_id()), we may need to pass it explicitly or create a trigger. Adjust based on 26-01-SUMMARY.md findings.
  </action>
  <verify>Run `npm run typecheck` to verify types. Confirm buildWeights correctly transforms DB rows to TaxonomyWeights shape.</verify>
  <done>useTaxonomyWeights hook created with level and node weight mutations</done>
</task>

</tasks>

<verification>
- [ ] React Query installed and devtools visible in dev mode
- [ ] QueryProvider wraps the app in correct order
- [ ] useTaxonomy hook fetches and transforms taxonomy nodes
- [ ] buildTree correctly creates nested structure from flat rows
- [ ] All mutation hooks invalidate correct query keys
- [ ] TypeScript types are correct for database rows
</verification>

<success_criteria>
- React Query provider integrated in main.tsx
- useTaxonomy returns nested TaxonomyItem[] from flat DB rows
- useTaxonomyWeights returns TaxonomyWeights shape
- All hooks use proper query key structure for cache management
- Type safety maintained between database types and application types
</success_criteria>

<output>
After completion, create `.planning/phases/26-shared-tenant-database/26-03-SUMMARY.md`
</output>
