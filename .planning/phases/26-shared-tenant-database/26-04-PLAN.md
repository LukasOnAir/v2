---
phase: 26-shared-tenant-database
plan: 04
type: execute
wave: 2
depends_on: ["26-01", "26-02"]
files_modified:
  - src/hooks/useControls.ts
  - src/hooks/useControlLinks.ts
  - src/hooks/useRCTRows.ts
  - src/hooks/useCustomColumns.ts
autonomous: true

must_haves:
  truths:
    - "useControls hook fetches controls from Supabase with CRUD operations"
    - "useControlLinks hook manages control-to-RCT-row links"
    - "useRCTRows hook fetches RCT rows with computed scores"
    - "Optimistic updates provide instant UI feedback"
  artifacts:
    - path: "src/hooks/useControls.ts"
      provides: "Control CRUD operations via React Query"
      exports: ["useControls", "useAddControl", "useUpdateControl", "useDeleteControl"]
    - path: "src/hooks/useControlLinks.ts"
      provides: "Control link operations via React Query"
      exports: ["useControlLinks", "useLinkControl", "useUnlinkControl", "useUpdateLink"]
    - path: "src/hooks/useRCTRows.ts"
      provides: "RCT row operations via React Query"
      exports: ["useRCTRows", "useUpdateRCTRow", "useDeleteRCTRow"]
    - path: "src/hooks/useCustomColumns.ts"
      provides: "Custom column operations via React Query"
      exports: ["useCustomColumns", "useAddCustomColumn", "useUpdateCustomColumn", "useDeleteCustomColumn"]
  key_links:
    - from: "src/hooks/useControls.ts"
      to: "supabase"
      via: "useQuery with supabase client"
      pattern: "supabase\\.from\\('controls'\\)"
    - from: "src/hooks/useRCTRows.ts"
      to: "supabase"
      via: "useQuery with supabase client"
      pattern: "supabase\\.from\\('rct_rows'\\)"
---

<objective>
Create data fetching hooks for controls, control links, RCT rows, and custom columns.

Purpose: These hooks provide the core RCT (Risk Control Table) data access layer. Controls are the mitigation measures, RCT rows are risk-process combinations, and control links connect them in a many-to-many relationship.

Output: 4 hook files with full CRUD support for the RCT domain.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-shared-tenant-database/26-RESEARCH.md

# Existing patterns
@src/stores/controlsStore.ts
@src/stores/rctStore.ts
@src/types/rct.ts
@src/hooks/useTaxonomy.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useControls hook with optimistic updates</name>
  <files>src/hooks/useControls.ts</files>
  <action>
Create src/hooks/useControls.ts with CRUD operations and optimistic updates:

```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import { supabase } from '@/lib/supabase/client'
import type { Control } from '@/types/rct'
import type { Database } from '@/types/database.types'
import { toast } from 'sonner'

type ControlRow = Database['public']['Tables']['controls']['Row']
type ControlInsert = Database['public']['Tables']['controls']['Insert']

// Transform DB row to Control type
function toControl(row: ControlRow): Control {
  return {
    id: row.id,
    name: row.name,
    description: row.description || undefined,
    controlType: row.control_type as Control['controlType'],
    netProbability: row.net_probability,
    netImpact: row.net_impact,
    netScore: row.net_score,
    comment: row.comment || undefined,
    testFrequency: row.test_frequency as Control['testFrequency'],
    nextTestDate: row.next_test_date,
    lastTestDate: row.last_test_date,
    testProcedure: row.test_procedure || undefined,
    assignedTesterId: row.assigned_tester_id,
  }
}

export function useControls() {
  return useQuery({
    queryKey: ['controls'],
    queryFn: async () => {
      const { data, error } = await supabase
        .from('controls')
        .select('*')
        .order('name')

      if (error) throw error
      return data.map(toControl)
    },
  })
}

export function useControlById(id: string | undefined) {
  return useQuery({
    queryKey: ['controls', id],
    queryFn: async () => {
      if (!id) return null
      const { data, error } = await supabase
        .from('controls')
        .select('*')
        .eq('id', id)
        .single()

      if (error) throw error
      return toControl(data)
    },
    enabled: !!id,
  })
}

export function useAddControl() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (control: Omit<Control, 'id' | 'netScore'>) => {
      const { data, error } = await supabase
        .from('controls')
        .insert({
          name: control.name,
          description: control.description || null,
          control_type: control.controlType,
          net_probability: control.netProbability,
          net_impact: control.netImpact,
          test_frequency: control.testFrequency,
          next_test_date: control.nextTestDate,
          last_test_date: control.lastTestDate,
          test_procedure: control.testProcedure || null,
          assigned_tester_id: control.assignedTesterId,
          comment: control.comment || null,
        })
        .select()
        .single()

      if (error) throw error
      return toControl(data)
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['controls'] })
    },
  })
}

export function useUpdateControl() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async ({ id, ...updates }: { id: string } & Partial<Control>) => {
      const dbUpdates: Record<string, unknown> = {
        updated_at: new Date().toISOString(),
      }

      // Map Control fields to database columns
      if (updates.name !== undefined) dbUpdates.name = updates.name
      if (updates.description !== undefined) dbUpdates.description = updates.description || null
      if (updates.controlType !== undefined) dbUpdates.control_type = updates.controlType
      if (updates.netProbability !== undefined) dbUpdates.net_probability = updates.netProbability
      if (updates.netImpact !== undefined) dbUpdates.net_impact = updates.netImpact
      if (updates.testFrequency !== undefined) dbUpdates.test_frequency = updates.testFrequency
      if (updates.nextTestDate !== undefined) dbUpdates.next_test_date = updates.nextTestDate
      if (updates.lastTestDate !== undefined) dbUpdates.last_test_date = updates.lastTestDate
      if (updates.testProcedure !== undefined) dbUpdates.test_procedure = updates.testProcedure || null
      if (updates.assignedTesterId !== undefined) dbUpdates.assigned_tester_id = updates.assignedTesterId
      if (updates.comment !== undefined) dbUpdates.comment = updates.comment || null

      const { data, error } = await supabase
        .from('controls')
        .update(dbUpdates)
        .eq('id', id)
        .select()
        .single()

      if (error) throw error
      return toControl(data)
    },
    // Optimistic update
    onMutate: async ({ id, ...updates }) => {
      await queryClient.cancelQueries({ queryKey: ['controls'] })
      const previousControls = queryClient.getQueryData<Control[]>(['controls'])

      queryClient.setQueryData<Control[]>(['controls'], (old) =>
        old?.map((c) => (c.id === id ? { ...c, ...updates } : c))
      )

      return { previousControls }
    },
    onError: (err, variables, context) => {
      if (context?.previousControls) {
        queryClient.setQueryData(['controls'], context.previousControls)
      }
      toast.error('Failed to update control')
    },
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: ['controls'] })
    },
  })
}

export function useDeleteControl() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (id: string) => {
      const { error } = await supabase
        .from('controls')
        .delete()
        .eq('id', id)

      if (error) throw error
    },
    // Optimistic delete
    onMutate: async (id) => {
      await queryClient.cancelQueries({ queryKey: ['controls'] })
      const previousControls = queryClient.getQueryData<Control[]>(['controls'])

      queryClient.setQueryData<Control[]>(['controls'], (old) =>
        old?.filter((c) => c.id !== id)
      )

      return { previousControls }
    },
    onError: (err, variables, context) => {
      if (context?.previousControls) {
        queryClient.setQueryData(['controls'], context.previousControls)
      }
      toast.error('Failed to delete control')
    },
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: ['controls'] })
      queryClient.invalidateQueries({ queryKey: ['controlLinks'] })
    },
  })
}
```

Key decisions:
- toControl transformer handles DB column naming (snake_case) to TypeScript (camelCase)
- Optimistic updates for update and delete for instant feedback
- Rollback on error with toast notification
- Cascade invalidate control links when deleting control
  </action>
  <verify>Run `npm run typecheck` to verify Control type mapping is correct.</verify>
  <done>useControls hook created with query and CRUD mutations, optimistic updates</done>
</task>

<task type="auto">
  <name>Task 2: Create useControlLinks and useRCTRows hooks</name>
  <files>
    src/hooks/useControlLinks.ts
    src/hooks/useRCTRows.ts
  </files>
  <action>
Create src/hooks/useControlLinks.ts for managing control-to-RCT-row links:

```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import { supabase } from '@/lib/supabase/client'
import type { ControlLink } from '@/types/rct'
import type { Database } from '@/types/database.types'

type LinkRow = Database['public']['Tables']['control_links']['Row']

function toControlLink(row: LinkRow): ControlLink {
  return {
    id: row.id,
    controlId: row.control_id,
    rowId: row.rct_row_id,
    netProbability: row.net_probability ?? undefined,
    netImpact: row.net_impact ?? undefined,
    netScore: row.net_score ?? undefined,
    createdAt: row.created_at,
  }
}

export function useControlLinks() {
  return useQuery({
    queryKey: ['controlLinks'],
    queryFn: async () => {
      const { data, error } = await supabase
        .from('control_links')
        .select('*')

      if (error) throw error
      return data.map(toControlLink)
    },
  })
}

export function useLinksForRow(rowId: string) {
  return useQuery({
    queryKey: ['controlLinks', 'row', rowId],
    queryFn: async () => {
      const { data, error } = await supabase
        .from('control_links')
        .select('*')
        .eq('rct_row_id', rowId)

      if (error) throw error
      return data.map(toControlLink)
    },
  })
}

export function useLinkControl() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async ({ controlId, rowId }: { controlId: string; rowId: string }) => {
      const { data, error } = await supabase
        .from('control_links')
        .insert({ control_id: controlId, rct_row_id: rowId })
        .select()
        .single()

      if (error) throw error
      return toControlLink(data)
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['controlLinks'] })
    },
  })
}

export function useUnlinkControl() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (linkId: string) => {
      const { error } = await supabase
        .from('control_links')
        .delete()
        .eq('id', linkId)

      if (error) throw error
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['controlLinks'] })
    },
  })
}

export function useUpdateLink() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async ({ id, netProbability, netImpact }: {
      id: string
      netProbability?: number | null
      netImpact?: number | null
    }) => {
      const { data, error } = await supabase
        .from('control_links')
        .update({
          net_probability: netProbability,
          net_impact: netImpact,
        })
        .eq('id', id)
        .select()
        .single()

      if (error) throw error
      return toControlLink(data)
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['controlLinks'] })
    },
  })
}
```

Create src/hooks/useRCTRows.ts for RCT row operations:

```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import { supabase } from '@/lib/supabase/client'
import type { RCTRow } from '@/types/rct'
import type { Database } from '@/types/database.types'
import { toast } from 'sonner'

type RCTRowDB = Database['public']['Tables']['rct_rows']['Row']

// Note: Full RCTRow has denormalized taxonomy data. For now, we'll return partial
// and join with taxonomy in the component layer, OR we'll need a view/function.
// Starting simple - return what the DB stores directly.

export interface RCTRowData {
  id: string
  rowId: string
  riskId: string
  processId: string
  grossProbability: number | null
  grossImpact: number | null
  grossScore: number | null
  grossProbabilityComment: string | null
  grossImpactComment: string | null
  riskAppetite: number
  withinAppetite: number | null
  customValues: Record<string, unknown>
  createdAt: string
  updatedAt: string
}

function toRCTRow(row: RCTRowDB): RCTRowData {
  return {
    id: row.id,
    rowId: row.row_id,
    riskId: row.risk_id,
    processId: row.process_id,
    grossProbability: row.gross_probability,
    grossImpact: row.gross_impact,
    grossScore: row.gross_score,
    grossProbabilityComment: row.gross_probability_comment,
    grossImpactComment: row.gross_impact_comment,
    riskAppetite: row.risk_appetite ?? 9,
    withinAppetite: row.within_appetite,
    customValues: (row.custom_values as Record<string, unknown>) || {},
    createdAt: row.created_at,
    updatedAt: row.updated_at,
  }
}

export function useRCTRows() {
  return useQuery({
    queryKey: ['rctRows'],
    queryFn: async () => {
      const { data, error } = await supabase
        .from('rct_rows')
        .select('*')
        .order('row_id')

      if (error) throw error
      return data.map(toRCTRow)
    },
  })
}

export function useUpdateRCTRow() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async ({ id, ...updates }: {
      id: string
      grossProbability?: number | null
      grossImpact?: number | null
      grossProbabilityComment?: string | null
      grossImpactComment?: string | null
      riskAppetite?: number
      customValues?: Record<string, unknown>
    }) => {
      const dbUpdates: Record<string, unknown> = {
        updated_at: new Date().toISOString(),
      }

      if (updates.grossProbability !== undefined) dbUpdates.gross_probability = updates.grossProbability
      if (updates.grossImpact !== undefined) dbUpdates.gross_impact = updates.grossImpact
      if (updates.grossProbabilityComment !== undefined) dbUpdates.gross_probability_comment = updates.grossProbabilityComment
      if (updates.grossImpactComment !== undefined) dbUpdates.gross_impact_comment = updates.grossImpactComment
      if (updates.riskAppetite !== undefined) dbUpdates.risk_appetite = updates.riskAppetite
      if (updates.customValues !== undefined) dbUpdates.custom_values = updates.customValues

      const { data, error } = await supabase
        .from('rct_rows')
        .update(dbUpdates)
        .eq('id', id)
        .select()
        .single()

      if (error) throw error
      return toRCTRow(data)
    },
    onMutate: async ({ id, ...updates }) => {
      await queryClient.cancelQueries({ queryKey: ['rctRows'] })
      const previousRows = queryClient.getQueryData<RCTRowData[]>(['rctRows'])

      queryClient.setQueryData<RCTRowData[]>(['rctRows'], (old) =>
        old?.map((r) => (r.id === id ? { ...r, ...updates } : r))
      )

      return { previousRows }
    },
    onError: (err, variables, context) => {
      if (context?.previousRows) {
        queryClient.setQueryData(['rctRows'], context.previousRows)
      }
      toast.error('Failed to update row')
    },
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: ['rctRows'] })
    },
  })
}

export function useCreateRCTRow() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (row: {
      rowId: string
      riskId: string
      processId: string
      grossProbability?: number | null
      grossImpact?: number | null
      riskAppetite?: number
    }) => {
      const { data, error } = await supabase
        .from('rct_rows')
        .insert({
          row_id: row.rowId,
          risk_id: row.riskId,
          process_id: row.processId,
          gross_probability: row.grossProbability ?? null,
          gross_impact: row.grossImpact ?? null,
          risk_appetite: row.riskAppetite ?? 9,
        })
        .select()
        .single()

      if (error) throw error
      return toRCTRow(data)
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['rctRows'] })
    },
  })
}

export function useDeleteRCTRow() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (id: string) => {
      const { error } = await supabase
        .from('rct_rows')
        .delete()
        .eq('id', id)

      if (error) throw error
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['rctRows'] })
      queryClient.invalidateQueries({ queryKey: ['controlLinks'] })
    },
  })
}
```

Note: RCTRow has denormalized taxonomy columns (riskL1Name, etc.) that we don't store in DB. We'll need to join/compute these in the component layer or create a database view. For now, return the core data and handle denormalization in Phase 26-07 (frontend integration).
  </action>
  <verify>Run `npm run typecheck` to verify types. Check that ControlLink and RCTRowData transformers handle all fields.</verify>
  <done>useControlLinks and useRCTRows hooks created with full CRUD operations</done>
</task>

<task type="auto">
  <name>Task 3: Create useCustomColumns hook</name>
  <files>src/hooks/useCustomColumns.ts</files>
  <action>
Create src/hooks/useCustomColumns.ts for managing RCT custom columns:

```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import { supabase } from '@/lib/supabase/client'
import type { CustomColumn } from '@/types/rct'
import type { Database } from '@/types/database.types'

type CustomColumnRow = Database['public']['Tables']['custom_columns']['Row']

function toCustomColumn(row: CustomColumnRow): CustomColumn {
  return {
    id: row.id,
    name: row.name,
    type: row.type as CustomColumn['type'],
    options: row.options ?? undefined,
    formula: row.formula ?? undefined,
    width: row.width ?? undefined,
  }
}

export function useCustomColumns() {
  return useQuery({
    queryKey: ['customColumns'],
    queryFn: async () => {
      const { data, error } = await supabase
        .from('custom_columns')
        .select('*')
        .order('sort_order')

      if (error) throw error
      return data.map(toCustomColumn)
    },
  })
}

export function useAddCustomColumn() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (column: Omit<CustomColumn, 'id'> & { sortOrder?: number }) => {
      const { data, error } = await supabase
        .from('custom_columns')
        .insert({
          name: column.name,
          type: column.type,
          options: column.options || null,
          formula: column.formula || null,
          width: column.width || null,
          sort_order: column.sortOrder ?? 0,
        })
        .select()
        .single()

      if (error) throw error
      return toCustomColumn(data)
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['customColumns'] })
    },
  })
}

export function useUpdateCustomColumn() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async ({ id, ...updates }: { id: string } & Partial<CustomColumn> & { sortOrder?: number }) => {
      const dbUpdates: Record<string, unknown> = {}

      if (updates.name !== undefined) dbUpdates.name = updates.name
      if (updates.type !== undefined) dbUpdates.type = updates.type
      if (updates.options !== undefined) dbUpdates.options = updates.options
      if (updates.formula !== undefined) dbUpdates.formula = updates.formula
      if (updates.width !== undefined) dbUpdates.width = updates.width
      if (updates.sortOrder !== undefined) dbUpdates.sort_order = updates.sortOrder

      const { data, error } = await supabase
        .from('custom_columns')
        .update(dbUpdates)
        .eq('id', id)
        .select()
        .single()

      if (error) throw error
      return toCustomColumn(data)
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['customColumns'] })
    },
  })
}

export function useDeleteCustomColumn() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (id: string) => {
      const { error } = await supabase
        .from('custom_columns')
        .delete()
        .eq('id', id)

      if (error) throw error
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['customColumns'] })
      // Custom column values are stored in rct_rows.custom_values JSONB
      // We should invalidate rct rows to refetch (column definition changed)
      queryClient.invalidateQueries({ queryKey: ['rctRows'] })
    },
  })
}

export function useReorderCustomColumns() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (orderedIds: string[]) => {
      // Update sort_order for each column
      const updates = orderedIds.map((id, index) =>
        supabase
          .from('custom_columns')
          .update({ sort_order: index })
          .eq('id', id)
      )

      await Promise.all(updates)
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['customColumns'] })
    },
  })
}
```

This hook manages the custom column definitions. The actual values for custom columns are stored in rct_rows.custom_values JSONB field and accessed through useRCTRows/useUpdateRCTRow.
  </action>
  <verify>Run `npm run typecheck` to verify types match CustomColumn from src/types/rct.ts.</verify>
  <done>useCustomColumns hook created with CRUD and reorder operations</done>
</task>

</tasks>

<verification>
- [ ] useControls hook fetches all controls with proper type transformation
- [ ] useControlLinks hook manages many-to-many control-row relationships
- [ ] useRCTRows hook fetches rows with computed GENERATED columns
- [ ] useCustomColumns hook manages column definitions
- [ ] Optimistic updates work for control and RCT row mutations
- [ ] Related queries are invalidated on mutations (cascade invalidation)
</verification>

<success_criteria>
- All 4 hook files created with proper type transformations
- Database column names (snake_case) correctly mapped to TypeScript (camelCase)
- Optimistic updates provide instant UI feedback
- Query key structure supports targeted invalidation
</success_criteria>

<output>
After completion, create `.planning/phases/26-shared-tenant-database/26-04-SUMMARY.md`
</output>
