---
phase: 26-shared-tenant-database
plan: 05
type: execute
wave: 2
depends_on: ["26-01", "26-02"]
files_modified:
  - src/hooks/useControlTests.ts
  - src/hooks/useRemediationPlans.ts
  - src/hooks/useTickets.ts
  - src/hooks/useComments.ts
  - src/hooks/usePendingChanges.ts
  - src/hooks/useScoreLabels.ts
autonomous: true

must_haves:
  truths:
    - "useControlTests hook fetches and records test executions"
    - "useRemediationPlans hook manages remediation plans with action items"
    - "useTickets hook fetches tickets with entity links"
    - "usePendingChanges hook manages four-eye approval workflow"
  artifacts:
    - path: "src/hooks/useControlTests.ts"
      provides: "Control test record operations"
      exports: ["useControlTests", "useRecordTest", "useTestHistory"]
    - path: "src/hooks/useRemediationPlans.ts"
      provides: "Remediation plan CRUD operations"
      exports: ["useRemediationPlans", "useCreateRemediationPlan", "useUpdateRemediationStatus"]
    - path: "src/hooks/useTickets.ts"
      provides: "Ticket CRUD and entity linking"
      exports: ["useTickets", "useCreateTicket", "useLinkTicketToEntity"]
    - path: "src/hooks/usePendingChanges.ts"
      provides: "Four-eye approval workflow"
      exports: ["usePendingChanges", "useCreatePendingChange", "useApproveChange", "useRejectChange"]
  key_links:
    - from: "src/hooks/useControlTests.ts"
      to: "supabase"
      via: "useQuery with supabase client"
      pattern: "supabase\\.from\\('control_tests'\\)"
---

<objective>
Create data fetching hooks for control tests, remediation plans, tickets, comments, pending changes, and score labels.

Purpose: These hooks complete the data layer by supporting testing workflows, remediation tracking, task management, collaboration, and the four-eye approval process.

Output: 6 hook files providing full CRUD for secondary domain entities.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-shared-tenant-database/26-RESEARCH.md

# Existing patterns
@src/stores/rctStore.ts
@src/stores/ticketsStore.ts
@src/stores/collaborationStore.ts
@src/stores/approvalStore.ts
@src/types/rct.ts
@src/types/tickets.ts
@src/types/collaboration.ts
@src/types/approval.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useControlTests and useRemediationPlans hooks</name>
  <files>
    src/hooks/useControlTests.ts
    src/hooks/useRemediationPlans.ts
  </files>
  <action>
Create src/hooks/useControlTests.ts:

```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import { supabase } from '@/lib/supabase/client'
import type { ControlTest } from '@/types/rct'
import type { Database } from '@/types/database.types'

type TestRow = Database['public']['Tables']['control_tests']['Row']

function toControlTest(row: TestRow): ControlTest {
  return {
    id: row.id,
    controlId: row.control_id,
    rowId: row.rct_row_id || '',
    testDate: row.test_date,
    result: row.result as ControlTest['result'],
    effectiveness: row.effectiveness,
    testerName: row.tester_name ?? undefined,
    evidence: row.evidence ?? undefined,
    findings: row.findings ?? undefined,
    recommendations: row.recommendations ?? undefined,
  }
}

export function useControlTests() {
  return useQuery({
    queryKey: ['controlTests'],
    queryFn: async () => {
      const { data, error } = await supabase
        .from('control_tests')
        .select('*')
        .order('test_date', { ascending: false })

      if (error) throw error
      return data.map(toControlTest)
    },
  })
}

export function useTestHistory(controlId: string) {
  return useQuery({
    queryKey: ['controlTests', 'history', controlId],
    queryFn: async () => {
      const { data, error } = await supabase
        .from('control_tests')
        .select('*')
        .eq('control_id', controlId)
        .order('test_date', { ascending: false })

      if (error) throw error
      return data.map(toControlTest)
    },
  })
}

export function useRecordTest() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (test: Omit<ControlTest, 'id'>) => {
      const { data, error } = await supabase
        .from('control_tests')
        .insert({
          control_id: test.controlId,
          rct_row_id: test.rowId || null,
          test_date: test.testDate,
          result: test.result,
          effectiveness: test.effectiveness,
          tester_name: test.testerName || null,
          evidence: test.evidence || null,
          findings: test.findings || null,
          recommendations: test.recommendations || null,
        })
        .select()
        .single()

      if (error) throw error
      return toControlTest(data)
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: ['controlTests'] })
      queryClient.invalidateQueries({ queryKey: ['controlTests', 'history', data.controlId] })
      // Also invalidate controls to update lastTestDate
      queryClient.invalidateQueries({ queryKey: ['controls'] })
    },
  })
}
```

Create src/hooks/useRemediationPlans.ts:

```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import { supabase } from '@/lib/supabase/client'
import type { RemediationPlan, RemediationStatus, ActionItem } from '@/types/rct'
import type { Database } from '@/types/database.types'
import { format } from 'date-fns'

type PlanRow = Database['public']['Tables']['remediation_plans']['Row']

function toRemediationPlan(row: PlanRow): RemediationPlan {
  return {
    id: row.id,
    controlTestId: row.control_test_id,
    controlId: row.control_id,
    rowId: row.rct_row_id || '',
    title: row.title,
    description: row.description ?? undefined,
    owner: row.owner,
    deadline: row.deadline,
    status: row.status as RemediationStatus,
    priority: row.priority as RemediationPlan['priority'],
    actionItems: (row.action_items as ActionItem[]) || [],
    createdDate: row.created_date,
    resolvedDate: row.resolved_date ?? undefined,
    closedDate: row.closed_date ?? undefined,
    notes: row.notes ?? undefined,
  }
}

export function useRemediationPlans() {
  return useQuery({
    queryKey: ['remediationPlans'],
    queryFn: async () => {
      const { data, error } = await supabase
        .from('remediation_plans')
        .select('*')
        .order('deadline')

      if (error) throw error
      return data.map(toRemediationPlan)
    },
  })
}

export function useRemediationForControl(controlId: string) {
  return useQuery({
    queryKey: ['remediationPlans', 'control', controlId],
    queryFn: async () => {
      const { data, error } = await supabase
        .from('remediation_plans')
        .select('*')
        .eq('control_id', controlId)
        .order('deadline')

      if (error) throw error
      return data.map(toRemediationPlan)
    },
  })
}

export function useCreateRemediationPlan() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (plan: Omit<RemediationPlan, 'id' | 'createdDate'>) => {
      const { data, error } = await supabase
        .from('remediation_plans')
        .insert({
          control_test_id: plan.controlTestId,
          control_id: plan.controlId,
          rct_row_id: plan.rowId || null,
          title: plan.title,
          description: plan.description || null,
          owner: plan.owner,
          deadline: plan.deadline,
          status: plan.status,
          priority: plan.priority,
          action_items: plan.actionItems,
          notes: plan.notes || null,
          created_date: format(new Date(), 'yyyy-MM-dd'),
        })
        .select()
        .single()

      if (error) throw error
      return toRemediationPlan(data)
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['remediationPlans'] })
    },
  })
}

export function useUpdateRemediationPlan() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async ({ id, ...updates }: { id: string } & Partial<RemediationPlan>) => {
      const dbUpdates: Record<string, unknown> = {
        updated_at: new Date().toISOString(),
      }

      if (updates.title !== undefined) dbUpdates.title = updates.title
      if (updates.description !== undefined) dbUpdates.description = updates.description
      if (updates.owner !== undefined) dbUpdates.owner = updates.owner
      if (updates.deadline !== undefined) dbUpdates.deadline = updates.deadline
      if (updates.priority !== undefined) dbUpdates.priority = updates.priority
      if (updates.actionItems !== undefined) dbUpdates.action_items = updates.actionItems
      if (updates.notes !== undefined) dbUpdates.notes = updates.notes

      const { data, error } = await supabase
        .from('remediation_plans')
        .update(dbUpdates)
        .eq('id', id)
        .select()
        .single()

      if (error) throw error
      return toRemediationPlan(data)
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['remediationPlans'] })
    },
  })
}

export function useUpdateRemediationStatus() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async ({ id, status }: { id: string; status: RemediationStatus }) => {
      const updates: Record<string, unknown> = {
        status,
        updated_at: new Date().toISOString(),
      }

      const today = format(new Date(), 'yyyy-MM-dd')
      if (status === 'resolved') updates.resolved_date = today
      if (status === 'closed') updates.closed_date = today

      const { data, error } = await supabase
        .from('remediation_plans')
        .update(updates)
        .eq('id', id)
        .select()
        .single()

      if (error) throw error
      return toRemediationPlan(data)
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['remediationPlans'] })
    },
  })
}

export function useDeleteRemediationPlan() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (id: string) => {
      const { error } = await supabase
        .from('remediation_plans')
        .delete()
        .eq('id', id)

      if (error) throw error
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['remediationPlans'] })
    },
  })
}
```
  </action>
  <verify>Run `npm run typecheck` to verify type transformations match ControlTest and RemediationPlan types.</verify>
  <done>useControlTests and useRemediationPlans hooks created with full CRUD</done>
</task>

<task type="auto">
  <name>Task 2: Create useTickets and useComments hooks</name>
  <files>
    src/hooks/useTickets.ts
    src/hooks/useComments.ts
  </files>
  <action>
Create src/hooks/useTickets.ts:

```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import { supabase } from '@/lib/supabase/client'
import type { Ticket, TicketStatus, TicketEntityLink, TicketLinkEntityType } from '@/types/tickets'
import type { Database } from '@/types/database.types'

type TicketRow = Database['public']['Tables']['tickets']['Row']
type LinkRow = Database['public']['Tables']['ticket_entity_links']['Row']

function toTicket(row: TicketRow): Ticket {
  return {
    id: row.id,
    title: row.title,
    description: row.description ?? undefined,
    category: row.category,
    status: row.status as TicketStatus,
    priority: row.priority as Ticket['priority'],
    owner: row.owner,
    deadline: row.deadline,
    notes: row.notes ?? undefined,
    recurrence: row.recurrence as Ticket['recurrence'] | undefined,
    doneDate: row.done_date ?? undefined,
    archived: row.archived ?? false,
    createdDate: row.created_at,
  }
}

function toEntityLink(row: LinkRow): TicketEntityLink {
  return {
    id: row.id,
    ticketId: row.ticket_id,
    entityType: row.entity_type as TicketLinkEntityType,
    entityId: row.entity_id,
    entityName: row.entity_name || '',
    createdAt: row.created_at,
  }
}

export function useTickets() {
  return useQuery({
    queryKey: ['tickets'],
    queryFn: async () => {
      const { data, error } = await supabase
        .from('tickets')
        .select('*')
        .eq('archived', false)
        .order('deadline')

      if (error) throw error
      return data.map(toTicket)
    },
  })
}

export function useTicketEntityLinks() {
  return useQuery({
    queryKey: ['ticketEntityLinks'],
    queryFn: async () => {
      const { data, error } = await supabase
        .from('ticket_entity_links')
        .select('*')

      if (error) throw error
      return data.map(toEntityLink)
    },
  })
}

export function useCreateTicket() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (ticket: Omit<Ticket, 'id' | 'createdDate' | 'archived'>) => {
      const { data, error } = await supabase
        .from('tickets')
        .insert({
          title: ticket.title,
          description: ticket.description || null,
          category: ticket.category,
          status: ticket.status,
          priority: ticket.priority,
          owner: ticket.owner,
          deadline: ticket.deadline,
          notes: ticket.notes || null,
          recurrence: ticket.recurrence || null,
        })
        .select()
        .single()

      if (error) throw error
      return toTicket(data)
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['tickets'] })
    },
  })
}

export function useUpdateTicket() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async ({ id, ...updates }: { id: string } & Partial<Ticket>) => {
      const dbUpdates: Record<string, unknown> = {}

      if (updates.title !== undefined) dbUpdates.title = updates.title
      if (updates.description !== undefined) dbUpdates.description = updates.description
      if (updates.category !== undefined) dbUpdates.category = updates.category
      if (updates.status !== undefined) dbUpdates.status = updates.status
      if (updates.priority !== undefined) dbUpdates.priority = updates.priority
      if (updates.owner !== undefined) dbUpdates.owner = updates.owner
      if (updates.deadline !== undefined) dbUpdates.deadline = updates.deadline
      if (updates.notes !== undefined) dbUpdates.notes = updates.notes
      if (updates.recurrence !== undefined) dbUpdates.recurrence = updates.recurrence
      if (updates.doneDate !== undefined) dbUpdates.done_date = updates.doneDate
      if (updates.archived !== undefined) dbUpdates.archived = updates.archived

      const { data, error } = await supabase
        .from('tickets')
        .update(dbUpdates)
        .eq('id', id)
        .select()
        .single()

      if (error) throw error
      return toTicket(data)
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['tickets'] })
    },
  })
}

export function useDeleteTicket() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (id: string) => {
      const { error } = await supabase
        .from('tickets')
        .delete()
        .eq('id', id)

      if (error) throw error
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['tickets'] })
      queryClient.invalidateQueries({ queryKey: ['ticketEntityLinks'] })
    },
  })
}

export function useLinkTicketToEntity() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async ({ ticketId, entityType, entityId, entityName }: {
      ticketId: string
      entityType: TicketLinkEntityType
      entityId: string
      entityName: string
    }) => {
      const { data, error } = await supabase
        .from('ticket_entity_links')
        .insert({
          ticket_id: ticketId,
          entity_type: entityType,
          entity_id: entityId,
          entity_name: entityName,
        })
        .select()
        .single()

      if (error) throw error
      return toEntityLink(data)
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['ticketEntityLinks'] })
    },
  })
}

export function useUnlinkTicketFromEntity() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async ({ ticketId, entityType, entityId }: {
      ticketId: string
      entityType: TicketLinkEntityType
      entityId: string
    }) => {
      const { error } = await supabase
        .from('ticket_entity_links')
        .delete()
        .eq('ticket_id', ticketId)
        .eq('entity_type', entityType)
        .eq('entity_id', entityId)

      if (error) throw error
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['ticketEntityLinks'] })
    },
  })
}
```

Create src/hooks/useComments.ts:

```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import { supabase } from '@/lib/supabase/client'
import type { Comment, CommentableEntityType } from '@/types/collaboration'
import type { Database } from '@/types/database.types'

type CommentRow = Database['public']['Tables']['comments']['Row']

function toComment(row: CommentRow): Comment {
  return {
    id: row.id,
    entityType: row.entity_type as CommentableEntityType,
    entityId: row.entity_id,
    parentId: row.parent_id ?? undefined,
    content: row.content,
    authorId: row.author_id ?? undefined,
    authorRole: row.author_role,
    isEdited: row.is_edited ?? false,
    createdAt: row.created_at,
    updatedAt: row.updated_at ?? undefined,
  }
}

export function useComments(entityType: CommentableEntityType, entityId: string) {
  return useQuery({
    queryKey: ['comments', entityType, entityId],
    queryFn: async () => {
      const { data, error } = await supabase
        .from('comments')
        .select('*')
        .eq('entity_type', entityType)
        .eq('entity_id', entityId)
        .order('created_at')

      if (error) throw error
      return data.map(toComment)
    },
  })
}

export function useAddComment() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (comment: Omit<Comment, 'id' | 'createdAt' | 'isEdited'>) => {
      const { data, error } = await supabase
        .from('comments')
        .insert({
          entity_type: comment.entityType,
          entity_id: comment.entityId,
          parent_id: comment.parentId || null,
          content: comment.content,
          author_id: comment.authorId || null,
          author_role: comment.authorRole,
        })
        .select()
        .single()

      if (error) throw error
      return toComment(data)
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: ['comments', data.entityType, data.entityId] })
    },
  })
}

export function useUpdateComment() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async ({ id, content, entityType, entityId }: {
      id: string
      content: string
      entityType: CommentableEntityType
      entityId: string
    }) => {
      const { data, error } = await supabase
        .from('comments')
        .update({
          content,
          is_edited: true,
          updated_at: new Date().toISOString(),
        })
        .eq('id', id)
        .select()
        .single()

      if (error) throw error
      return { comment: toComment(data), entityType, entityId }
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: ['comments', data.entityType, data.entityId] })
    },
  })
}

export function useDeleteComment() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async ({ id, entityType, entityId }: {
      id: string
      entityType: CommentableEntityType
      entityId: string
    }) => {
      // CASCADE delete handles replies
      const { error } = await supabase
        .from('comments')
        .delete()
        .eq('id', id)

      if (error) throw error
      return { entityType, entityId }
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: ['comments', data.entityType, data.entityId] })
    },
  })
}
```
  </action>
  <verify>Run `npm run typecheck` to verify Ticket and Comment type transformations.</verify>
  <done>useTickets and useComments hooks created with full CRUD and entity linking</done>
</task>

<task type="auto">
  <name>Task 3: Create usePendingChanges and useScoreLabels hooks</name>
  <files>
    src/hooks/usePendingChanges.ts
    src/hooks/useScoreLabels.ts
  </files>
  <action>
Create src/hooks/usePendingChanges.ts:

```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import { supabase } from '@/lib/supabase/client'
import type { PendingChange, PendingChangeEntityType } from '@/types/approval'
import type { Database } from '@/types/database.types'

type PendingRow = Database['public']['Tables']['pending_changes']['Row']

function toPendingChange(row: PendingRow): PendingChange {
  return {
    id: row.id,
    entityType: row.entity_type as PendingChangeEntityType,
    entityId: row.entity_id,
    entityName: row.entity_name,
    changeType: row.change_type as PendingChange['changeType'],
    currentValues: (row.current_values as Record<string, unknown>) || {},
    proposedValues: row.proposed_values as Record<string, unknown>,
    status: row.status as PendingChange['status'],
    submittedBy: row.submitted_by,
    submittedAt: row.submitted_at,
    reviewedBy: row.reviewed_by ?? undefined,
    reviewedAt: row.reviewed_at ?? undefined,
    rejectionReason: row.rejection_reason ?? undefined,
    version: row.version ?? 1,
  }
}

export function usePendingChanges() {
  return useQuery({
    queryKey: ['pendingChanges'],
    queryFn: async () => {
      const { data, error } = await supabase
        .from('pending_changes')
        .select('*')
        .order('submitted_at', { ascending: false })

      if (error) throw error
      return data.map(toPendingChange)
    },
  })
}

export function usePendingCount() {
  return useQuery({
    queryKey: ['pendingChanges', 'count'],
    queryFn: async () => {
      const { count, error } = await supabase
        .from('pending_changes')
        .select('*', { count: 'exact', head: true })
        .eq('status', 'pending')

      if (error) throw error
      return count || 0
    },
  })
}

export function useCreatePendingChange() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (change: Omit<PendingChange, 'id' | 'status' | 'submittedAt' | 'version'>) => {
      const { data, error } = await supabase
        .from('pending_changes')
        .insert({
          entity_type: change.entityType,
          entity_id: change.entityId,
          entity_name: change.entityName,
          change_type: change.changeType,
          current_values: change.currentValues,
          proposed_values: change.proposedValues,
          submitted_by: change.submittedBy,
        })
        .select()
        .single()

      if (error) throw error
      return toPendingChange(data)
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['pendingChanges'] })
    },
  })
}

export function useApproveChange() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async ({ id, reviewedBy }: { id: string; reviewedBy: string }) => {
      const { data, error } = await supabase
        .from('pending_changes')
        .update({
          status: 'approved',
          reviewed_by: reviewedBy,
          reviewed_at: new Date().toISOString(),
        })
        .eq('id', id)
        .select()
        .single()

      if (error) throw error
      return toPendingChange(data)
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['pendingChanges'] })
    },
  })
}

export function useRejectChange() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async ({ id, reviewedBy, reason }: { id: string; reviewedBy: string; reason?: string }) => {
      const { data, error } = await supabase
        .from('pending_changes')
        .update({
          status: 'rejected',
          reviewed_by: reviewedBy,
          reviewed_at: new Date().toISOString(),
          rejection_reason: reason || null,
        })
        .eq('id', id)
        .select()
        .single()

      if (error) throw error
      return toPendingChange(data)
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['pendingChanges'] })
    },
  })
}
```

Create src/hooks/useScoreLabels.ts:

```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import { supabase } from '@/lib/supabase/client'
import type { ScoreLabel } from '@/stores/rctStore'
import type { Database } from '@/types/database.types'

type LabelRow = Database['public']['Tables']['score_labels']['Row']

function toScoreLabel(row: LabelRow): ScoreLabel {
  return {
    score: row.score,
    label: row.label,
    description: row.description || '',
  }
}

export function useScoreLabels(type: 'probability' | 'impact') {
  return useQuery({
    queryKey: ['scoreLabels', type],
    queryFn: async () => {
      const { data, error } = await supabase
        .from('score_labels')
        .select('*')
        .eq('type', type)
        .order('score')

      if (error) throw error
      return data.map(toScoreLabel)
    },
  })
}

export function useUpdateScoreLabel() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async ({ type, score, label, description }: {
      type: 'probability' | 'impact'
      score: number
      label: string
      description?: string
    }) => {
      const { data, error } = await supabase
        .from('score_labels')
        .upsert({
          type,
          score,
          label,
          description: description || null,
        }, {
          onConflict: 'tenant_id,type,score',
        })
        .select()
        .single()

      if (error) throw error
      return toScoreLabel(data)
    },
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({ queryKey: ['scoreLabels', variables.type] })
    },
  })
}
```

Note: ApprovalSettings is a single row per tenant. Create a separate useApprovalSettings hook if needed, but it's simpler to store in component state and sync on change since it's configuration, not transactional data.
  </action>
  <verify>Run `npm run typecheck` to verify PendingChange and ScoreLabel type transformations.</verify>
  <done>usePendingChanges and useScoreLabels hooks created with full operations</done>
</task>

</tasks>

<verification>
- [ ] useControlTests hook fetches and records tests
- [ ] useRemediationPlans hook manages plans with action items (JSONB)
- [ ] useTickets hook handles tickets and entity links
- [ ] useComments hook manages threaded comments
- [ ] usePendingChanges hook implements approve/reject workflow
- [ ] useScoreLabels hook manages custom probability/impact labels
</verification>

<success_criteria>
- All 6 hook files created with proper type transformations
- JSONB fields (action_items, recurrence, etc.) correctly typed
- Query key structure supports targeted cache invalidation
- Status transitions (remediation, pending changes) correctly update timestamps
</success_criteria>

<output>
After completion, create `.planning/phases/26-shared-tenant-database/26-05-SUMMARY.md`
</output>
