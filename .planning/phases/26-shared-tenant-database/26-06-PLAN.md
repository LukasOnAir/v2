---
phase: 26-shared-tenant-database
plan: 06
type: execute
wave: 3
depends_on: ["26-03", "26-04", "26-05"]
files_modified:
  - src/hooks/useRealtimeSync.ts
  - src/providers/RealtimeProvider.tsx
  - src/main.tsx
autonomous: true

must_haves:
  truths:
    - "Changes made by one user are visible to other tenant users via realtime subscriptions"
    - "Realtime subscription handles React Strict Mode double-mount"
    - "Query cache is invalidated when realtime change events are received"
  artifacts:
    - path: "src/hooks/useRealtimeSync.ts"
      provides: "Realtime subscription hook for database changes"
      exports: ["useRealtimeSync"]
    - path: "src/providers/RealtimeProvider.tsx"
      provides: "Context provider that initializes realtime subscriptions"
      exports: ["RealtimeProvider"]
  key_links:
    - from: "src/hooks/useRealtimeSync.ts"
      to: "supabase"
      via: "Supabase Realtime channel subscription"
      pattern: "supabase\\.channel"
    - from: "src/main.tsx"
      to: "src/providers/RealtimeProvider.tsx"
      via: "Provider wrapping app"
      pattern: "<RealtimeProvider>"
---

<objective>
Set up Supabase Realtime subscriptions to sync data changes across users within the same tenant.

Purpose: When User A makes a change, User B should see it without refreshing. This is essential for multi-user collaboration within a tenant. Realtime subscriptions push database changes to connected clients.

Output: Realtime hook and provider that invalidate React Query cache when changes are detected.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-shared-tenant-database/26-RESEARCH.md

# Existing patterns
@src/lib/supabase/client.ts
@src/contexts/AuthContext.tsx
@src/providers/QueryProvider.tsx
@src/main.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useRealtimeSync hook</name>
  <files>src/hooks/useRealtimeSync.ts</files>
  <action>
Create src/hooks/useRealtimeSync.ts following 26-RESEARCH.md patterns:

```typescript
import { useEffect, useRef } from 'react'
import { useQueryClient } from '@tanstack/react-query'
import { supabase } from '@/lib/supabase/client'
import { useAuth } from '@/contexts/AuthContext'

/**
 * Subscribe to realtime database changes and invalidate React Query cache.
 *
 * This hook sets up Supabase Realtime subscriptions for tables that benefit
 * from cross-user sync. When another user modifies data, the cache is
 * invalidated so React Query refetches fresh data.
 *
 * Tables subscribed:
 * - taxonomy_nodes: Risk and process taxonomy changes
 * - controls: Control definition changes
 * - control_links: Control-to-row link changes
 * - rct_rows: Risk Control Table row changes
 * - pending_changes: Four-eye approval workflow
 *
 * Other tables (tests, remediation, tickets, comments) are less collaborative
 * and can be added later if needed.
 */
export function useRealtimeSync() {
  const queryClient = useQueryClient()
  const { session } = useAuth()
  const isFirstRender = useRef(true)
  const channelRef = useRef<ReturnType<typeof supabase.channel> | null>(null)

  useEffect(() => {
    // Skip if not authenticated
    if (!session) return

    // Prevent duplicate subscription in React Strict Mode
    if (!isFirstRender.current) return
    isFirstRender.current = false

    const userId = session.user.id

    // Create a single channel for all subscriptions
    const channel = supabase
      .channel('tenant-db-changes')
      // Taxonomy changes
      .on(
        'postgres_changes',
        { event: '*', schema: 'public', table: 'taxonomy_nodes' },
        (payload) => {
          // Get the type from either new or old record
          const type = (payload.new as { type?: string })?.type ||
                       (payload.old as { type?: string })?.type
          if (type) {
            queryClient.invalidateQueries({ queryKey: ['taxonomy', type] })
          } else {
            // Fallback: invalidate both
            queryClient.invalidateQueries({ queryKey: ['taxonomy'] })
          }
        }
      )
      // Control changes
      .on(
        'postgres_changes',
        { event: '*', schema: 'public', table: 'controls' },
        () => {
          queryClient.invalidateQueries({ queryKey: ['controls'] })
        }
      )
      // Control link changes
      .on(
        'postgres_changes',
        { event: '*', schema: 'public', table: 'control_links' },
        () => {
          queryClient.invalidateQueries({ queryKey: ['controlLinks'] })
        }
      )
      // RCT row changes
      .on(
        'postgres_changes',
        { event: '*', schema: 'public', table: 'rct_rows' },
        () => {
          queryClient.invalidateQueries({ queryKey: ['rctRows'] })
        }
      )
      // Pending changes (for approval workflow)
      .on(
        'postgres_changes',
        { event: '*', schema: 'public', table: 'pending_changes' },
        () => {
          queryClient.invalidateQueries({ queryKey: ['pendingChanges'] })
        }
      )
      .subscribe((status) => {
        if (status === 'SUBSCRIBED') {
          console.log('[Realtime] Subscribed to tenant database changes')
        } else if (status === 'CHANNEL_ERROR') {
          console.error('[Realtime] Channel error')
        }
      })

    channelRef.current = channel

    return () => {
      if (channelRef.current) {
        console.log('[Realtime] Unsubscribing from tenant database changes')
        channelRef.current.unsubscribe()
        channelRef.current = null
      }
    }
  }, [session, queryClient])
}
```

Key decisions:
- Single channel for all table subscriptions (more efficient than multiple channels)
- Use `isFirstRender` ref to handle React Strict Mode double-mount
- Target specific query keys for granular cache invalidation
- Only subscribe to high-collaboration tables (taxonomy, controls, RCT, pending changes)
- Log subscription status for debugging
  </action>
  <verify>Run `npm run typecheck` to verify types. Check that supabase.channel API matches Supabase v2 SDK.</verify>
  <done>useRealtimeSync hook created with subscriptions to core tables</done>
</task>

<task type="auto">
  <name>Task 2: Create RealtimeProvider and integrate into app</name>
  <files>
    src/providers/RealtimeProvider.tsx
    src/main.tsx
  </files>
  <action>
Create src/providers/RealtimeProvider.tsx:

```typescript
import { type ReactNode } from 'react'
import { useRealtimeSync } from '@/hooks/useRealtimeSync'

/**
 * Provider component that initializes realtime subscriptions.
 *
 * Must be rendered inside:
 * - QueryProvider (needs queryClient for cache invalidation)
 * - AuthProvider (needs session for user context)
 *
 * The actual subscription logic is in useRealtimeSync hook.
 * This provider just ensures it's called once at the app level.
 */
export function RealtimeProvider({ children }: { children: ReactNode }) {
  useRealtimeSync()
  return <>{children}</>
}
```

Update src/main.tsx to add RealtimeProvider:

The provider order should be:
1. ErrorBoundary (outermost - catches all errors)
2. QueryProvider (React Query client)
3. AuthProvider (authentication state)
4. RealtimeProvider (needs both Query and Auth)
5. RouterProvider (routing)

Find the existing provider structure and add RealtimeProvider after AuthProvider:

```typescript
import { RealtimeProvider } from '@/providers/RealtimeProvider'

// In the render tree:
<ErrorBoundary>
  <QueryProvider>
    <AuthProvider>
      <RealtimeProvider>
        <RouterProvider router={router} />
      </RealtimeProvider>
    </AuthProvider>
  </QueryProvider>
</ErrorBoundary>
```

Note: RealtimeProvider must be inside AuthProvider because useRealtimeSync uses useAuth() to get the session.
  </action>
  <verify>Run `npm run dev` and open browser DevTools console. Verify "[Realtime] Subscribed to tenant database changes" appears after login. Open app in two browser tabs, make a change in one tab, verify it appears in the other tab without refresh.</verify>
  <done>RealtimeProvider created and integrated into main.tsx</done>
</task>

<task type="auto">
  <name>Task 3: Enable Supabase Realtime for required tables</name>
  <files>supabase/migrations/00026_enable_realtime.sql</files>
  <action>
Create migration to enable Realtime on required tables.

Supabase requires explicit enabling of Realtime for each table via publication:

```sql
-- Enable Realtime for tenant data tables
-- These tables will broadcast changes to connected clients

-- Add tables to the supabase_realtime publication
-- (supabase_realtime is the default publication for Realtime)

-- Check if publication exists first (Supabase creates it automatically)
DO $$
BEGIN
  -- taxonomy_nodes
  IF NOT EXISTS (
    SELECT 1 FROM pg_publication_tables
    WHERE pubname = 'supabase_realtime' AND tablename = 'taxonomy_nodes'
  ) THEN
    ALTER PUBLICATION supabase_realtime ADD TABLE public.taxonomy_nodes;
  END IF;

  -- controls
  IF NOT EXISTS (
    SELECT 1 FROM pg_publication_tables
    WHERE pubname = 'supabase_realtime' AND tablename = 'controls'
  ) THEN
    ALTER PUBLICATION supabase_realtime ADD TABLE public.controls;
  END IF;

  -- control_links
  IF NOT EXISTS (
    SELECT 1 FROM pg_publication_tables
    WHERE pubname = 'supabase_realtime' AND tablename = 'control_links'
  ) THEN
    ALTER PUBLICATION supabase_realtime ADD TABLE public.control_links;
  END IF;

  -- rct_rows
  IF NOT EXISTS (
    SELECT 1 FROM pg_publication_tables
    WHERE pubname = 'supabase_realtime' AND tablename = 'rct_rows'
  ) THEN
    ALTER PUBLICATION supabase_realtime ADD TABLE public.rct_rows;
  END IF;

  -- pending_changes
  IF NOT EXISTS (
    SELECT 1 FROM pg_publication_tables
    WHERE pubname = 'supabase_realtime' AND tablename = 'pending_changes'
  ) THEN
    ALTER PUBLICATION supabase_realtime ADD TABLE public.pending_changes;
  END IF;
END $$;

COMMENT ON TABLE public.taxonomy_nodes IS 'Realtime enabled for cross-user sync';
COMMENT ON TABLE public.controls IS 'Realtime enabled for cross-user sync';
COMMENT ON TABLE public.control_links IS 'Realtime enabled for cross-user sync';
COMMENT ON TABLE public.rct_rows IS 'Realtime enabled for cross-user sync';
COMMENT ON TABLE public.pending_changes IS 'Realtime enabled for cross-user sync';
```

Run the migration:
```bash
npx supabase db push
```

Note: In Supabase Dashboard, you can also enable Realtime via Database > Replication > Enable for specific tables. This migration ensures it's reproducible.
  </action>
  <verify>Run `npx supabase db push` to apply migration. Check Supabase Dashboard > Database > Replication to confirm tables are listed under supabase_realtime publication.</verify>
  <done>Realtime enabled for taxonomy_nodes, controls, control_links, rct_rows, and pending_changes tables</done>
</task>

</tasks>

<verification>
- [ ] useRealtimeSync hook subscribes to database changes on mount
- [ ] React Strict Mode double-mount is handled (no duplicate subscriptions)
- [ ] RealtimeProvider is in correct position in provider hierarchy
- [ ] Tables are added to supabase_realtime publication
- [ ] Changes in one browser tab appear in another tab without refresh
- [ ] Console shows "[Realtime] Subscribed to tenant database changes" after login
</verification>

<success_criteria>
- Realtime subscriptions work for authenticated users
- Cache invalidation triggers React Query refetch
- Changes propagate between users within same tenant
- No memory leaks (cleanup on unmount)
</success_criteria>

<output>
After completion, create `.planning/phases/26-shared-tenant-database/26-06-SUMMARY.md`
</output>
