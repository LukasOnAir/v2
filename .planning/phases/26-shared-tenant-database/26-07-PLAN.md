---
phase: 26-shared-tenant-database
plan: 07
type: execute
wave: 4
depends_on: ["26-03", "26-04", "26-05", "26-06"]
files_modified:
  - src/stores/taxonomyStore.ts
  - src/stores/controlsStore.ts
  - src/stores/rctStore.ts
  - src/hooks/useTenantData.ts
autonomous: true

must_haves:
  truths:
    - "Application loads data from Supabase instead of LocalStorage for authenticated users"
    - "Demo mode continues to use LocalStorage (no authentication)"
    - "Zustand stores still provide actions but delegate to database mutations"
    - "Existing UI components continue to work without modification"
  artifacts:
    - path: "src/hooks/useTenantData.ts"
      provides: "Central hook for loading/managing tenant data"
      exports: ["useTenantData", "useTenantDataLoading"]
    - path: "src/stores/taxonomyStore.ts"
      provides: "Updated store with database-backed mutations"
      contains: "supabase"
    - path: "src/stores/controlsStore.ts"
      provides: "Updated store with database-backed mutations"
      contains: "supabase"
  key_links:
    - from: "src/stores/taxonomyStore.ts"
      to: "src/hooks/useTaxonomy.ts"
      via: "Store actions call mutation hooks"
      pattern: "import.*useTaxonomy"
---

<objective>
Migrate frontend data layer from LocalStorage-only Zustand stores to database-backed state with React Query, while preserving demo mode functionality.

Purpose: This is the final integration step that connects the UI to the database. Authenticated users get shared tenant data from Supabase. Demo mode (unauthenticated) continues to use LocalStorage for local-only experimentation.

Output: Updated stores that route to database for authenticated users, central data loading hook, preserved demo mode.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-shared-tenant-database/26-RESEARCH.md

# Existing stores to modify
@src/stores/taxonomyStore.ts
@src/stores/controlsStore.ts
@src/stores/rctStore.ts

# New hooks from previous plans
@src/hooks/useTaxonomy.ts
@src/hooks/useControls.ts
@src/hooks/useRCTRows.ts

# Auth context for demo mode detection
@src/contexts/AuthContext.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useTenantData hook for coordinated data loading</name>
  <files>src/hooks/useTenantData.ts</files>
  <action>
Create src/hooks/useTenantData.ts as a central hook for loading tenant data:

```typescript
import { useTaxonomy } from '@/hooks/useTaxonomy'
import { useTaxonomyWeights } from '@/hooks/useTaxonomyWeights'
import { useControls } from '@/hooks/useControls'
import { useControlLinks } from '@/hooks/useControlLinks'
import { useRCTRows } from '@/hooks/useRCTRows'
import { useCustomColumns } from '@/hooks/useCustomColumns'
import { useScoreLabels } from '@/hooks/useScoreLabels'
import { useAuth } from '@/contexts/AuthContext'
import { useMemo } from 'react'

/**
 * Central hook for loading all tenant data.
 *
 * Returns loading state and data for all core entities.
 * Components can use individual hooks for specific data,
 * or this hook for coordinated loading state.
 */
export function useTenantData() {
  const { session } = useAuth()
  const isAuthenticated = !!session

  // Core data queries (only enabled when authenticated)
  const risks = useTaxonomy('risk')
  const processes = useTaxonomy('process')
  const riskWeights = useTaxonomyWeights('risk')
  const processWeights = useTaxonomyWeights('process')
  const controls = useControls()
  const controlLinks = useControlLinks()
  const rctRows = useRCTRows()
  const customColumns = useCustomColumns()
  const probabilityLabels = useScoreLabels('probability')
  const impactLabels = useScoreLabels('impact')

  // Aggregate loading state
  const isLoading = useMemo(() => {
    if (!isAuthenticated) return false // Demo mode - no loading

    return (
      risks.isLoading ||
      processes.isLoading ||
      riskWeights.isLoading ||
      processWeights.isLoading ||
      controls.isLoading ||
      controlLinks.isLoading ||
      rctRows.isLoading ||
      customColumns.isLoading ||
      probabilityLabels.isLoading ||
      impactLabels.isLoading
    )
  }, [
    isAuthenticated,
    risks.isLoading,
    processes.isLoading,
    riskWeights.isLoading,
    processWeights.isLoading,
    controls.isLoading,
    controlLinks.isLoading,
    rctRows.isLoading,
    customColumns.isLoading,
    probabilityLabels.isLoading,
    impactLabels.isLoading,
  ])

  // Aggregate error state
  const error = useMemo(() => {
    const errors = [
      risks.error,
      processes.error,
      controls.error,
      rctRows.error,
    ].filter(Boolean)

    return errors.length > 0 ? errors[0] : null
  }, [risks.error, processes.error, controls.error, rctRows.error])

  return {
    isAuthenticated,
    isLoading,
    error,
    data: {
      risks: risks.data || [],
      processes: processes.data || [],
      riskWeights: riskWeights.data || { levelDefaults: { l1: 1, l2: 1, l3: 1, l4: 1, l5: 1 }, nodeOverrides: {} },
      processWeights: processWeights.data || { levelDefaults: { l1: 1, l2: 1, l3: 1, l4: 1, l5: 1 }, nodeOverrides: {} },
      controls: controls.data || [],
      controlLinks: controlLinks.data || [],
      rctRows: rctRows.data || [],
      customColumns: customColumns.data || [],
      probabilityLabels: probabilityLabels.data || [],
      impactLabels: impactLabels.data || [],
    },
  }
}

/**
 * Hook for components that only need loading state.
 */
export function useTenantDataLoading() {
  const { isLoading, error } = useTenantData()
  return { isLoading, error }
}

/**
 * Check if we're in demo mode (not authenticated).
 */
export function useIsDemoMode() {
  const { session } = useAuth()
  return !session
}
```

This hook provides:
- Coordinated loading state across all data queries
- Type-safe access to all tenant data
- Demo mode detection for conditional behavior
  </action>
  <verify>Run `npm run typecheck` to verify hook types. Check that all imported hooks exist from previous plans.</verify>
  <done>useTenantData hook created for coordinated data loading</done>
</task>

<task type="auto">
  <name>Task 2: Update taxonomyStore for dual-mode operation</name>
  <files>src/stores/taxonomyStore.ts</files>
  <action>
Update src/stores/taxonomyStore.ts to support both demo mode (LocalStorage) and authenticated mode (database).

The key insight: Zustand stores can remain for local state management, but when authenticated, mutations should trigger database operations instead of just LocalStorage.

However, this creates a complexity: React Query hooks can't be called from Zustand actions (hooks must be in React components).

**Solution Architecture:**
1. Keep Zustand store for UI state and demo mode
2. Create a new pattern: "store wrappers" that check auth state and route to either Zustand or React Query mutations
3. For Phase 26, we'll use a simpler approach: components call React Query hooks directly when authenticated

**Simpler Approach for Now:**
Rather than modifying the existing store extensively, we'll:
1. Keep the store for demo mode
2. Add a flag to detect demo mode
3. Components will use conditional logic: `isDemoMode ? store.action() : mutation.mutate()`

Update the store to export a demo mode flag:

```typescript
// Add to taxonomyStore.ts

import { useAuth } from '@/contexts/AuthContext'

// ... existing code ...

/**
 * Helper to check if we're in demo mode (for use in Zustand actions).
 * Note: This is a utility function, not a React hook.
 */
export function isDemoMode(): boolean {
  // Check if there's a session in localStorage (Supabase stores session there)
  const storedSession = localStorage.getItem('sb-auth-token')
  return !storedSession
}

// Update persist middleware to only persist in demo mode
export const useTaxonomyStore = create<TaxonomyState>()(
  persist(
    immer((set, get) => ({
      // ... existing implementation ...
    })),
    {
      name: 'riskguard-taxonomy',
      storage: createJSONStorage(() => localStorage),
      // Only persist if in demo mode
      partialize: (state) => {
        // Check if authenticated - if so, don't persist to localStorage
        const storedSession = localStorage.getItem('sb-auth-token')
        if (storedSession) {
          // Return empty object - don't persist authenticated user data to localStorage
          return {}
        }
        // Demo mode - persist everything
        return {
          risks: state.risks,
          processes: state.processes,
          riskWeights: state.riskWeights,
          processWeights: state.processWeights,
        }
      },
    }
  )
)
```

**Important Note:** This is a partial solution. The full integration requires updating components to check auth state and use appropriate hooks. This will be done in plan 26-08.

For now, focus on:
1. Adding isDemoMode helper
2. Updating persist partialize to not persist authenticated user data to localStorage
3. Documenting the migration pattern for components
  </action>
  <verify>Run `npm run typecheck` to verify store changes compile. Test that demo mode (logged out) still persists to localStorage. Test that authenticated mode does not persist taxonomy to localStorage.</verify>
  <done>taxonomyStore updated with demo mode detection and conditional persistence</done>
</task>

<task type="auto">
  <name>Task 3: Update controlsStore and rctStore for dual-mode operation</name>
  <files>
    src/stores/controlsStore.ts
    src/stores/rctStore.ts
  </files>
  <action>
Apply the same pattern to controlsStore and rctStore:

**src/stores/controlsStore.ts:**
1. Add isDemoMode check to persist partialize
2. Keep existing implementation for demo mode
3. Add TODO comments for component migration

```typescript
// In persist config:
{
  name: 'riskguard-controls',
  storage: createJSONStorage(() => localStorage),
  partialize: (state) => {
    // Don't persist authenticated user data to localStorage
    const storedSession = localStorage.getItem('sb-auth-token')
    if (storedSession) {
      return {}
    }
    return {
      controls: state.controls,
      controlLinks: state.controlLinks,
      migrationVersion: state.migrationVersion,
    }
  },
}
```

**src/stores/rctStore.ts:**
Same pattern:

```typescript
// In persist config:
{
  name: 'riskguard-rct',
  storage: createJSONStorage(() => localStorage),
  merge: (persistedState, currentState) => ({
    ...currentState,
    ...(persistedState as Partial<RCTState>),
    columnVisibility: {
      ...((persistedState as Partial<RCTState>)?.columnVisibility || {}),
      riskId: false,
      processId: false,
    },
  }),
  partialize: (state) => {
    // Don't persist authenticated user data to localStorage
    const storedSession = localStorage.getItem('sb-auth-token')
    if (storedSession) {
      // Keep only UI preferences, not data
      return {
        columnVisibility: state.columnVisibility,
        columnOrder: state.columnOrder,
      }
    }
    // Demo mode - persist everything
    return {
      rows: state.rows,
      customColumns: state.customColumns,
      columnVisibility: state.columnVisibility,
      columnOrder: state.columnOrder,
      probabilityLabels: state.probabilityLabels,
      impactLabels: state.impactLabels,
      changeRequests: state.changeRequests,
      controlTests: state.controlTests,
      remediationPlans: state.remediationPlans,
    }
  },
}
```

Note: For rctStore, we still persist UI preferences (columnVisibility, columnOrder) even when authenticated, as these are user-specific settings not shared tenant data.

**TODO for next plan (26-08):**
- Update components to use React Query hooks when authenticated
- Create wrapper components or custom hooks that abstract the demo/auth mode difference
- Migrate page-level components to new data flow
  </action>
  <verify>Run `npm run typecheck` to verify store changes. Test that authenticated mode only persists UI preferences (not data rows). Test that demo mode persists all data.</verify>
  <done>controlsStore and rctStore updated with conditional persistence</done>
</task>

</tasks>

<verification>
- [ ] useTenantData hook provides coordinated loading state
- [ ] useIsDemoMode correctly detects authentication state
- [ ] Zustand stores don't persist data to localStorage when authenticated
- [ ] Zustand stores continue to persist data in demo mode
- [ ] UI preferences (column visibility) persist regardless of auth state
- [ ] TypeScript types remain correct after store modifications
</verification>

<success_criteria>
- Dual-mode architecture established (demo vs authenticated)
- LocalStorage no longer stores tenant data for authenticated users
- Demo mode functionality preserved
- Foundation laid for component migration in next plan
</success_criteria>

<output>
After completion, create `.planning/phases/26-shared-tenant-database/26-07-SUMMARY.md`
</output>
