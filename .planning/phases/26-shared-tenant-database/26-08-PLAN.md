---
phase: 26-shared-tenant-database
plan: 08
type: execute
wave: 5
depends_on: ["26-07"]
files_modified:
  - src/pages/RiskTaxonomyPage.tsx
  - src/pages/ProcessTaxonomyPage.tsx
  - src/pages/RCTPage.tsx
  - src/components/taxonomy/TaxonomyTree.tsx
  - src/components/rct/RCTTable.tsx
autonomous: true

must_haves:
  truths:
    - "RiskTaxonomyPage loads taxonomy from database when authenticated"
    - "ProcessTaxonomyPage loads taxonomy from database when authenticated"
    - "RCTPage loads RCT rows from database when authenticated"
    - "Taxonomy editing uses database mutations when authenticated"
    - "Demo mode continues to work with LocalStorage"
  artifacts:
    - path: "src/pages/RiskTaxonomyPage.tsx"
      provides: "Taxonomy page with database integration"
      contains: "useTaxonomy"
    - path: "src/pages/ProcessTaxonomyPage.tsx"
      provides: "Taxonomy page with database integration"
      contains: "useTaxonomy"
    - path: "src/pages/RCTPage.tsx"
      provides: "RCT page with database integration"
      contains: "useRCTRows"
  key_links:
    - from: "src/pages/RiskTaxonomyPage.tsx"
      to: "src/hooks/useTaxonomy.ts"
      via: "Hook call for data fetching"
      pattern: "useTaxonomy\\('risk'\\)"
---

<objective>
Update core page components to use React Query hooks for data fetching and mutations when authenticated, while preserving demo mode functionality.

Purpose: This is the critical integration that makes the application actually use the database. Users will see shared tenant data instead of browser-local data.

Output: Updated page components that load from and save to Supabase when authenticated.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-shared-tenant-database/26-RESEARCH.md

# Pages to update
@src/pages/RiskTaxonomyPage.tsx
@src/pages/ProcessTaxonomyPage.tsx
@src/pages/RCTPage.tsx

# New hooks to use
@src/hooks/useTaxonomy.ts
@src/hooks/useControls.ts
@src/hooks/useRCTRows.ts
@src/hooks/useTenantData.ts

# Existing stores for demo mode
@src/stores/taxonomyStore.ts
@src/stores/rctStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update RiskTaxonomyPage and ProcessTaxonomyPage</name>
  <files>
    src/pages/RiskTaxonomyPage.tsx
    src/pages/ProcessTaxonomyPage.tsx
  </files>
  <action>
Update both taxonomy pages to use React Query hooks when authenticated.

Read the current implementation of each page first, then update with:

**Pattern to apply:**

```typescript
import { useTaxonomy, useAddTaxonomyNode, useUpdateTaxonomyNode, useDeleteTaxonomyNode } from '@/hooks/useTaxonomy'
import { useTaxonomyStore } from '@/stores/taxonomyStore'
import { useIsDemoMode } from '@/hooks/useTenantData'

function RiskTaxonomyPage() {
  const isDemoMode = useIsDemoMode()

  // Database hooks (only enabled when authenticated)
  const { data: dbRisks, isLoading } = useTaxonomy('risk')
  const addMutation = useAddTaxonomyNode('risk')
  const updateMutation = useUpdateTaxonomyNode('risk')
  const deleteMutation = useDeleteTaxonomyNode('risk')

  // Zustand store for demo mode
  const storeRisks = useTaxonomyStore((s) => s.risks)
  const setRisks = useTaxonomyStore((s) => s.setRisks)

  // Use appropriate data source
  const risks = isDemoMode ? storeRisks : (dbRisks || [])

  // Loading state (only when authenticated)
  if (!isDemoMode && isLoading) {
    return <div>Loading...</div>
  }

  // Handlers that route to appropriate backend
  const handleAddNode = async (name: string, parentId?: string) => {
    if (isDemoMode) {
      // Existing Zustand logic
      // ... use setRisks with updated tree
    } else {
      await addMutation.mutateAsync({ name, parentId })
    }
  }

  const handleUpdateNode = async (id: string, name: string) => {
    if (isDemoMode) {
      // Existing Zustand logic
    } else {
      await updateMutation.mutateAsync({ id, name })
    }
  }

  const handleDeleteNode = async (id: string) => {
    if (isDemoMode) {
      // Existing Zustand logic
    } else {
      await deleteMutation.mutateAsync(id)
    }
  }

  // ... rest of component with handlers passed to children
}
```

**Key changes:**
1. Import hooks from @/hooks/useTaxonomy
2. Add useIsDemoMode() check
3. Fetch from database when authenticated
4. Route mutations to either Zustand or React Query based on mode
5. Show loading state when fetching from database
6. Keep all existing UI/UX the same

Apply this pattern to both RiskTaxonomyPage.tsx and ProcessTaxonomyPage.tsx (changing 'risk' to 'process' for the latter).

Read each file first to understand the current implementation, then make minimal changes to add database support.
  </action>
  <verify>Run `npm run typecheck` to verify types. Test in browser: (1) Log out, verify demo mode uses LocalStorage, (2) Log in, verify data loads from database, (3) Make a change, verify it persists to database and appears in another browser tab.</verify>
  <done>Both taxonomy pages updated with database integration and demo mode preservation</done>
</task>

<task type="auto">
  <name>Task 2: Update RCTPage with database integration</name>
  <files>
    src/pages/RCTPage.tsx
    src/components/rct/RCTTable.tsx
  </files>
  <action>
Update RCTPage and RCTTable to use React Query hooks for RCT data.

The RCT page is more complex because it:
1. Combines taxonomy data (to display risk/process names)
2. Has RCT rows with scores
3. Has controls linked to rows
4. Has custom columns

**Read the current implementation first**, then apply similar pattern:

```typescript
import { useRCTRows, useUpdateRCTRow, useCreateRCTRow } from '@/hooks/useRCTRows'
import { useControls } from '@/hooks/useControls'
import { useControlLinks } from '@/hooks/useControlLinks'
import { useTaxonomy } from '@/hooks/useTaxonomy'
import { useIsDemoMode } from '@/hooks/useTenantData'
import { useRCTStore } from '@/stores/rctStore'

function RCTPage() {
  const isDemoMode = useIsDemoMode()

  // Database queries
  const { data: dbRctRows, isLoading: rowsLoading } = useRCTRows()
  const { data: dbControls } = useControls()
  const { data: dbControlLinks } = useControlLinks()
  const { data: risks } = useTaxonomy('risk')
  const { data: processes } = useTaxonomy('process')
  const updateRowMutation = useUpdateRCTRow()

  // Zustand for demo mode
  const storeRows = useRCTStore((s) => s.rows)

  // Combine data sources
  const rctRows = isDemoMode ? storeRows : (dbRctRows || [])

  // ... rest of component
}
```

**Note on RCT Row structure:**
The database stores minimal row data (riskId, processId, scores, customValues).
The full RCTRow type includes denormalized taxonomy data (riskL1Name, etc.).

For the initial migration, we have two options:
1. Compute denormalized names on the client by joining rctRows with taxonomy data
2. Create a database view that joins the data

For simplicity in this plan, use option 1 - compute names client-side:

```typescript
// Helper to denormalize RCT row with taxonomy data
function denormalizeRow(
  row: RCTRowData,
  riskTree: TaxonomyItem[],
  processTree: TaxonomyItem[]
): RCTRow {
  // Find risk node by ID and get ancestors
  const riskPath = findNodePath(riskTree, row.riskId)
  const processPath = findNodePath(processTree, row.processId)

  return {
    ...row,
    // Risk hierarchy
    riskL1Id: riskPath[0]?.id || '',
    riskL1Name: riskPath[0]?.name || '',
    riskL2Id: riskPath[1]?.id || '',
    riskL2Name: riskPath[1]?.name || '',
    // ... etc
    riskName: riskPath[riskPath.length - 1]?.name || '',
    riskDescription: riskPath[riskPath.length - 1]?.description || '',
    // Process hierarchy (same pattern)
    // ...
    // Controls from control links
    controls: [], // Populated separately
    hasControls: false,
    // Net scores computed from control links
    netProbability: null,
    netImpact: null,
    netScore: null,
    netWithinAppetite: null,
  }
}
```

This is complex - focus on getting basic data loading working first.
The denormalization can be optimized in a follow-up plan if needed.
  </action>
  <verify>Run `npm run typecheck`. Test RCT page loads data from database when logged in. Verify row updates persist to database. Test demo mode still works.</verify>
  <done>RCTPage and RCTTable updated with database integration</done>
</task>

<task type="auto">
  <name>Task 3: Update TaxonomyTree component for database mutations</name>
  <files>src/components/taxonomy/TaxonomyTree.tsx</files>
  <action>
Update TaxonomyTree component to accept mutation callbacks.

The TaxonomyTree component is likely used by both taxonomy pages. It needs to:
1. Receive data (already works - passed as prop)
2. Call mutation callbacks for add/update/delete instead of direct store calls

**Read the current implementation first**, then update:

**Option A: Pass callbacks from page (preferred)**
The page passes onAdd, onUpdate, onDelete callbacks that abstract the demo/auth logic:

```typescript
interface TaxonomyTreeProps {
  items: TaxonomyItem[]
  onAdd?: (name: string, parentId?: string) => Promise<void>
  onUpdate?: (id: string, name: string, description?: string) => Promise<void>
  onDelete?: (id: string) => Promise<void>
  // ... other existing props
}
```

**Option B: Component handles mode internally**
Less preferred as it duplicates mode-checking logic.

**Apply Option A:**
1. Update TaxonomyTree to accept callbacks
2. Remove direct store calls from the component
3. Call the callbacks instead
4. Pages pass appropriate handlers based on demo/auth mode

```typescript
// In TaxonomyTree.tsx
const handleAddNode = async (name: string, parentId?: string) => {
  if (onAdd) {
    await onAdd(name, parentId)
  }
}

// Instead of:
// useTaxonomyStore.getState().setRisks(...)

// Use:
// onAdd?.(name, parentId)
```

This keeps the component pure and testable - it doesn't need to know about auth state or database.
  </action>
  <verify>Run `npm run typecheck`. Test taxonomy tree add/update/delete operations work in both demo and authenticated modes.</verify>
  <done>TaxonomyTree component updated to use callback props for mutations</done>
</task>

</tasks>

<verification>
- [ ] RiskTaxonomyPage loads from database when authenticated
- [ ] ProcessTaxonomyPage loads from database when authenticated
- [ ] RCTPage loads rows from database when authenticated
- [ ] Taxonomy mutations persist to database
- [ ] Demo mode (logged out) continues to use LocalStorage
- [ ] Loading states display while fetching from database
- [ ] Changes in one tab appear in another tab (realtime sync working)
</verification>

<success_criteria>
- Core pages use React Query hooks for authenticated users
- Demo mode preserved with LocalStorage
- No regression in existing functionality
- Type safety maintained
- Components accept callbacks for mutation abstraction
</success_criteria>

<output>
After completion, create `.planning/phases/26-shared-tenant-database/26-08-SUMMARY.md`
</output>
