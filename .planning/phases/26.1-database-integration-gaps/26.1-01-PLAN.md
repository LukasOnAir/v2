---
phase: 26.1-database-integration-gaps
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/useRCTRows.ts
  - src/components/rct/RCTTable.tsx
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Regenerate RCT preserves existing row data when taxonomy changes"
    - "New taxonomy combinations are added as new rows"
    - "Rows for removed taxonomy combinations are preserved (no data loss)"
  artifacts:
    - path: "src/hooks/useRCTRows.ts"
      provides: "useBulkUpsertRCTRows hook"
      exports: ["useBulkUpsertRCTRows"]
    - path: "src/components/rct/RCTTable.tsx"
      provides: "Regenerate button uses upsert in auth mode"
      contains: "bulkUpsertRCTRowsMutation"
  key_links:
    - from: "src/components/rct/RCTTable.tsx"
      to: "src/hooks/useRCTRows.ts"
      via: "useBulkUpsertRCTRows import"
      pattern: "useBulkUpsertRCTRows"
---

<objective>
Fix Regenerate RCT button to update existing rows when taxonomy changes

Purpose: Currently, the Regenerate RCT button in authenticated mode uses `bulkCreateRCTRowsMutation` which only INSERTs new rows. When taxonomy changes, existing rows with data (scores, customValues) should be preserved, and only new risk:process combinations should be inserted.

Output: An upsert hook that preserves existing data, plus updated RCTTable using this hook.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/26.1-database-integration-gaps/26.1-RESEARCH.md

Reference implementation:
@src/hooks/useRCTRows.ts (existing bulk create hook to extend)
@src/components/rct/RCTTable.tsx (lines 436-466 - regenerate handler)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useBulkUpsertRCTRows hook</name>
  <files>src/hooks/useRCTRows.ts</files>
  <action>
Add a new `useBulkUpsertRCTRows` hook after the existing `useBulkCreateRCTRows` hook.

Implementation approach:
1. Accept array of `{ riskId, processId, riskAppetite? }` objects
2. Query existing rows with `SELECT id, risk_id, process_id FROM rct_rows`
3. Build a Map of existing `riskId:processId` combinations
4. Filter input to only rows NOT in the Map (new combinations)
5. If no new rows, return early (nothing to insert)
6. Insert only the new rows using the same format as bulkCreateRCTRows

Do NOT delete orphaned rows - preserve existing data.

Export the new hook alongside existing exports.

```typescript
export function useBulkUpsertRCTRows() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (rows: Array<{
      riskId: string
      processId: string
      riskAppetite?: number
    }>) => {
      // 1. Fetch existing rows to find which combinations already exist
      const { data: existingRows, error: fetchError } = await supabase
        .from('rct_rows')
        .select('risk_id, process_id')

      if (fetchError) throw fetchError

      // 2. Build set of existing combinations
      const existingKeys = new Set(
        existingRows.map(r => `${r.risk_id}:${r.process_id}`)
      )

      // 3. Filter to only new combinations
      const newRows = rows.filter(r =>
        !existingKeys.has(`${r.riskId}:${r.processId}`)
      )

      // 4. If no new rows, return empty array
      if (newRows.length === 0) {
        return []
      }

      // 5. Insert only new rows
      const inserts = newRows.map(row => ({
        row_id: `${row.riskId}:${row.processId}`,
        risk_id: row.riskId,
        process_id: row.processId,
        risk_appetite: row.riskAppetite ?? 9,
      }))

      const { data, error } = await supabase
        .from('rct_rows')
        .insert(inserts)
        .select()

      if (error) throw error
      return data.map(toRCTRow)
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: ['rctRows'] })
      if (data.length > 0) {
        toast.success(`Added ${data.length} new row${data.length > 1 ? 's' : ''}`)
      } else {
        toast.info('RCT is up to date')
      }
    },
  })
}
```
  </action>
  <verify>TypeScript compiles without errors: `npx tsc --noEmit`</verify>
  <done>useBulkUpsertRCTRows hook exported from useRCTRows.ts</done>
</task>

<task type="auto">
  <name>Task 2: Update RCTTable to use upsert for regenerate</name>
  <files>src/components/rct/RCTTable.tsx</files>
  <action>
Update the handleGenerateRows function to use useBulkUpsertRCTRows instead of useBulkCreateRCTRows in authenticated mode.

1. Add import for useBulkUpsertRCTRows:
   ```typescript
   import { useRCTRows, useUpdateRCTRow, useBulkUpsertRCTRows, type RCTRowData } from '@/hooks/useRCTRows'
   ```

2. Replace `bulkCreateRCTRowsMutation` with `bulkUpsertRCTRowsMutation`:
   ```typescript
   // Change this line:
   const bulkCreateRCTRowsMutation = useBulkCreateRCTRows()
   // To:
   const bulkUpsertRCTRowsMutation = useBulkUpsertRCTRows()
   ```

3. In handleGenerateRows (around line 447-464), update authenticated mode to use the upsert mutation:
   ```typescript
   } else {
     // Authenticated mode: use database with upsert
     const newRows = generateRCTRows(risks, processes)

     if (newRows.length === 0) {
       return
     }

     // Convert to database format
     const dbRows = newRows.map((row) => ({
       riskId: row.riskId,
       processId: row.processId,
       riskAppetite: row.riskAppetite,
     }))

     bulkUpsertRCTRowsMutation.mutate(dbRows)
   }
   ```

Note: The `rowId` field is no longer passed - the hook constructs it internally.
  </action>
  <verify>
1. `npx tsc --noEmit` - no TypeScript errors
2. Manual test: Add a new taxonomy item, click Regenerate RCT, verify:
   - Existing rows preserve their scores
   - New row(s) appear for the new taxonomy combination
   - Toast shows "Added N new row(s)" or "RCT is up to date"
  </verify>
  <done>Regenerate RCT button uses upsert mutation, preserving existing data</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit`
2. App loads without errors: `npm run dev`
3. Functional test in authenticated mode:
   - Create initial taxonomy and generate RCT
   - Set scores on some rows
   - Add a new risk taxonomy item
   - Click Regenerate RCT
   - Verify existing scores are preserved
   - Verify new row appears for new risk
</verification>

<success_criteria>
- useBulkUpsertRCTRows hook exists and is exported
- RCTTable uses useBulkUpsertRCTRows for regenerate in authenticated mode
- Regenerating RCT preserves existing row data (scores, customValues)
- New taxonomy combinations result in new rows being added
- Toast feedback indicates whether rows were added or table is up-to-date
</success_criteria>

<output>
After completion, create `.planning/phases/26.1-database-integration-gaps/26.1-01-SUMMARY.md`
</output>
