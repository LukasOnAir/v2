---
phase: 26.1-database-integration-gaps
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/rct/ControlPanel.tsx
autonomous: true
user_setup: []

must_haves:
  truths:
    - "ControlPanel shows controls from database when authenticated"
    - "ControlPanel shows controls from Zustand store when in demo mode"
    - "Control count in ControlPanel matches control count in RCTTable"
  artifacts:
    - path: "src/components/rct/ControlPanel.tsx"
      provides: "Dual-source data loading for controls and controlLinks"
      contains: "useIsDemoMode"
  key_links:
    - from: "src/components/rct/ControlPanel.tsx"
      to: "src/hooks/useControlLinks.ts"
      via: "useControlLinks import"
      pattern: "useControlLinks"
    - from: "src/components/rct/ControlPanel.tsx"
      to: "src/hooks/useControls.ts"
      via: "useControls import"
      pattern: "useControls"
---

<objective>
Wire ControlPanel to read from database when authenticated

Purpose: ControlPanel currently reads `controls` and `controlLinks` directly from Zustand stores without checking authentication mode. This causes stale demo data to appear when authenticated, and control counts to be incorrect.

Output: ControlPanel uses the isDemoMode pattern to read from appropriate data source.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/26.1-database-integration-gaps/26.1-RESEARCH.md

Reference implementation:
@src/components/rct/RCTTable.tsx (lines 256-327 - dual-source pattern)
@src/components/rct/ControlPanel.tsx (current implementation to update)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dual-source data loading to ControlPanel</name>
  <files>src/components/rct/ControlPanel.tsx</files>
  <action>
Apply the isDemoMode pattern from RCTTable to ControlPanel.

1. Add imports at top of file:
   ```typescript
   import { useIsDemoMode } from '@/hooks/useTenantData'
   import { useControlLinks } from '@/hooks/useControlLinks'
   import { useControls } from '@/hooks/useControls'
   ```

2. Inside the ControlPanel component (after destructuring props), add demo mode check:
   ```typescript
   // Demo mode check
   const isDemoMode = useIsDemoMode()
   ```

3. Rename current store access to be explicit about source:
   ```typescript
   // Store data (for demo mode)
   const storeControls = useControlsStore(state => state.controls)
   const storeControlLinks = useControlsStore(state => state.controlLinks)
   ```

4. Add database hooks (below store data):
   ```typescript
   // Database hooks (for authenticated mode)
   const { data: dbControls } = useControls()
   const { data: dbControlLinks } = useControlLinks()
   ```

5. Create unified data sources (before mutations):
   ```typescript
   // Use appropriate data sources based on auth mode
   const controls = isDemoMode ? storeControls : (dbControls || [])
   const controlLinks = isDemoMode ? storeControlLinks : (dbControlLinks || [])
   ```

6. Update usages throughout the component:
   - Line ~131: `const { controls, controlLinks, linkControl, unlinkControl, updateControl: updateHubControl, addControl: addHubControl } = useControlsStore()`
   - Keep the mutations from useControlsStore (`linkControl`, `unlinkControl`, `updateHubControl`, `addHubControl`) but use the unified `controls` and `controlLinks` variables for data reads

7. The `availableControls` useMemo (line ~285) should use the unified `controls` variable - it already does if you replace the variable.

8. The `linkedControls` useMemo (line ~315) already uses `controlLinks` and `controls` variables, so it will automatically use the correct source.

9. The `linkCountMap` useMemo (line ~303) already uses `controlLinks`, so it will use the correct source.

Key changes summary:
- Add `useIsDemoMode()` call
- Add `useControls()` and `useControlLinks()` hook calls
- Create `controls` and `controlLinks` variables that branch on isDemoMode
- Keep store mutations for demo mode compatibility
  </action>
  <verify>
1. `npx tsc --noEmit` - no TypeScript errors
2. Manual test in authenticated mode:
   - Open ControlPanel for an RCT row
   - Verify controls appear (not "0 controls" when controls exist)
   - Add a control, verify it appears
   - Refresh page, verify control persists
  </verify>
  <done>ControlPanel reads from database when authenticated, store when in demo mode</done>
</task>

<task type="auto">
  <name>Task 2: Wire mutation handlers to database when authenticated</name>
  <files>src/components/rct/ControlPanel.tsx</files>
  <action>
The ControlPanel has several mutation handlers that need to route to database vs store.

Currently, mutations go directly to Zustand stores:
- `linkControl(controlId, rowId)`
- `unlinkControl(linkId)`
- `updateHubControl(controlId, updates)`
- `addHubControl(control)`

For full database integration, these need database hooks. HOWEVER, looking at the existing codebase:
- The store mutations include logic for the approval workflow
- The database hooks don't exist for all operations yet

For this plan, focus on data READING (which is the immediate issue).

For mutations, keep the current store-based approach. The realtime sync (useRealtimeSync) should propagate database changes to stores, and vice versa.

Actually, check if database mutation hooks exist:
- `useCreateControl` - check in useControls.ts
- `useLinkControl` - check in useControlLinks.ts
- `useUnlinkControl` - check in useControlLinks.ts
- `useUpdateControl` - check in useControls.ts

If these hooks exist, add conditional mutation routing:

```typescript
// Database mutations (if hooks exist)
const createControlMutation = useCreateControl()
const linkControlMutation = useLinkControl()
const unlinkControlMutation = useUnlinkControl()
const updateControlMutation = useUpdateControl()

// Unified handlers
const handleAddControl = () => {
  if (!newDescription.trim()) return

  if (isDemoMode) {
    const controlId = addHubControl({...})
    linkControl(controlId, row.id)
  } else {
    // Database mutation
    createControlMutation.mutate({
      name: newDescription.trim(),
      // ... other fields
    }, {
      onSuccess: (control) => {
        linkControlMutation.mutate({ controlId: control.id, rowId: row.id })
      }
    })
  }
  setNewDescription('')
}
```

If database mutation hooks DON'T exist yet, leave mutations using store and add a TODO comment:
```typescript
// TODO: Add database mutation hooks for full authenticated mode support
// For now, realtime sync propagates store changes to database
```

The critical fix is reading data from database - mutations can be a follow-up if hooks don't exist.
  </action>
  <verify>
1. `npx tsc --noEmit` - no TypeScript errors
2. Check if mutations work in both modes (store for demo, database for auth if hooks exist)
  </verify>
  <done>Control mutations route appropriately based on auth mode (or TODO documented for missing hooks)</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit`
2. App loads without errors: `npm run dev`
3. Demo mode: ControlPanel shows/manages controls via Zustand stores
4. Authenticated mode:
   - ControlPanel shows controls from database
   - Control count matches what RCTTable shows
   - No stale demo data appears
</verification>

<success_criteria>
- ControlPanel imports and uses `useIsDemoMode()`
- ControlPanel imports and calls `useControls()` and `useControlLinks()`
- Data reading branches on isDemoMode (store vs database)
- Control counts are correct in authenticated mode
- No stale demo controls appear when authenticated
</success_criteria>

<output>
After completion, create `.planning/phases/26.1-database-integration-gaps/26.1-02-SUMMARY.md`
</output>
