---
phase: 26.1-database-integration-gaps
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/rct/RCTTable.tsx
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Custom columns read from database when authenticated"
    - "Custom column values save correctly to database"
    - "Dropdown custom columns display correct options from database"
  artifacts:
    - path: "src/components/rct/RCTTable.tsx"
      provides: "Dual-source custom columns loading"
      contains: "useCustomColumns"
  key_links:
    - from: "src/components/rct/RCTTable.tsx"
      to: "src/hooks/useCustomColumns.ts"
      via: "useCustomColumns import"
      pattern: "useCustomColumns"
---

<objective>
Wire RCTTable custom columns to read from database when authenticated

Purpose: Custom columns definitions (name, type, options, formula) are read from Zustand store `useRCTStore().customColumns` without checking auth mode. This causes custom columns to not appear or have wrong options in authenticated mode.

Output: RCTTable reads custom column definitions from database when authenticated.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/26.1-database-integration-gaps/26.1-RESEARCH.md

Reference:
@src/hooks/useCustomColumns.ts (existing hook)
@src/components/rct/RCTTable.tsx (lines 259-266 - store destructuring including customColumns)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dual-source custom columns loading</name>
  <files>src/components/rct/RCTTable.tsx</files>
  <action>
Apply the isDemoMode pattern to custom columns in RCTTable.

1. Add import for useCustomColumns hook:
   ```typescript
   import { useCustomColumns } from '@/hooks/useCustomColumns'
   ```

2. The existing code destructures `customColumns` from useRCTStore (line ~265):
   ```typescript
   const {
     rows: storeRows,
     setRows,
     updateRow: storeUpdateRow,
     columnVisibility,
     setColumnVisibility,
     customColumns,  // <-- this line
   } = useRCTStore()
   ```

   Rename to `storeCustomColumns`:
   ```typescript
   const {
     rows: storeRows,
     setRows,
     updateRow: storeUpdateRow,
     columnVisibility,
     setColumnVisibility,
     customColumns: storeCustomColumns,
   } = useRCTStore()
   ```

3. After the existing database hooks section (around line 277), add:
   ```typescript
   // Custom columns from database
   const { data: dbCustomColumns } = useCustomColumns()
   ```

4. After the existing data source selection (around line 284), add:
   ```typescript
   // Use appropriate custom columns source
   const customColumns = isDemoMode ? storeCustomColumns : (dbCustomColumns || [])
   ```

5. The `customColumnDefs` useMemo (line ~494) already uses `customColumns` variable, so it will automatically pick up the correct source.

That's it - the custom column values are already stored in `rct_rows.custom_values` JSONB and handled correctly by the existing update flow.
  </action>
  <verify>
1. `npx tsc --noEmit` - no TypeScript errors
2. Manual test in authenticated mode:
   - Add a custom column (text type)
   - Enter a value in the column
   - Refresh page, verify value persists
   - Add a dropdown column with options
   - Select an option, verify it displays correctly
  </verify>
  <done>Custom columns read from database when authenticated, store when in demo mode</done>
</task>

<task type="auto">
  <name>Task 2: Verify custom column mutations route correctly</name>
  <files>src/components/rct/RCTTable.tsx</files>
  <action>
Verify that custom column VALUE changes (the data in each cell) are saved correctly.

The existing `handleCustomValueChange` function (lines 478-491) calls `updateRow` which:
- In demo mode: calls `storeUpdateRow`
- In auth mode: calls `updateRCTRowMutation.mutate` with `customValues`

This should already work because the unified `updateRow` callback handles both modes.

Verify by reading the code flow:
1. `handleCustomValueChange` (line 478) -> calls `updateRow`
2. `updateRow` (line 302-327) -> checks `isDemoMode`, routes to store or mutation
3. Mutation sends `customValues` to database (line 317-322)

The custom column DEFINITIONS (adding/removing columns) are handled in RCTToolbar component, which may also need dual-source wiring. Check if RCTToolbar uses `useAddCustomColumn`, `useDeleteCustomColumn` hooks.

If RCTToolbar modifications are needed, add a note but don't include in this plan (keep scope focused).
  </action>
  <verify>
1. Read through the code to confirm value updates flow through updateRow
2. Test: Edit a custom column value, refresh, verify it persists
  </verify>
  <done>Custom column values save correctly through existing updateRow flow</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit`
2. App loads without errors: `npm run dev`
3. Demo mode: Custom columns from Zustand store appear correctly
4. Authenticated mode:
   - Custom columns from database appear
   - Text column: enter value, save on blur, persists after refresh
   - Number column: enter value, save on blur, persists after refresh
   - Dropdown column: options appear, selection persists after refresh
   - Formula column: calculates correctly based on other columns
</verification>

<success_criteria>
- RCTTable imports `useCustomColumns` hook
- `customColumns` variable branches on isDemoMode
- Custom column definitions load from database when authenticated
- Custom column values save and persist correctly
- Dropdown options display from database-sourced column definitions
</success_criteria>

<output>
After completion, create `.planning/phases/26.1-database-integration-gaps/26.1-03-SUMMARY.md`
</output>
