---
phase: 26.1-database-integration-gaps
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/matrix/MatrixGrid.tsx
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Risk Process Matrix displays data from database when authenticated"
    - "Matrix cells show correct aggregated scores"
    - "Matrix displays data from Zustand store in demo mode"
  artifacts:
    - path: "src/components/matrix/MatrixGrid.tsx"
      provides: "Dual-source data loading for matrix visualization"
      contains: "useIsDemoMode"
  key_links:
    - from: "src/components/matrix/MatrixGrid.tsx"
      to: "src/hooks/useTaxonomy.ts"
      via: "useTaxonomy import"
      pattern: "useTaxonomy"
    - from: "src/components/matrix/MatrixGrid.tsx"
      to: "src/hooks/useRCTRows.ts"
      via: "useRCTRows import"
      pattern: "useRCTRows"
---

<objective>
Wire MatrixGrid to read from database when authenticated

Purpose: MatrixGrid currently reads `risks`, `processes`, `riskWeights`, and `rows` directly from Zustand stores without checking authentication mode. This causes the Risk Process Matrix to show empty when authenticated with database data.

Output: MatrixGrid uses the isDemoMode pattern to display data from the appropriate source.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/26.1-database-integration-gaps/26.1-RESEARCH.md

Reference implementation:
@src/components/rct/RCTTable.tsx (lines 256-296 - dual-source pattern with denormalization)
@src/components/matrix/MatrixGrid.tsx (current implementation to update)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dual-source data loading to MatrixGrid</name>
  <files>src/components/matrix/MatrixGrid.tsx</files>
  <action>
Apply the isDemoMode pattern from RCTTable to MatrixGrid.

1. Add imports at top of file:
   ```typescript
   import { useIsDemoMode } from '@/hooks/useTenantData'
   import { useTaxonomy } from '@/hooks/useTaxonomy'
   import { useRCTRows } from '@/hooks/useRCTRows'
   ```

2. Inside the MatrixGrid component, before the existing store access, add:
   ```typescript
   // Demo mode check
   const isDemoMode = useIsDemoMode()
   ```

3. Rename current store access to be explicit:
   ```typescript
   // Store data (for demo mode)
   const { risks: storeRisks, processes: storeProcesses, riskWeights } = useTaxonomyStore()
   const { rows: storeRows } = useRCTStore()
   ```

4. Add database hooks:
   ```typescript
   // Database hooks (for authenticated mode)
   const { data: dbRisks } = useTaxonomy('risk')
   const { data: dbProcesses } = useTaxonomy('process')
   const { data: dbRctRows } = useRCTRows()
   ```

5. Create unified data sources:
   ```typescript
   // Use appropriate data sources
   const risks = isDemoMode ? storeRisks : (dbRisks || [])
   const processes = isDemoMode ? storeProcesses : (dbProcesses || [])
   ```

6. For rows, we need to handle denormalization similar to RCTTable. However, MatrixGrid only needs `riskId`, `processId`, and score columns - not full hierarchy.

   Looking at the `calculateWeightedAverage` function usage (line 45-51), it needs:
   - `rows` with `riskId`, `riskL1Id`, `riskL2Id`, etc. columns

   The database rows (RCTRowData) only have `riskId` and `processId`, not the denormalized hierarchy columns.

   For MatrixGrid, the scoring calculation uses risk ID matching, so we need to handle this. Two options:

   Option A: Pass minimal row data and update calculateWeightedAverage to work with it
   Option B: Denormalize rows like RCTTable does

   For consistency with RCTTable, use Option B. Add the denormalization helper:

   ```typescript
   import type { TaxonomyItem } from '@/types/taxonomy'
   import type { RCTRow } from '@/types/rct'
   import type { RCTRowData } from '@/hooks/useRCTRows'

   // Copy the denormalizeRCTRow and helper functions from RCTTable, or better:
   // Import from a shared utility (if exists) or create minimal version here
   ```

   Actually, look at what calculateWeightedAverage needs. It may only need the leaf node ID matching.

   Check src/utils/aggregation.ts for calculateWeightedAverage signature.

   If it works with just `riskId`/`processId` matching, then we can use a simpler approach:

   ```typescript
   // For authenticated mode, create minimal RCTRow-like objects
   const rows = useMemo(() => {
     if (isDemoMode) {
       return storeRows
     }
     if (!dbRctRows) return []
     // Create minimal row objects with just what aggregation needs
     return dbRctRows.map(r => ({
       id: r.id,
       riskId: r.riskId,
       processId: r.processId,
       grossScore: r.grossScore,
       riskAppetite: r.riskAppetite,
       // Add hierarchy IDs from taxonomy lookup if needed
     }))
   }, [isDemoMode, storeRows, dbRctRows])
   ```

7. After adding the data sources, verify the component uses the unified variables (not the store variables directly).
  </action>
  <verify>
1. `npx tsc --noEmit` - no TypeScript errors
2. Manual test: Navigate to Risk Process Matrix page when authenticated
   - Matrix should display (not empty)
   - Cell colors should reflect risk scores
  </verify>
  <done>MatrixGrid reads from database when authenticated</done>
</task>

<task type="auto">
  <name>Task 2: Handle row denormalization for matrix scoring</name>
  <files>src/components/matrix/MatrixGrid.tsx</files>
  <action>
Complete the row data transformation for authenticated mode.

First, check what `calculateWeightedAverage` in `@/utils/aggregation.ts` actually requires.

If it needs hierarchy IDs (riskL1Id, riskL2Id, etc.) for weighted scoring by level, we need to denormalize.

Add a minimal denormalization function (or import shared utility if available):

```typescript
/**
 * Denormalize database row for matrix scoring
 * Only includes fields needed for calculateWeightedAverage
 */
function denormalizeForMatrix(
  dbRow: RCTRowData,
  risks: TaxonomyItem[],
  processes: TaxonomyItem[]
): Partial<RCTRow> {
  // Find the leaf risk and process items
  const riskItem = findTaxonomyById(risks, dbRow.riskId)
  const processItem = findTaxonomyById(processes, dbRow.processId)

  // Build hierarchy path from hierarchical ID (e.g., "1.2.3")
  const riskParts = riskItem?.hierarchicalId.split('.') || []
  const processParts = processItem?.hierarchicalId.split('.') || []

  return {
    id: dbRow.id,
    riskId: dbRow.riskId,
    processId: dbRow.processId,
    grossScore: dbRow.grossScore,
    riskAppetite: dbRow.riskAppetite,
    // Add L1-L5 IDs for weighting (hierarchical ID parts)
    riskL1Id: riskParts[0] || '',
    riskL2Id: riskParts.slice(0, 2).join('.') || '',
    riskL3Id: riskParts.slice(0, 3).join('.') || '',
    riskL4Id: riskParts.slice(0, 4).join('.') || '',
    riskL5Id: riskParts.slice(0, 5).join('.') || '',
    processL1Id: processParts[0] || '',
    processL2Id: processParts.slice(0, 2).join('.') || '',
    processL3Id: processParts.slice(0, 3).join('.') || '',
    processL4Id: processParts.slice(0, 4).join('.') || '',
    processL5Id: processParts.slice(0, 5).join('.') || '',
  } as Partial<RCTRow>
}

// Helper to find taxonomy item by ID
function findTaxonomyById(items: TaxonomyItem[], id: string): TaxonomyItem | null {
  for (const item of items) {
    if (item.id === id) return item
    if (item.children) {
      const found = findTaxonomyById(item.children, id)
      if (found) return found
    }
  }
  return null
}
```

Then update the rows useMemo to use this:

```typescript
const rows = useMemo(() => {
  if (isDemoMode) {
    return storeRows
  }
  if (!dbRctRows || risks.length === 0 || processes.length === 0) {
    return []
  }
  return dbRctRows.map(r => denormalizeForMatrix(r, risks, processes)) as RCTRow[]
}, [isDemoMode, storeRows, dbRctRows, risks, processes])
```

Note: Type assertion may be needed since we're creating partial rows. Check if calculateWeightedAverage handles undefined values gracefully.
  </action>
  <verify>
1. `npx tsc --noEmit` - no TypeScript errors
2. Matrix displays with correct cell colors based on scores
3. Scores aggregate correctly (hover over cell to verify)
  </verify>
  <done>Matrix rows denormalized correctly for scoring calculations</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit`
2. App loads without errors: `npm run dev`
3. Demo mode: Matrix displays data from Zustand stores
4. Authenticated mode:
   - Matrix displays data from database (not empty)
   - Cell colors reflect correct risk scores
   - Aggregation works correctly (weighted average)
   - Zoom controls work
</verification>

<success_criteria>
- MatrixGrid imports and uses `useIsDemoMode()`
- MatrixGrid imports and calls `useTaxonomy('risk')`, `useTaxonomy('process')`, `useRCTRows()`
- Data reading branches on isDemoMode
- Matrix displays correctly in authenticated mode
- No empty matrix when database has data
</success_criteria>

<output>
After completion, create `.planning/phases/26.1-database-integration-gaps/26.1-04-SUMMARY.md`
</output>
