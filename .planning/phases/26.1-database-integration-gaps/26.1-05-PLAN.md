---
phase: 26.1-database-integration-gaps
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/sunburst/useSunburstData.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Sunburst visualization displays data from database when authenticated"
    - "Sunburst shows risk and process taxonomies with correct scores"
    - "Sunburst displays data from Zustand store in demo mode"
  artifacts:
    - path: "src/components/sunburst/useSunburstData.ts"
      provides: "Dual-source data loading for sunburst visualization"
      contains: "useIsDemoMode"
  key_links:
    - from: "src/components/sunburst/useSunburstData.ts"
      to: "src/hooks/useTaxonomy.ts"
      via: "useTaxonomy import"
      pattern: "useTaxonomy"
    - from: "src/components/sunburst/useSunburstData.ts"
      to: "src/hooks/useRCTRows.ts"
      via: "useRCTRows import"
      pattern: "useRCTRows"
---

<objective>
Wire useSunburstData to read from database when authenticated

Purpose: useSunburstData currently reads `risks`, `processes`, `rows`, `controlLinks`, and `controls` directly from Zustand stores without checking authentication mode. This causes the Sunburst visualization to show empty when authenticated with database data.

Output: useSunburstData uses the isDemoMode pattern to display data from the appropriate source.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/26.1-database-integration-gaps/26.1-RESEARCH.md

Reference:
@src/components/rct/RCTTable.tsx (lines 256-296 - dual-source pattern)
@src/components/sunburst/useSunburstData.ts (current implementation to update)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dual-source data loading to useSunburstData</name>
  <files>src/components/sunburst/useSunburstData.ts</files>
  <action>
Apply the isDemoMode pattern to useSunburstData hook.

1. Add imports at top of file:
   ```typescript
   import { useIsDemoMode } from '@/hooks/useTenantData'
   import { useTaxonomy } from '@/hooks/useTaxonomy'
   import { useRCTRows, type RCTRowData } from '@/hooks/useRCTRows'
   import { useControls } from '@/hooks/useControls'
   import { useControlLinks } from '@/hooks/useControlLinks'
   ```

2. Inside the useSunburstData hook (line ~453), add demo mode check BEFORE the existing store access:
   ```typescript
   export function useSunburstData(): SunburstDataResult | null {
     // Demo mode check
     const isDemoMode = useIsDemoMode()

     // Sunburst config from store (always from store - UI settings)
     const { taxonomyType, viewMode, aggregationMode } = useSunburstStore()
   ```

3. Rename current store access to be explicit (lines ~455-459):
   ```typescript
   // Store data (for demo mode)
   const { risks: storeRisks, processes: storeProcesses, riskWeights, processWeights } = useTaxonomyStore()
   const storeRows = useRCTStore((state) => state.rows)
   const storeControlLinks = useControlsStore((state) => state.controlLinks)
   const storeControls = useControlsStore((state) => state.controls)
   ```

4. Add database hooks:
   ```typescript
   // Database hooks (for authenticated mode)
   const { data: dbRisks } = useTaxonomy('risk')
   const { data: dbProcesses } = useTaxonomy('process')
   const { data: dbRctRows } = useRCTRows()
   const { data: dbControls } = useControls()
   const { data: dbControlLinks } = useControlLinks()
   ```

5. Create unified data sources:
   ```typescript
   // Use appropriate data sources
   const risks = isDemoMode ? storeRisks : (dbRisks || [])
   const processes = isDemoMode ? storeProcesses : (dbProcesses || [])
   const controlLinks = isDemoMode ? storeControlLinks : (dbControlLinks || [])
   const allControls = isDemoMode ? storeControls : (dbControls || [])
   ```

6. For rows, handle denormalization like in MatrixGrid plan. The sunburst scoring needs hierarchy IDs for matching.

   Add denormalization helper (can reuse from MatrixGrid or create similar):

   ```typescript
   /**
    * Denormalize database row for sunburst scoring
    */
   function denormalizeForSunburst(
     dbRow: RCTRowData,
     risks: TaxonomyItem[],
     processes: TaxonomyItem[]
   ): RCTRow {
     const findById = (items: TaxonomyItem[], id: string): TaxonomyItem | null => {
       for (const item of items) {
         if (item.id === id) return item
         if (item.children) {
           const found = findById(item.children, id)
           if (found) return found
         }
       }
       return null
     }

     const riskItem = findById(risks, dbRow.riskId)
     const processItem = findById(processes, dbRow.processId)
     const riskParts = riskItem?.hierarchicalId.split('.') || []
     const processParts = processItem?.hierarchicalId.split('.') || []

     return {
       id: dbRow.id,
       riskId: dbRow.riskId,
       processId: dbRow.processId,
       riskL1Id: riskParts[0] || '',
       riskL2Id: riskParts.slice(0, 2).join('.') || '',
       riskL3Id: riskParts.slice(0, 3).join('.') || '',
       riskL4Id: riskParts.slice(0, 4).join('.') || '',
       riskL5Id: riskParts.slice(0, 5).join('.') || '',
       processL1Id: processParts[0] || '',
       processL2Id: processParts.slice(0, 2).join('.') || '',
       processL3Id: processParts.slice(0, 3).join('.') || '',
       processL4Id: processParts.slice(0, 4).join('.') || '',
       processL5Id: processParts.slice(0, 5).join('.') || '',
       grossScore: dbRow.grossScore,
       grossProbability: dbRow.grossProbability,
       grossImpact: dbRow.grossImpact,
       riskAppetite: dbRow.riskAppetite,
       controls: [],
       // Other fields with defaults
       riskL1Name: '', riskL2Name: '', riskL3Name: '', riskL4Name: '', riskL5Name: '',
       processL1Name: '', processL2Name: '', processL3Name: '', processL4Name: '', processL5Name: '',
       riskName: riskItem?.name || '',
       processName: processItem?.name || '',
       riskDescription: riskItem?.description || '',
       processDescription: processItem?.description || '',
       hasControls: false,
       netScore: null,
       withinAppetite: dbRow.withinAppetite,
       customValues: dbRow.customValues,
     } as RCTRow
   }
   ```

7. Create unified rows with useMemo:
   ```typescript
   const rows = useMemo(() => {
     if (isDemoMode) {
       return storeRows
     }
     if (!dbRctRows || risks.length === 0 || processes.length === 0) {
       return []
     }
     return dbRctRows.map(r => denormalizeForSunburst(r, risks, processes))
   }, [isDemoMode, storeRows, dbRctRows, risks, processes])
   ```

8. Update the useMemo dependency array for result (line ~560) to include all the data sources.
  </action>
  <verify>
1. `npx tsc --noEmit` - no TypeScript errors
2. Manual test: Navigate to Sunburst visualization when authenticated
   - Sunburst should display (not empty)
   - Arcs should show taxonomy structure
   - Colors should reflect risk scores
  </verify>
  <done>useSunburstData reads from database when authenticated</done>
</task>

<task type="auto">
  <name>Task 2: Update calculateRowNetScore for dual-source</name>
  <files>src/components/sunburst/useSunburstData.ts</files>
  <action>
The `calculateRowNetScore` function (lines 112-148) accesses `controlLinks` and `controls` via `useControlsStore.getState()` directly. This needs to use the unified variables.

However, `calculateRowNetScore` is called INSIDE the `buildSunburstTree` function which is called inside useMemo. Passing data through would require significant refactoring.

Better approach: Modify `calculateRowNetScore` to accept controlLinks and controls as parameters:

```typescript
function calculateRowNetScore(
  row: RCTRow,
  controlLinks: ControlLink[],
  controls: Control[]
): number | null {
  // Remove the getState() call, use passed parameters
  // const { controlLinks, controls } = useControlsStore.getState()  // REMOVE THIS LINE

  // ... rest of function uses passed controlLinks and controls
}
```

Then update `calculateLeafScores` to pass these parameters through:

```typescript
function calculateLeafScores(
  rows: RCTRow[],
  type: 'risk' | 'process',
  nodeId: string,
  aggregationMode: 'weighted' | 'max',
  weights: TaxonomyWeights,
  controlLinks: ControlLink[],
  controls: Control[]
): LeafScores {
  // ...
  const netScore = calculateRowNetScore(row, controlLinks, controls)
  // ...
}
```

And update `transformTaxonomyItem` to pass them through:

```typescript
function transformTaxonomyItem(
  item: TaxonomyItem,
  rows: RCTRow[],
  type: 'risk' | 'process',
  viewMode: ViewMode,
  aggregationMode: 'weighted' | 'max',
  weights: TaxonomyWeights,
  level: number,
  controlLinks: ControlLink[],
  controls: Control[]
): SunburstNode {
  // ... pass to calculateLeafScores
}
```

And `buildSunburstTree`:

```typescript
function buildSunburstTree(
  taxonomy: TaxonomyItem[],
  rows: RCTRow[],
  type: 'risk' | 'process',
  viewMode: ViewMode,
  aggregationMode: 'weighted' | 'max',
  weights: TaxonomyWeights,
  controlLinks: ControlLink[],
  controls: Control[]
): SunburstNode {
  // ... pass to transformTaxonomyItem
}
```

Finally, update the useMemo call to pass the unified controlLinks and allControls:

```typescript
const rootNode = buildSunburstTree(
  taxonomy,
  rows,
  taxonomyType,
  viewMode,
  aggregationMode,
  weights,
  controlLinks,  // unified variable
  allControls    // unified variable
)
```

Import the types if needed:
```typescript
import type { ControlLink } from '@/stores/controlsStore'
import type { Control } from '@/types/rct'
```
  </action>
  <verify>
1. `npx tsc --noEmit` - no TypeScript errors
2. Sunburst displays correct net scores when controls exist
3. Net score colors update when controls are modified
  </verify>
  <done>Net score calculation uses unified data sources</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit`
2. App loads without errors: `npm run dev`
3. Demo mode: Sunburst displays data from Zustand stores
4. Authenticated mode:
   - Sunburst displays data from database (not empty)
   - Risk taxonomy sunburst shows correct hierarchy
   - Process taxonomy sunburst shows correct hierarchy
   - Gross/Net/Delta scores display correctly
   - View mode toggle works
   - Hover tooltips show correct values
</verification>

<success_criteria>
- useSunburstData imports and uses `useIsDemoMode()`
- useSunburstData imports and calls database hooks
- Data reading branches on isDemoMode
- Net score calculation uses passed parameters (not store.getState())
- Sunburst displays correctly in authenticated mode
- No empty sunburst when database has data
</success_criteria>

<output>
After completion, create `.planning/phases/26.1-database-integration-gaps/26.1-05-SUMMARY.md`
</output>
