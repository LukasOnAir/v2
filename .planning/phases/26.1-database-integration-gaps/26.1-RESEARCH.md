# Phase 26.1: Database Integration Gaps - Research

**Researched:** 2026-01-27
**Domain:** React/Zustand/React Query data flow, authentication-aware data sourcing
**Confidence:** HIGH

## Summary

Phase 26.1 addresses six specific gaps where components read from Zustand stores instead of database via React Query hooks when authenticated. The RCTTable.tsx component (lines 256-327) demonstrates the correct pattern: check `isDemoMode`, use store data if true, use React Query hooks if false. Several visualization components and the regenerate functionality have not been updated to follow this pattern.

The core issue is straightforward: components need conditional data sourcing based on authentication state. The hooks (useRCTRows, useTaxonomy, useControls, useControlLinks, useCustomColumns) already exist and work correctly. The fix is to apply the same `isDemoMode` pattern that RCTTable already uses to the remaining components.

**Primary recommendation:** Apply the RCTTable.tsx dual-source pattern (lines 256-327) to MatrixGrid.tsx, useSunburstData.ts, and ControlPanel.tsx. For Regenerate RCT, implement an upsert-style bulk operation.

## Standard Stack

The established patterns already exist in this codebase:

### Core Pattern (from RCTTable.tsx)
| Pattern | Location | Purpose |
|---------|----------|---------|
| `useIsDemoMode()` | `src/hooks/useTenantData.ts:106-109` | Auth state check |
| Dual data sources | RCTTable.tsx:256-284 | Conditional hook vs store usage |
| Data denormalization | RCTTable.tsx:286-296 | Transform DB rows to full types |
| Unified update handlers | RCTTable.tsx:302-327 | Route mutations to store or database |

### Existing Database Hooks
| Hook | File | Purpose |
|------|------|---------|
| `useRCTRows` | `src/hooks/useRCTRows.ts` | Fetch/update RCT rows |
| `useTaxonomy` | `src/hooks/useTaxonomy.ts` | Fetch taxonomy trees |
| `useControlLinks` | `src/hooks/useControlLinks.ts` | Fetch control-row links |
| `useControls` | `src/hooks/useControls.ts` | Fetch controls |
| `useCustomColumns` | `src/hooks/useCustomColumns.ts` | Fetch column definitions |

### Missing Operations
| Operation | Needed For | Status |
|-----------|------------|--------|
| `useBulkUpsertRCTRows` | Regenerate RCT | Does not exist - needs implementation |

## Architecture Patterns

### Pattern 1: Conditional Data Sourcing (REFERENCE)
**What:** Check `isDemoMode`, branch data source accordingly
**When to use:** Every component that displays entity data
**Example from RCTTable.tsx (lines 256-284):**
```typescript
// Demo mode check
const isDemoMode = useIsDemoMode()

// Store data (for demo mode)
const { rows: storeRows } = useRCTStore()
const { risks: storeRisks } = useTaxonomyStore()

// Database hooks (for authenticated mode)
const { data: dbRctRows } = useRCTRows()
const { data: dbRisks } = useTaxonomy('risk')
const { data: dbControlLinks } = useControlLinks()

// Use appropriate data sources
const risks = isDemoMode ? storeRisks : (dbRisks || [])
const controlLinks = isDemoMode ? storeControlLinks : (dbControlLinks || [])
```

### Pattern 2: Row Denormalization
**What:** Transform compact DB rows (with foreign keys) to full denormalized rows with hierarchy paths
**When to use:** When RCT rows need display columns (riskL1Name, processL2Name, etc.)
**Example from RCTTable.tsx (lines 195-249):**
```typescript
function denormalizeRCTRow(
  dbRow: RCTRowData,
  risks: TaxonomyItem[],
  processes: TaxonomyItem[]
): RCTRow {
  const riskPath = getHierarchyPath(risks, dbRow.riskId)
  const processPath = getHierarchyPath(processes, dbRow.processId)
  return {
    id: dbRow.id,
    riskId: dbRow.riskId,
    riskL1Id: riskPath.l1Id,
    riskL1Name: riskPath.l1Name,
    // ... all hierarchy columns
    grossProbability: dbRow.grossProbability,
    // ... all scoring columns
  }
}
```

### Pattern 3: Unified Mutation Handler
**What:** Single update function that routes to Zustand store or React Query mutation
**When to use:** Any component with edit functionality
**Example from RCTTable.tsx (lines 302-327):**
```typescript
const updateRow = useCallback((rowId: string, updates: Partial<RCTRow>) => {
  if (isDemoMode) {
    storeUpdateRow(rowId, updates)
  } else {
    updateRCTRowMutation.mutate({ id: rowId, ...updates })
  }
}, [isDemoMode, storeUpdateRow, updateRCTRowMutation])
```

### Anti-Patterns to Avoid
- **Direct store access without auth check:** `const rows = useRCTStore(s => s.rows)` without branching on demo mode
- **Mixing data sources:** Using store for some fields, DB for others in same component
- **Missing hook subscriptions:** Forgetting to call hooks (even if not using result) breaks React Query cache

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Auth state detection | Session checking logic | `useIsDemoMode()` | Consistent, tested |
| Taxonomy hierarchy lookup | Tree traversal | `getHierarchyPath()` in rctGenerator.ts | Handles all 5 levels |
| Net score calculation | Manual aggregation | `calculateNetScoresFromLinks()` in rctStore.ts | Handles embedded + linked controls |
| Control link counts | Filter in render | Pre-compute in useMemo with Map | O(1) vs O(n) lookups |

## Common Pitfalls

### Pitfall 1: Not invalidating queries after mutations
**What goes wrong:** Data appears stale after updates
**Why it happens:** Forgot `queryClient.invalidateQueries()` in mutation's onSuccess
**How to avoid:** Check all existing mutation hooks - they all invalidate correctly. Follow the pattern.
**Warning signs:** Component shows old data, refresh fixes it

### Pitfall 2: Stale closure in callbacks
**What goes wrong:** Callbacks reference outdated state
**Why it happens:** Dependency array missing in useCallback
**How to avoid:** Include all referenced values in deps array, or access store directly with `useStore.getState()`
**Example from RCTTable.tsx (lines 478-491):**
```typescript
// Access rows via store directly to avoid dependency that causes re-renders
const currentRows = useRCTStore.getState().rows
```

### Pitfall 3: Hook called conditionally
**What goes wrong:** React error about hooks order changing
**Why it happens:** `if (isDemoMode) return` before hook calls
**How to avoid:** Call ALL hooks first, THEN branch on isDemoMode for data usage

### Pitfall 4: Missing loading/empty states
**What goes wrong:** Flash of wrong content, or blank screen
**Why it happens:** Didn't check `isLoading` from queries
**How to avoid:** Follow RCTTable pattern (lines 772-815) - show loading spinner, then check for empty data

### Pitfall 5: Control count not reading from controlLinks
**What goes wrong:** Shows 0 controls when controls exist
**Why it happens:** Only checking `row.controls` (embedded), not `controlLinks` table
**How to avoid:** Use linkCountByRow Map pattern from RCTTable.tsx (lines 332-338)
```typescript
const linkCountByRow = useMemo(() => {
  const map = new Map<string, number>()
  for (const link of controlLinks) {
    map.set(link.rowId, (map.get(link.rowId) || 0) + 1)
  }
  return map
}, [controlLinks])
```

## Specific Gap Analysis

### Gap 1: Regenerate RCT doesn't update with new taxonomy
**Root cause:** In RCTTable.tsx (lines 437-466), authenticated mode uses `bulkCreateRCTRowsMutation` which only INSERTs. Existing rows are not updated when taxonomy changes.
**Fix approach:** Need upsert operation that:
1. Finds existing rows by `riskId:processId` composite key
2. Updates existing rows (preserve scores, customValues)
3. Inserts new rows for new taxonomy combinations
4. Optionally deletes orphaned rows (taxonomy items removed)

**Implementation option:** Create `useBulkUpsertRCTRows` hook that:
```typescript
// Pseudocode
const existingRows = await fetchCurrentRows()
const existingMap = new Map(existingRows.map(r => [`${r.riskId}:${r.processId}`, r]))

for (const newRow of generatedRows) {
  const key = `${newRow.riskId}:${newRow.processId}`
  if (existingMap.has(key)) {
    // Already exists - no action needed (preserves data)
    existingMap.delete(key)
  } else {
    // New combination - insert
    rowsToInsert.push(newRow)
  }
}
// Remaining in existingMap are orphaned - optionally delete
```

### Gap 2: Control count incorrect - not reading from controlLinks
**Root cause:** Some component reads `row.controls.length` instead of querying `controlLinks` table
**Analysis:** RCTTable.tsx correctly reads from `controlLinks` (line 697), so this may be in ControlPanel.tsx which still uses store
**Fix approach:** ControlPanel.tsx needs the dual-source pattern for controlLinks

### Gap 3: Stale demo controls showing in authenticated mode
**Root cause:** ControlPanel.tsx (lines 131, 318-322) reads directly from `useControlsStore()` without checking `isDemoMode`
**Fix approach:** Add `useIsDemoMode()` check and branch data source:
```typescript
const isDemoMode = useIsDemoMode()
const storeControlLinks = useControlsStore(state => state.controlLinks)
const { data: dbControlLinks } = useControlLinks()
const controlLinks = isDemoMode ? storeControlLinks : (dbControlLinks || [])
```

### Gap 4: Custom columns don't save (text, number) or display (dropdown)
**Root cause:** RCTTable.tsx custom column handlers (lines 478-491) route to `updateRow` which correctly handles DB vs store. BUT the `customColumns` list comes from `useRCTStore().customColumns`, not `useCustomColumns()` hook.
**Analysis:** The DB hook exists and works. The component needs to:
1. Read `customColumns` from database when authenticated
2. The values save correctly (stored in `rct_rows.custom_values` JSONB)

**Fix approach:** Add to RCTTable.tsx:
```typescript
const { customColumns: storeCustomColumns } = useRCTStore()
const { data: dbCustomColumns } = useCustomColumns()
const customColumns = isDemoMode ? storeCustomColumns : (dbCustomColumns || [])
```

### Gap 5 & 6: Risk Process Matrix and Sunburst show empty
**Root cause:** MatrixGrid.tsx (lines 29-31) and useSunburstData.ts (lines 455-459) read directly from Zustand stores without auth check
**Fix approach:** Apply dual-source pattern to both files:

**MatrixGrid.tsx fix:**
```typescript
const isDemoMode = useIsDemoMode()
const { risks: storeRisks, processes: storeProcesses, riskWeights } = useTaxonomyStore()
const { rows: storeRows } = useRCTStore()
const { data: dbRisks } = useTaxonomy('risk')
const { data: dbProcesses } = useTaxonomy('process')
const { data: dbRows } = useRCTRows()

const risks = isDemoMode ? storeRisks : (dbRisks || [])
const processes = isDemoMode ? storeProcesses : (dbProcesses || [])
const rows = isDemoMode ? storeRows : denormalizedRows
```

**useSunburstData.ts fix:** Same pattern, replacing direct store subscriptions with conditional sourcing

## State of the Art

| Old Approach (Demo-only) | Current Approach (Dual-source) | When Changed | Impact |
|--------------------------|--------------------------------|--------------|--------|
| Direct Zustand reads | isDemoMode check + conditional | Phase 26 | Allows same components for demo + auth |
| Embedded controls in rows | Controls Hub with controlLinks | Phase 13 | Controls reusable across rows |
| Full RCT row in store | Normalized DB + denormalize | Phase 26 | Reduces storage, enables tenant isolation |

## Open Questions

1. **Orphan row cleanup:** When taxonomy items are deleted, should Regenerate RCT delete orphaned rows? Current demo mode preserves all data. Need business decision.
   - What we know: FK constraints prevent orphans in some cases
   - Recommendation: For v1, skip deletion - let rows persist until explicit cleanup

2. **Custom column display order:** Database has `sort_order` field. Is RCTTable using it?
   - What we know: `useCustomColumns()` orders by `sort_order`
   - Recommendation: Verify column rendering respects this order

## Sources

### Primary (HIGH confidence)
- `src/components/rct/RCTTable.tsx` - Reference implementation of dual-source pattern
- `src/hooks/useRCTRows.ts` - Database mutation hooks
- `src/hooks/useTenantData.ts` - `useIsDemoMode()` implementation
- `src/stores/controlsStore.ts` - Store partialize logic showing auth awareness

### Secondary (MEDIUM confidence)
- `src/components/matrix/MatrixGrid.tsx` - Gap 5 source analysis
- `src/components/sunburst/useSunburstData.ts` - Gap 6 source analysis
- `src/components/rct/ControlPanel.tsx` - Gaps 2/3 source analysis

## Metadata

**Confidence breakdown:**
- Gap analysis: HIGH - Traced code paths, identified exact lines
- Fix approaches: HIGH - Following established pattern from same codebase
- Upsert implementation: MEDIUM - Standard pattern but needs implementation

**Research date:** 2026-01-27
**Valid until:** N/A - Internal codebase analysis, no external dependencies
