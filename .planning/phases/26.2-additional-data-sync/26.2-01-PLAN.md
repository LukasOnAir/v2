---
phase: 26.2-additional-data-sync
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/approval/ApprovalQueue.tsx
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Approval queue displays pending changes from database when authenticated"
    - "Approve/reject actions update database when authenticated"
    - "Demo mode continues to use localStorage store"
  artifacts:
    - path: "src/components/approval/ApprovalQueue.tsx"
      provides: "Dual-source approval queue"
      contains: "isDemoMode"
  key_links:
    - from: "src/components/approval/ApprovalQueue.tsx"
      to: "src/hooks/usePendingChanges.ts"
      via: "usePendingChanges import"
      pattern: "usePendingChanges"
---

<objective>
Wire ApprovalQueue component to database using existing hooks

Purpose: ApprovalQueue.tsx currently uses only useApprovalStore (localStorage). The usePendingChanges.ts database hooks already exist with full CRUD operations. This plan wires the component to use database when authenticated while preserving demo mode functionality.

Output: ApprovalQueue with dual-source pattern for pending changes data and mutations.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/26.2-additional-data-sync/26.2-RESEARCH.md

Reference implementations:
@src/hooks/usePendingChanges.ts (existing database hooks - usePendingChanges, useApproveChange, useRejectChange)
@src/stores/approvalStore.ts (existing store for demo mode)
@src/components/approval/ApprovalQueue.tsx (component to update)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dual-source pattern to ApprovalQueue</name>
  <files>src/components/approval/ApprovalQueue.tsx</files>
  <action>
Update ApprovalQueue.tsx to use dual-source pattern for data and mutations.

1. Add imports for database hooks and usePermissions:
   ```typescript
   import { usePermissions } from '@/hooks/usePermissions'
   import {
     usePendingChanges,
     useApproveChange,
     useRejectChange,
   } from '@/hooks/usePendingChanges'
   ```

2. Inside the component, add dual-source data loading:
   ```typescript
   const { isDemoMode } = usePermissions()

   // Store data (demo mode)
   const storePendingChanges = useApprovalStore((state) => state.pendingChanges)
   const storeApprove = useApprovalStore((state) => state.approveChange)
   const storeReject = useApprovalStore((state) => state.rejectChange)

   // Database data (authenticated mode)
   const { data: dbPendingChanges } = usePendingChanges()
   const { mutate: dbApprove } = useApproveChange()
   const { mutate: dbReject } = useRejectChange()

   // Dual-source selection
   const pendingChanges = isDemoMode ? storePendingChanges : (dbPendingChanges || [])
   ```

3. Remove the existing direct store access lines:
   - Remove: `const pendingChanges = useApprovalStore((state) => state.pendingChanges)`
   - Remove: `const approveChange = useApprovalStore((state) => state.approveChange)`
   - Remove: `const rejectChange = useApprovalStore((state) => state.rejectChange)`

4. Create wrapper functions for approve/reject that handle dual-mode:
   ```typescript
   const handleApprove = (id: string) => {
     if (isDemoMode) {
       storeApprove(id)
     } else {
       // Get user email or role for reviewer identification
       const reviewedBy = 'authenticated-user' // Will use actual user from session
       dbApprove({ id, reviewedBy })
     }
   }

   const handleReject = (id: string, reason?: string) => {
     if (isDemoMode) {
       storeReject(id, reason)
     } else {
       const reviewedBy = 'authenticated-user'
       dbReject({ id, reviewedBy, reason })
     }
   }
   ```

5. Update all uses of `approveChange` to use `handleApprove`:
   - In action buttons onClick: `onClick={() => handleApprove(change.id)}`
   - In handleBulkApprove: `selectedPendingIds.forEach((id) => handleApprove(id))`

6. Update all uses of `rejectChange` to use `handleReject`:
   - In handleBulkReject: `selectedPendingIds.forEach((id) => handleReject(id))`
   - In handleRejectWithReason: `handleReject(rejectingId, rejectReason || undefined)`

7. Update column definitions - replace `approveChange` with `handleApprove` in useMemo dependency array.
  </action>
  <verify>
1. `npx tsc --noEmit` - no TypeScript errors
2. `npm run dev` - app loads without errors
3. Manual test in demo mode: approval queue shows store data, approve/reject work
4. Manual test in auth mode (if available): approval queue shows database data
  </verify>
  <done>ApprovalQueue uses database hooks when authenticated, store when in demo mode</done>
</task>

<task type="auto">
  <name>Task 2: Get reviewer identity from auth context</name>
  <files>src/components/approval/ApprovalQueue.tsx</files>
  <action>
Improve the reviewer identification to use actual user information.

1. Add useAuth import:
   ```typescript
   import { useAuth } from '@/hooks/useAuth'
   ```

2. Inside component, get user email:
   ```typescript
   const { user } = useAuth()
   ```

3. Update handleApprove to use real user identity:
   ```typescript
   const handleApprove = (id: string) => {
     if (isDemoMode) {
       storeApprove(id)
     } else {
       const reviewedBy = user?.email || 'unknown'
       dbApprove({ id, reviewedBy })
     }
   }
   ```

4. Update handleReject similarly:
   ```typescript
   const handleReject = (id: string, reason?: string) => {
     if (isDemoMode) {
       storeReject(id, reason)
     } else {
       const reviewedBy = user?.email || 'unknown'
       dbReject({ id, reviewedBy, reason })
     }
   }
   ```
  </action>
  <verify>
1. `npx tsc --noEmit` - no TypeScript errors
2. Approve/reject actions store actual user email as reviewedBy
  </verify>
  <done>Approval queue stores actual user identity as reviewer</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit`
2. App loads without errors: `npm run dev`
3. Demo mode test:
   - Toggle to demo mode (no auth)
   - Approval queue shows localStorage data
   - Approve/reject work and update localStorage
4. Authenticated mode test (if Supabase available):
   - Log in as authenticated user
   - Approval queue shows database data
   - Approve action updates pending_changes table with status='approved'
   - Reject action updates pending_changes table with status='rejected'
</verification>

<success_criteria>
- ApprovalQueue imports usePermissions and database hooks
- Dual-source pattern: isDemoMode ? store : database
- Approve/reject mutations route to store (demo) or database (auth)
- Reviewer identity captured from authenticated user
- No regressions in demo mode functionality
</success_criteria>

<rollback>
If issues arise:
1. Revert ApprovalQueue.tsx to previous version: `git checkout HEAD~1 -- src/components/approval/ApprovalQueue.tsx`
2. The existing store and hooks remain unchanged
</rollback>

<output>
After completion, create `.planning/phases/26.2-additional-data-sync/26.2-01-SUMMARY.md`
</output>
