---
phase: 26.2-additional-data-sync
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/useAuditLogDb.ts
  - src/hooks/useAuditLog.ts
  - src/pages/AuditPage.tsx
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Audit trail displays entries from database audit_log table when authenticated"
    - "Field changes are extracted from old_data/new_data JSONB columns"
    - "Demo mode continues to use localStorage store"
  artifacts:
    - path: "src/hooks/useAuditLogDb.ts"
      provides: "Database query hook for audit_log"
      exports: ["useAuditLogDb"]
    - path: "src/pages/AuditPage.tsx"
      provides: "Dual-source audit page"
      contains: "isDemoMode"
  key_links:
    - from: "src/pages/AuditPage.tsx"
      to: "src/hooks/useAuditLogDb.ts"
      via: "useAuditLogDb import"
      pattern: "useAuditLogDb"
---

<objective>
Create audit log database hook and wire AuditPage to dual-source

Purpose: The audit_log database table is automatically populated by triggers on entity changes. The AuditPage currently reads from useAuditStore (localStorage). When authenticated, it should read from the database table instead, showing the trigger-generated entries.

Output: New useAuditLogDb.ts hook plus updated AuditPage with dual-source pattern.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/26.2-additional-data-sync/26.2-RESEARCH.md

Reference implementations:
@src/lib/supabase/types.ts (AuditLog type definition - lines 182-230)
@src/hooks/useAuditLog.ts (existing store-based hook with filter types)
@src/stores/auditStore.ts (store for demo mode)
@src/pages/AuditPage.tsx (page to update)
@src/types/audit.ts (AuditEntry type)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useAuditLogDb hook</name>
  <files>src/hooks/useAuditLogDb.ts</files>
  <action>
Create a new hook file that queries the audit_log database table.

```typescript
import { useQuery } from '@tanstack/react-query'
import { supabase } from '@/lib/supabase/client'
import type { AuditEntry, FieldChange, EntityType, ChangeType } from '@/types/audit'
import type { AuditLog } from '@/lib/supabase/types'
import type { AuditFilters } from '@/hooks/useAuditLog'

/**
 * Extract field changes from old_data and new_data JSONB columns.
 * Compares top-level fields and returns array of changes.
 */
function extractFieldChanges(
  oldData: unknown,
  newData: unknown
): FieldChange[] {
  const changes: FieldChange[] = []
  const oldObj = (oldData || {}) as Record<string, unknown>
  const newObj = (newData || {}) as Record<string, unknown>

  const allKeys = new Set([...Object.keys(oldObj), ...Object.keys(newObj)])
  for (const key of allKeys) {
    // Skip internal/metadata fields
    if (key === 'tenant_id' || key === 'created_at' || key === 'updated_at') {
      continue
    }

    if (JSON.stringify(oldObj[key]) !== JSON.stringify(newObj[key])) {
      changes.push({
        field: key,
        oldValue: oldObj[key] ?? null,
        newValue: newObj[key] ?? null,
      })
    }
  }
  return changes
}

/**
 * Transform database audit_log row to AuditEntry type.
 */
function toAuditEntry(row: AuditLog): AuditEntry {
  // Map database entity_type to app EntityType
  // Database stores: taxonomy_nodes, controls, rct_rows, control_tests, etc.
  // App expects: risk, process, control, rctRow, controlTest, etc.
  const entityTypeMap: Record<string, EntityType> = {
    taxonomy_nodes: 'risk', // Will need context to distinguish risk/process
    controls: 'control',
    rct_rows: 'rctRow',
    control_tests: 'controlTest',
    remediation_plans: 'remediationPlan',
    // Add more mappings as needed
  }

  const mappedType = entityTypeMap[row.entity_type] || (row.entity_type as EntityType)

  return {
    id: row.id,
    timestamp: row.created_at,
    entityType: mappedType,
    entityId: row.entity_id || '',
    entityName: row.entity_name || undefined,
    changeType: row.change_type as ChangeType,
    fieldChanges: extractFieldChanges(row.old_data, row.new_data),
    user: row.user_email || 'system',
  }
}

/**
 * Query audit_log table with optional filters.
 * Returns entries sorted by timestamp descending (newest first).
 */
export function useAuditLogDb(filters?: AuditFilters) {
  return useQuery({
    queryKey: ['auditLog', filters],
    queryFn: async () => {
      let query = supabase
        .from('audit_log')
        .select('*')
        .order('created_at', { ascending: false })
        .limit(1000) // Reasonable limit for UI performance

      // Apply date range filter
      if (filters?.dateRange.start) {
        query = query.gte('created_at', filters.dateRange.start.toISOString())
      }
      if (filters?.dateRange.end) {
        query = query.lte('created_at', filters.dateRange.end.toISOString())
      }

      // Apply entity type filter (map app types back to DB types)
      if (filters?.entityTypes && filters.entityTypes.length > 0) {
        const dbEntityTypes = filters.entityTypes.map(type => {
          const reverseMap: Record<string, string> = {
            risk: 'taxonomy_nodes',
            process: 'taxonomy_nodes',
            control: 'controls',
            rctRow: 'rct_rows',
            controlTest: 'control_tests',
            remediationPlan: 'remediation_plans',
          }
          return reverseMap[type] || type
        })
        query = query.in('entity_type', dbEntityTypes)
      }

      // Apply change type filter
      if (filters?.changeTypes && filters.changeTypes.length > 0) {
        query = query.in('change_type', filters.changeTypes)
      }

      // Note: searchQuery filter applied client-side after fetch
      // (entity_name may be null, and we want to search summaries too)

      const { data, error } = await query

      if (error) throw error

      let entries = data.map(toAuditEntry)

      // Client-side search filter
      if (filters?.searchQuery?.trim()) {
        const searchLower = filters.searchQuery.toLowerCase()
        entries = entries.filter(
          (e) =>
            e.entityName?.toLowerCase().includes(searchLower) ||
            e.user?.toLowerCase().includes(searchLower)
        )
      }

      return entries
    },
  })
}

/**
 * Get total count of audit entries (for stats display).
 */
export function useAuditLogCount() {
  return useQuery({
    queryKey: ['auditLog', 'count'],
    queryFn: async () => {
      const { count, error } = await supabase
        .from('audit_log')
        .select('*', { count: 'exact', head: true })

      if (error) throw error
      return count || 0
    },
  })
}
```
  </action>
  <verify>TypeScript compiles without errors: `npx tsc --noEmit`</verify>
  <done>useAuditLogDb hook created with filter support and field change extraction</done>
</task>

<task type="auto">
  <name>Task 2: Update AuditPage with dual-source pattern</name>
  <files>src/pages/AuditPage.tsx</files>
  <action>
Update AuditPage to use dual-source pattern for audit entries.

1. Add imports:
   ```typescript
   import { usePermissions } from '@/hooks/usePermissions'
   import { useAuditLogDb, useAuditLogCount } from '@/hooks/useAuditLogDb'
   ```

2. Inside component, add dual-source logic after filters state:
   ```typescript
   const { isDemoMode } = usePermissions()

   // Store data (demo mode)
   const storeAuditLog = useAuditLog(filters)

   // Database data (authenticated mode)
   const { data: dbEntries, isLoading: dbLoading } = useAuditLogDb(filters)
   const { data: dbTotalCount } = useAuditLogCount()

   // Dual-source selection
   const entries = isDemoMode ? storeAuditLog.entries : (dbEntries || [])
   const totalCount = isDemoMode ? storeAuditLog.totalCount : (dbTotalCount || 0)
   const filteredCount = entries.length
   ```

3. Remove or modify the existing `useAuditLog` destructuring:
   - Change from: `const { entries, totalCount, filteredCount } = useAuditLog(filters)`
   - The store-based hook is still called but results are selected based on isDemoMode

4. Add loading state for authenticated mode:
   ```typescript
   // Show loading indicator only in authenticated mode during fetch
   if (!isDemoMode && dbLoading) {
     return (
       <div className="space-y-6">
         <h1 className="text-2xl font-semibold text-text-primary">Audit Trail</h1>
         <div className="flex items-center justify-center p-8">
           <div className="animate-spin rounded-full h-8 w-8 border-2 border-accent-500 border-t-transparent" />
         </div>
       </div>
     )
   }
   ```

5. Update props passed to AuditFilters:
   ```typescript
   <AuditFilters
     filters={filters}
     onChange={setFilters}
     totalCount={totalCount}
     filteredCount={filteredCount}
   />
   ```
  </action>
  <verify>
1. `npx tsc --noEmit` - no TypeScript errors
2. `npm run dev` - app loads without errors
3. Demo mode: audit page shows localStorage entries
4. Auth mode: audit page shows database entries (from triggers)
  </verify>
  <done>AuditPage uses database audit_log when authenticated, store when in demo mode</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit`
2. App loads without errors: `npm run dev`
3. Demo mode test:
   - Audit page shows entries from localStorage store
   - Filters work correctly
4. Authenticated mode test (if Supabase available):
   - Audit page shows entries from audit_log table
   - Entries include field changes extracted from JSONB
   - Date and type filters work
   - Search filter works on entity names
</verification>

<success_criteria>
- useAuditLogDb.ts hook created and exported
- extractFieldChanges correctly transforms JSONB to FieldChange[]
- AuditPage uses dual-source pattern
- Filters work in both demo and authenticated modes
- Loading state shown during database fetch
</success_criteria>

<rollback>
If issues arise:
1. Delete useAuditLogDb.ts
2. Revert AuditPage.tsx: `git checkout HEAD~1 -- src/pages/AuditPage.tsx`
3. Existing store-based functionality preserved
</rollback>

<output>
After completion, create `.planning/phases/26.2-additional-data-sync/26.2-02-SUMMARY.md`
</output>
