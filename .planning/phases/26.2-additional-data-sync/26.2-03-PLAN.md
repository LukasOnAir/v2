---
phase: 26.2-additional-data-sync
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/useAnalyticsDataDb.ts
  - src/hooks/useAnalyticsData.ts
  - src/components/analytics/ControlTestTrendChart.tsx
  - src/components/analytics/AggregationReport.tsx
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Control test trends chart displays data from database when authenticated"
    - "Risk aggregation report derives scores from database when authenticated"
    - "Demo mode continues to use localStorage stores"
  artifacts:
    - path: "src/hooks/useAnalyticsDataDb.ts"
      provides: "Database-backed analytics hooks"
      exports: ["useControlTestTrendsDb", "useAggregationByCategoryDb"]
    - path: "src/components/analytics/ControlTestTrendChart.tsx"
      provides: "Dual-source control test chart"
      contains: "isDemoMode"
    - path: "src/components/analytics/AggregationReport.tsx"
      provides: "Dual-source aggregation report"
      contains: "isDemoMode"
  key_links:
    - from: "src/components/analytics/ControlTestTrendChart.tsx"
      to: "src/hooks/useAnalyticsDataDb.ts"
      via: "useControlTestTrendsDb import"
      pattern: "useControlTestTrendsDb"
---

<objective>
Create database-backed analytics hooks and wire analytics components

Purpose: The analytics hooks currently read from localStorage stores (useRCTStore, useAuditStore). When authenticated, analytics should derive data from the database tables (control_tests, rct_rows joined with taxonomy_nodes).

Output: New useAnalyticsDataDb.ts with database query hooks, plus updated analytics components with dual-source pattern.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/26.2-additional-data-sync/26.2-RESEARCH.md

Reference implementations:
@src/hooks/useAnalyticsData.ts (existing store-based hooks)
@src/lib/supabase/types.ts (ControlTestRow, RctRow types)
@src/components/analytics/ControlTestTrendChart.tsx
@src/components/analytics/AggregationReport.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useAnalyticsDataDb hooks</name>
  <files>src/hooks/useAnalyticsDataDb.ts</files>
  <action>
Create database-backed analytics hooks that mirror the store-based hooks.

```typescript
import { useQuery } from '@tanstack/react-query'
import { supabase } from '@/lib/supabase/client'
import { startOfDay } from 'date-fns'
import type { TrendDataPoint, CategoryAggregation } from '@/hooks/useAnalyticsData'
import type { ControlTestRow, RctRow, TaxonomyNode } from '@/lib/supabase/types'

/**
 * Query control_tests table for effectiveness trends.
 * Returns data points sorted by test_date ascending.
 */
export function useControlTestTrendsDb(
  controlId?: string,
  dateRange?: { start: Date; end: Date }
) {
  return useQuery({
    queryKey: ['analytics', 'controlTestTrends', controlId, dateRange?.start?.toISOString(), dateRange?.end?.toISOString()],
    queryFn: async (): Promise<TrendDataPoint[]> => {
      let query = supabase
        .from('control_tests')
        .select('test_date, result, effectiveness')
        .order('test_date', { ascending: true })

      // Filter by controlId if provided
      if (controlId) {
        query = query.eq('control_id', controlId)
      }

      // Filter by date range if provided
      if (dateRange?.start) {
        query = query.gte('test_date', dateRange.start.toISOString().split('T')[0])
      }
      if (dateRange?.end) {
        query = query.lte('test_date', dateRange.end.toISOString().split('T')[0])
      }

      const { data, error } = await query

      if (error) throw error

      // Map to TrendDataPoint
      return (data || []).map((test) => {
        let value: number
        if (test.effectiveness !== null && test.effectiveness !== undefined) {
          value = test.effectiveness
        } else {
          switch (test.result) {
            case 'pass':
              value = 5
              break
            case 'partial':
              value = 3
              break
            case 'fail':
            case 'not-tested':
            default:
              value = 1
              break
          }
        }

        const testDate = new Date(test.test_date)
        return {
          date: test.test_date,
          timestamp: testDate.getTime(),
          value,
          label: test.result,
        }
      })
    },
  })
}

/**
 * Aggregation by L1 category from database.
 * Joins rct_rows with taxonomy_nodes to get L1 grouping.
 */
export function useAggregationByCategoryDb(groupBy: 'riskL1' | 'processL1' = 'riskL1') {
  return useQuery({
    queryKey: ['analytics', 'aggregation', groupBy],
    queryFn: async (): Promise<CategoryAggregation[]> => {
      // Fetch RCT rows with taxonomy joins
      const { data: rctRows, error: rctError } = await supabase
        .from('rct_rows')
        .select(`
          id,
          gross_probability,
          gross_impact,
          gross_score,
          risk_id,
          process_id
        `)

      if (rctError) throw rctError

      // Fetch taxonomy nodes to get L1 info
      const { data: taxonomyNodes, error: taxError } = await supabase
        .from('taxonomy_nodes')
        .select('id, name, path, type')

      if (taxError) throw taxError

      // Build lookup maps
      const nodeMap = new Map<string, TaxonomyNode>()
      for (const node of taxonomyNodes || []) {
        nodeMap.set(node.id, node)
      }

      // Fetch control links to count controls per row
      const { data: controlLinks, error: linkError } = await supabase
        .from('control_links')
        .select('rct_row_id')

      if (linkError) throw linkError

      // Count controls per row
      const controlCountByRow = new Map<string, number>()
      for (const link of controlLinks || []) {
        const count = controlCountByRow.get(link.rct_row_id) || 0
        controlCountByRow.set(link.rct_row_id, count + 1)
      }

      // Helper to get L1 node from path
      const getL1Node = (nodeId: string): { id: string; name: string } | null => {
        const node = nodeMap.get(nodeId)
        if (!node || !node.path || node.path.length === 0) return null

        // path[0] is the L1 node ID
        const l1Id = node.path[0]
        const l1Node = nodeMap.get(l1Id)
        if (!l1Node) return null

        return { id: l1Node.id, name: l1Node.name }
      }

      // Group rows by L1 category
      const groups = new Map<string, {
        categoryId: string
        categoryName: string
        grossScores: number[]
        netScores: number[]
        rowCount: number
        controlCount: number
      }>()

      for (const row of rctRows || []) {
        const nodeId = groupBy === 'riskL1' ? row.risk_id : row.process_id
        const l1 = getL1Node(nodeId)
        if (!l1) continue

        let group = groups.get(l1.id)
        if (!group) {
          group = {
            categoryId: l1.id,
            categoryName: l1.name,
            grossScores: [],
            netScores: [],
            rowCount: 0,
            controlCount: 0,
          }
          groups.set(l1.id, group)
        }

        group.rowCount++
        group.controlCount += controlCountByRow.get(row.id) || 0

        if (row.gross_score !== null) {
          group.grossScores.push(row.gross_score)
        }
        // Note: net_score would need to be calculated from controls
        // For now, we'll use gross_score as placeholder
      }

      // Convert to CategoryAggregation array
      const result: CategoryAggregation[] = []
      for (const group of groups.values()) {
        const avgGrossScore =
          group.grossScores.length > 0
            ? group.grossScores.reduce((a, b) => a + b, 0) / group.grossScores.length
            : null

        result.push({
          categoryId: group.categoryId,
          categoryName: group.categoryName,
          avgGrossScore,
          avgNetScore: null, // Would need separate calculation
          rowCount: group.rowCount,
          controlCount: group.controlCount,
        })
      }

      return result
    },
  })
}
```
  </action>
  <verify>TypeScript compiles without errors: `npx tsc --noEmit`</verify>
  <done>useAnalyticsDataDb.ts created with database-backed analytics hooks</done>
</task>

<task type="auto">
  <name>Task 2: Update ControlTestTrendChart with dual-source</name>
  <files>src/components/analytics/ControlTestTrendChart.tsx</files>
  <action>
Update ControlTestTrendChart to use dual-source pattern.

1. Add imports:
   ```typescript
   import { usePermissions } from '@/hooks/usePermissions'
   import { useControlTestTrendsDb } from '@/hooks/useAnalyticsDataDb'
   ```

2. Inside component, add dual-source logic:
   ```typescript
   const { isDemoMode } = usePermissions()

   // Store data (demo mode)
   const storeData = useControlTestTrends(controlId, dateRange)

   // Database data (authenticated mode)
   const { data: dbData, isLoading } = useControlTestTrendsDb(controlId, dateRange)

   // Dual-source selection
   const data = isDemoMode ? storeData : (dbData || [])
   ```

3. Remove or modify the existing data line:
   - Change from: `const data = useControlTestTrends(controlId, dateRange)`

4. Update empty state to handle loading:
   ```typescript
   // Handle loading state (authenticated mode only)
   if (!isDemoMode && isLoading) {
     return (
       <div
         className="flex items-center justify-center text-text-muted"
         style={{ height }}
       >
         <div className="animate-spin rounded-full h-6 w-6 border-2 border-accent-500 border-t-transparent" />
       </div>
     )
   }

   // Handle empty state
   if (data.length === 0) {
     return (
       <div
         className="flex items-center justify-center text-text-muted"
         style={{ height }}
       >
         No test data available
       </div>
     )
   }
   ```
  </action>
  <verify>
1. `npx tsc --noEmit` - no TypeScript errors
2. Chart renders in both demo and authenticated modes
  </verify>
  <done>ControlTestTrendChart uses database data when authenticated</done>
</task>

<task type="auto">
  <name>Task 3: Update AggregationReport with dual-source</name>
  <files>src/components/analytics/AggregationReport.tsx</files>
  <action>
Update AggregationReport to use dual-source pattern.

1. Add imports:
   ```typescript
   import { usePermissions } from '@/hooks/usePermissions'
   import { useAggregationByCategoryDb } from '@/hooks/useAnalyticsDataDb'
   ```

2. Inside component, add dual-source logic after groupBy state:
   ```typescript
   const { isDemoMode } = usePermissions()

   // Store data (demo mode)
   const storeAggregations = useAggregationByCategory(groupBy)

   // Database data (authenticated mode)
   const { data: dbAggregations, isLoading } = useAggregationByCategoryDb(groupBy)

   // Dual-source selection
   const aggregations = isDemoMode ? storeAggregations : (dbAggregations || [])
   ```

3. Remove or modify the existing aggregations line:
   - Change from: `const aggregations = useAggregationByCategory(groupBy)`

4. Add loading state before empty state check:
   ```typescript
   // Handle loading state (authenticated mode only)
   if (!isDemoMode && isLoading) {
     return (
       <div className="space-y-4">
         {/* Header with toggle buttons - keep visible during load */}
         <div className="flex items-center justify-between">
           <h3 className="text-lg font-medium text-text-primary">
             Risk Aggregation by Category
           </h3>
           {/* ... toggle buttons ... */}
         </div>
         <div className="flex items-center justify-center p-8">
           <div className="animate-spin rounded-full h-6 w-6 border-2 border-accent-500 border-t-transparent" />
         </div>
       </div>
     )
   }
   ```
  </action>
  <verify>
1. `npx tsc --noEmit` - no TypeScript errors
2. Aggregation report renders in both demo and authenticated modes
  </verify>
  <done>AggregationReport uses database data when authenticated</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit`
2. App loads without errors: `npm run dev`
3. Demo mode test:
   - Analytics dashboard shows data from localStorage stores
   - Charts and tables render correctly
4. Authenticated mode test (if Supabase available):
   - Control test trends show data from control_tests table
   - Aggregation report shows data from rct_rows + taxonomy_nodes
   - Loading states display during fetch
</verification>

<success_criteria>
- useAnalyticsDataDb.ts created with database-backed hooks
- ControlTestTrendChart uses dual-source pattern
- AggregationReport uses dual-source pattern
- Loading states shown in authenticated mode
- Demo mode continues to work with localStorage data
</success_criteria>

<rollback>
If issues arise:
1. Delete useAnalyticsDataDb.ts
2. Revert ControlTestTrendChart.tsx: `git checkout HEAD~1 -- src/components/analytics/ControlTestTrendChart.tsx`
3. Revert AggregationReport.tsx: `git checkout HEAD~1 -- src/components/analytics/AggregationReport.tsx`
</rollback>

<output>
After completion, create `.planning/phases/26.2-additional-data-sync/26.2-03-SUMMARY.md`
</output>
