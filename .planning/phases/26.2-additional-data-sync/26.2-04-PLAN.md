---
phase: 26.2-additional-data-sync
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/00028_knowledge_base.sql
  - src/lib/supabase/types.ts
  - src/hooks/useKnowledgeBase.ts
  - src/pages/KnowledgeBasePage.tsx
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Knowledge base entries persist to database when authenticated"
    - "Multiple tenant users see the same knowledge base articles"
    - "Demo mode continues to use localStorage store"
  artifacts:
    - path: "supabase/migrations/00028_knowledge_base.sql"
      provides: "knowledge_base table with RLS"
      contains: "CREATE TABLE public.knowledge_base"
    - path: "src/hooks/useKnowledgeBase.ts"
      provides: "Database CRUD hooks for knowledge base"
      exports: ["useKnowledgeBase", "useCreateKnowledgeBaseEntry", "useUpdateKnowledgeBaseEntry", "useDeleteKnowledgeBaseEntry"]
    - path: "src/pages/KnowledgeBasePage.tsx"
      provides: "Dual-source knowledge base page"
      contains: "isDemoMode"
  key_links:
    - from: "src/pages/KnowledgeBasePage.tsx"
      to: "src/hooks/useKnowledgeBase.ts"
      via: "useKnowledgeBase import"
      pattern: "useKnowledgeBase"
---

<objective>
Create knowledge base database table, hooks, and wire KnowledgeBasePage

Purpose: The knowledge base currently uses only useCollaborationStore (localStorage). There is no database table for it. This plan creates the database table with RLS, React Query hooks, and wires the page to use database when authenticated.

Output: Migration file, type definitions, database hooks, and updated KnowledgeBasePage.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/26.2-additional-data-sync/26.2-RESEARCH.md

Reference implementations:
@src/stores/collaborationStore.ts (existing store with KnowledgeBaseEntry)
@src/types/collaboration.ts (KnowledgeBaseEntry, KnowledgeBaseCategory types)
@src/pages/KnowledgeBasePage.tsx (page to update)
@supabase/migrations/00022_comments.sql (example RLS pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create knowledge_base migration</name>
  <files>supabase/migrations/00028_knowledge_base.sql</files>
  <action>
Create the database migration for the knowledge_base table.

```sql
-- Migration: 00028_knowledge_base.sql
-- Creates knowledge_base table for shared knowledge articles

-- Create table
CREATE TABLE public.knowledge_base (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES public.tenants(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  content TEXT NOT NULL,
  category TEXT NOT NULL CHECK (category IN ('testing-procedure', 'best-practice', 'policy', 'template', 'reference')),
  tags TEXT[] DEFAULT '{}',
  author TEXT NOT NULL,
  related_control_types TEXT[] DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ
);

-- Indexes for common queries
CREATE INDEX idx_knowledge_base_tenant ON public.knowledge_base(tenant_id);
CREATE INDEX idx_knowledge_base_category ON public.knowledge_base(tenant_id, category);
CREATE INDEX idx_knowledge_base_created ON public.knowledge_base(tenant_id, created_at DESC);

-- Enable Row Level Security
ALTER TABLE public.knowledge_base ENABLE ROW LEVEL SECURITY;

-- RLS Policy: Tenant isolation for all operations
CREATE POLICY "knowledge_base_tenant_isolation" ON public.knowledge_base
  FOR ALL TO authenticated
  USING (tenant_id = (SELECT public.tenant_id()))
  WITH CHECK (tenant_id = (SELECT public.tenant_id()));

-- Grant permissions
GRANT SELECT, INSERT, UPDATE, DELETE ON public.knowledge_base TO authenticated;

-- Comment
COMMENT ON TABLE public.knowledge_base IS 'Shared knowledge base articles within a tenant';
```
  </action>
  <verify>SQL syntax is valid (no TypeScript check possible, will verify on migration push)</verify>
  <done>Migration file created for knowledge_base table with RLS</done>
</task>

<task type="auto">
  <name>Task 2: Add TypeScript types for knowledge_base</name>
  <files>src/lib/supabase/types.ts</files>
  <action>
Add type definitions for the knowledge_base table to types.ts.

1. Add KnowledgeBaseCategory type near the top with other type definitions (around line 86):
   ```typescript
   export type KnowledgeBaseCategory = 'testing-procedure' | 'best-practice' | 'policy' | 'template' | 'reference'
   ```

2. Add the knowledge_base table definition in the Database interface Tables section (after custom_columns, around line 994):
   ```typescript
      knowledge_base: {
        Row: {
          id: string
          tenant_id: string
          title: string
          content: string
          category: KnowledgeBaseCategory
          tags: string[]
          author: string
          related_control_types: string[]
          created_at: string
          updated_at: string | null
        }
        Insert: {
          id?: string
          tenant_id?: string
          title: string
          content: string
          category: KnowledgeBaseCategory
          tags?: string[]
          author: string
          related_control_types?: string[]
          created_at?: string
          updated_at?: string | null
        }
        Update: {
          id?: string
          tenant_id?: string
          title?: string
          content?: string
          category?: KnowledgeBaseCategory
          tags?: string[]
          author?: string
          related_control_types?: string[]
          created_at?: string
          updated_at?: string | null
        }
        Relationships: [
          {
            foreignKeyName: 'knowledge_base_tenant_id_fkey'
            columns: ['tenant_id']
            referencedRelation: 'tenants'
            referencedColumns: ['id']
          }
        ]
      }
   ```

3. Add convenience type aliases at the bottom (after CustomColumnUpdate):
   ```typescript
   export type KnowledgeBaseRow = Tables<'knowledge_base'>
   export type KnowledgeBaseInsert = Insertable<'knowledge_base'>
   export type KnowledgeBaseUpdate = Updatable<'knowledge_base'>
   ```
  </action>
  <verify>TypeScript compiles without errors: `npx tsc --noEmit`</verify>
  <done>TypeScript types added for knowledge_base table</done>
</task>

<task type="auto">
  <name>Task 3: Create useKnowledgeBase database hooks</name>
  <files>src/hooks/useKnowledgeBase.ts</files>
  <action>
Create React Query hooks for knowledge base CRUD operations.

```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import { supabase } from '@/lib/supabase/client'
import { toast } from 'sonner'
import type { KnowledgeBaseEntry, KnowledgeBaseCategory } from '@/types/collaboration'
import type { KnowledgeBaseRow } from '@/lib/supabase/types'

/**
 * Transform database row to app type.
 */
function toKnowledgeBaseEntry(row: KnowledgeBaseRow): KnowledgeBaseEntry {
  return {
    id: row.id,
    title: row.title,
    content: row.content,
    category: row.category as KnowledgeBaseCategory,
    tags: row.tags || [],
    author: row.author,
    relatedControlTypes: row.related_control_types || [],
    createdAt: row.created_at,
    updatedAt: row.updated_at || undefined,
  }
}

/**
 * Query all knowledge base entries for the tenant.
 */
export function useKnowledgeBase() {
  return useQuery({
    queryKey: ['knowledgeBase'],
    queryFn: async () => {
      const { data, error } = await supabase
        .from('knowledge_base')
        .select('*')
        .order('created_at', { ascending: false })

      if (error) throw error
      return data.map(toKnowledgeBaseEntry)
    },
  })
}

/**
 * Query knowledge base entries by category.
 */
export function useKnowledgeBaseByCategory(category: KnowledgeBaseCategory) {
  return useQuery({
    queryKey: ['knowledgeBase', 'category', category],
    queryFn: async () => {
      const { data, error } = await supabase
        .from('knowledge_base')
        .select('*')
        .eq('category', category)
        .order('created_at', { ascending: false })

      if (error) throw error
      return data.map(toKnowledgeBaseEntry)
    },
  })
}

/**
 * Create a new knowledge base entry.
 */
export function useCreateKnowledgeBaseEntry() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (entry: Omit<KnowledgeBaseEntry, 'id' | 'createdAt'>) => {
      const { data, error } = await supabase
        .from('knowledge_base')
        .insert({
          title: entry.title,
          content: entry.content,
          category: entry.category,
          tags: entry.tags,
          author: entry.author,
          related_control_types: entry.relatedControlTypes || [],
        })
        .select()
        .single()

      if (error) throw error
      return toKnowledgeBaseEntry(data)
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['knowledgeBase'] })
      toast.success('Article created')
    },
    onError: (error) => {
      toast.error(`Failed to create article: ${error.message}`)
    },
  })
}

/**
 * Update an existing knowledge base entry.
 */
export function useUpdateKnowledgeBaseEntry() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async ({
      id,
      updates,
    }: {
      id: string
      updates: Partial<Omit<KnowledgeBaseEntry, 'id' | 'createdAt'>>
    }) => {
      const dbUpdates: Record<string, unknown> = {
        updated_at: new Date().toISOString(),
      }
      if (updates.title !== undefined) dbUpdates.title = updates.title
      if (updates.content !== undefined) dbUpdates.content = updates.content
      if (updates.category !== undefined) dbUpdates.category = updates.category
      if (updates.tags !== undefined) dbUpdates.tags = updates.tags
      if (updates.author !== undefined) dbUpdates.author = updates.author
      if (updates.relatedControlTypes !== undefined) {
        dbUpdates.related_control_types = updates.relatedControlTypes
      }

      const { data, error } = await supabase
        .from('knowledge_base')
        .update(dbUpdates)
        .eq('id', id)
        .select()
        .single()

      if (error) throw error
      return toKnowledgeBaseEntry(data)
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['knowledgeBase'] })
      toast.success('Article updated')
    },
    onError: (error) => {
      toast.error(`Failed to update article: ${error.message}`)
    },
  })
}

/**
 * Delete a knowledge base entry.
 */
export function useDeleteKnowledgeBaseEntry() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (id: string) => {
      const { error } = await supabase
        .from('knowledge_base')
        .delete()
        .eq('id', id)

      if (error) throw error
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['knowledgeBase'] })
      toast.success('Article deleted')
    },
    onError: (error) => {
      toast.error(`Failed to delete article: ${error.message}`)
    },
  })
}
```
  </action>
  <verify>TypeScript compiles without errors: `npx tsc --noEmit`</verify>
  <done>useKnowledgeBase.ts created with CRUD hooks</done>
</task>

<task type="auto">
  <name>Task 4: Update KnowledgeBasePage with dual-source</name>
  <files>src/pages/KnowledgeBasePage.tsx</files>
  <action>
Update KnowledgeBasePage to use dual-source pattern for data and mutations.

1. Add imports:
   ```typescript
   import { usePermissions } from '@/hooks/usePermissions'
   import {
     useKnowledgeBase,
     useCreateKnowledgeBaseEntry,
     useUpdateKnowledgeBaseEntry,
     useDeleteKnowledgeBaseEntry,
   } from '@/hooks/useKnowledgeBase'
   ```

2. Inside component, add dual-source logic after destructuring from useCollaborationStore:
   ```typescript
   const { isDemoMode } = usePermissions()

   // Store data and mutations (demo mode)
   const {
     knowledgeBaseEntries: storeEntries,
     addKnowledgeBaseEntry: storeAdd,
     updateKnowledgeBaseEntry: storeUpdate,
     deleteKnowledgeBaseEntry: storeDelete,
   } = useCollaborationStore()

   // Database data and mutations (authenticated mode)
   const { data: dbEntries, isLoading } = useKnowledgeBase()
   const { mutate: dbAdd } = useCreateKnowledgeBaseEntry()
   const { mutate: dbUpdate } = useUpdateKnowledgeBaseEntry()
   const { mutate: dbDelete } = useDeleteKnowledgeBaseEntry()

   // Dual-source selection
   const knowledgeBaseEntries = isDemoMode ? storeEntries : (dbEntries || [])
   ```

3. Update the handler functions to use dual-source mutations:
   ```typescript
   const handleCreateEntry = (data: Omit<KnowledgeBaseEntry, 'id' | 'createdAt'>) => {
     if (isDemoMode) {
       storeAdd(data)
     } else {
       dbAdd(data)
     }
     setShowForm(false)
   }

   const handleUpdateEntry = (data: Omit<KnowledgeBaseEntry, 'id' | 'createdAt'>) => {
     if (!editingEntry) return
     if (isDemoMode) {
       storeUpdate(editingEntry.id, data)
     } else {
       dbUpdate({ id: editingEntry.id, updates: data })
     }
     setShowForm(false)
     setEditingEntry(null)
   }

   const handleDeleteEntry = (entryId: string) => {
     if (isDemoMode) {
       storeDelete(entryId)
     } else {
       dbDelete(entryId)
     }
     setSelectedEntry(null)
   }
   ```

4. Add loading state before the main return:
   ```typescript
   // Handle loading state (authenticated mode only)
   if (!isDemoMode && isLoading) {
     return (
       <div className="space-y-6">
         <div className="flex items-center justify-between">
           <h1 className="text-2xl font-semibold text-text-primary">Knowledge Base</h1>
         </div>
         <div className="flex items-center justify-center p-8">
           <div className="animate-spin rounded-full h-8 w-8 border-2 border-accent-500 border-t-transparent" />
         </div>
       </div>
     )
   }
   ```
  </action>
  <verify>
1. `npx tsc --noEmit` - no TypeScript errors
2. `npm run dev` - app loads without errors
3. Demo mode: knowledge base shows localStorage data, CRUD works
4. Auth mode: knowledge base shows database data (after migration push)
  </verify>
  <done>KnowledgeBasePage uses database when authenticated, store when in demo mode</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit`
2. App loads without errors: `npm run dev`
3. Demo mode test:
   - Knowledge base page shows localStorage entries
   - Create, edit, delete work and update localStorage
4. Authenticated mode test (after migration push):
   - Knowledge base shows database entries
   - Create adds to database
   - Edit updates database
   - Delete removes from database
   - Multiple tenant users see same articles
</verification>

<success_criteria>
- Migration file created with proper RLS policies
- TypeScript types added for knowledge_base table
- useKnowledgeBase.ts hooks created with CRUD operations
- KnowledgeBasePage uses dual-source pattern
- Toast feedback on mutations
- Loading state in authenticated mode
</success_criteria>

<rollback>
If issues arise:
1. Delete migration file (if not yet pushed)
2. Delete useKnowledgeBase.ts
3. Revert types.ts changes
4. Revert KnowledgeBasePage.tsx: `git checkout HEAD~1 -- src/pages/KnowledgeBasePage.tsx`

Note: Migration requires `npx supabase db push` to apply. If migration fails, check SQL syntax and RLS policy references.
</rollback>

<output>
After completion, create `.planning/phases/26.2-additional-data-sync/26.2-04-SUMMARY.md`
</output>
