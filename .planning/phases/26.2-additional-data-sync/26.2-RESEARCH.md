# Phase 26.2: Additional Data Sync - Research

**Researched:** 2026-01-27
**Domain:** Database integration for approval queue, audit trail, analytics, and knowledge base
**Confidence:** HIGH

## Summary

This phase addresses four remaining features that need database synchronization:

1. **Approval Queue**: Component uses `useApprovalStore` (localStorage) despite `usePendingChanges` hook existing for database access. Database schema (`pending_changes` table) already exists with triggers.

2. **Audit Trail**: Database `audit_log` table exists with triggers auto-recording changes. The `useAuditLog` hook reads from `useAuditStore` (localStorage) instead of database. For authenticated users, entries should come from database triggers.

3. **Analytics Dashboard**: All data hooks (`useAnalyticsData.ts`) read from localStorage stores (`useRCTStore`, `useAuditStore`). Analytics must derive from database when authenticated.

4. **Knowledge Base**: No database table exists. Uses `useCollaborationStore` (localStorage) only. Needs new `knowledge_base` table and React Query hooks.

**Primary recommendation:** Apply the established dual-source pattern (`isDemoMode ? storeData : dbData`) to each component, leveraging existing infrastructure. Create new database table and hooks only for knowledge base.

## Standard Stack

The established libraries/tools for this domain:

### Core (Already in Use)
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| @tanstack/react-query | 5.x | Server state management | Already configured in QueryProvider |
| @supabase/supabase-js | 2.x | Database client | Existing Supabase setup |
| zustand | 4.x | Client state (demo mode) | Existing pattern for dual-source |

### Supporting (Already in Use)
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| sonner | 1.x | Toast notifications | Mutation feedback |
| date-fns | 3.x | Date formatting | Audit timestamps |

**No new dependencies required.** All infrastructure exists from Phase 26.

## Architecture Patterns

### Recommended Component Structure

Each feature follows the same integration pattern:

```
Feature/
├── Component.tsx         # UI component with dual-source pattern
├── useFeature.ts        # Store hook (existing, for demo mode)
└── useFeatureDb.ts      # React Query hook (new or wire existing)
```

### Pattern 1: Dual-Source Data Loading

**What:** Component reads from store in demo mode, database when authenticated
**When to use:** Every component that displays persistent data

```typescript
// Existing pattern from Phase 26
function Component() {
  const { isDemoMode } = usePermissions()

  // Store data (demo mode)
  const storeData = useStore(state => state.data)

  // Database data (authenticated mode)
  const { data: dbData } = useDatabaseQuery()

  // Dual-source selection
  const data = isDemoMode ? storeData : (dbData || [])

  return <div>{/* render data */}</div>
}
```

### Pattern 2: Dual-Source Mutations

**What:** Mutations target store in demo mode, database when authenticated
**When to use:** Every component that modifies data

```typescript
function Component() {
  const { isDemoMode } = usePermissions()

  // Store mutations
  const storeAction = useStore(state => state.action)

  // Database mutations
  const { mutate: dbAction } = useDatabaseMutation()

  const handleAction = (data) => {
    if (isDemoMode) {
      storeAction(data)
    } else {
      dbAction(data)
    }
  }
}
```

### Pattern 3: Database Row Transformation

**What:** Transform snake_case database rows to camelCase TypeScript types
**When to use:** Every React Query hook

```typescript
// Source: Existing pattern in useControls.ts
function toAppType(row: DbRow): AppType {
  return {
    id: row.id,
    fieldName: row.field_name,
    createdAt: row.created_at,
  }
}

export function useQuery() {
  return useQuery({
    queryKey: ['entity'],
    queryFn: async () => {
      const { data, error } = await supabase.from('table').select('*')
      if (error) throw error
      return data.map(toAppType)
    },
  })
}
```

### Anti-Patterns to Avoid

- **Mixing data sources:** Never combine store and database data in the same render
- **Direct store access when authenticated:** Always use database hooks when `!isDemoMode`
- **Creating new stores:** Use existing stores for demo mode, don't create new ones

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Pending changes CRUD | Custom fetch logic | `usePendingChanges` hook (exists!) | Already implemented with full CRUD |
| Audit log queries | Manual queries | Database triggers | Audit entries auto-generated on entity changes |
| Control test trends | Manual aggregation | SQL queries with proper indexes | Database does aggregation efficiently |
| Demo mode detection | Custom auth checks | `usePermissions().isDemoMode` | Centralized, consistent |
| Query invalidation | Manual cache clearing | React Query's `invalidateQueries` | Automatic on mutation success |

**Key insight:** `usePendingChanges.ts` already has database hooks but `ApprovalQueue.tsx` isn't using them.

## Common Pitfalls

### Pitfall 1: ApprovalQueue Uses Store Despite Hook Existing

**What goes wrong:** ApprovalQueue.tsx imports `useApprovalStore` directly instead of using `usePendingChanges` database hook
**Why it happens:** Original implementation predates Phase 26 database integration
**How to avoid:** Wire ApprovalQueue to use `usePendingChanges` hooks when authenticated
**Warning signs:** Component imports from `@/stores/approvalStore` without dual-source pattern

### Pitfall 2: Audit Store vs Database Triggers

**What goes wrong:** App writes to `useAuditStore` (localStorage) while database triggers write to `audit_log` table separately
**Why it happens:** Dual logging system - localStorage for demo, database triggers for production
**How to avoid:**
- Demo mode: Keep using `useAuditStore` (localStorage)
- Authenticated: READ from `audit_log` database table (triggers handle writes)
**Warning signs:** Authenticated users see different audit history than what's in database

### Pitfall 3: Analytics Recalculation

**What goes wrong:** Analytics uses stores which aren't updated in authenticated mode
**Why it happens:** `useAnalyticsData` hooks read from stores, not database
**How to avoid:** Create database-backed analytics hooks with SQL aggregations
**Warning signs:** Analytics show stale data or zeros when authenticated

### Pitfall 4: Knowledge Base Missing Table

**What goes wrong:** Knowledge base can't sync because no database table exists
**Why it happens:** Feature was built before database layer
**How to avoid:** Create migration first, then hooks
**Warning signs:** Knowledge base data not visible to other tenant users

### Pitfall 5: Approval Settings Singleton Pattern

**What goes wrong:** Multiple rows created for same tenant's approval settings
**Why it happens:** Not using upsert pattern
**How to avoid:** Use `onConflict` for approval_settings (UNIQUE constraint on tenant_id)
**Warning signs:** Settings not persisting correctly

## Implementation Details

### 1. ApprovalQueue Integration

**Current state:**
```typescript
// ApprovalQueue.tsx
const pendingChanges = useApprovalStore((state) => state.pendingChanges)
const approveChange = useApprovalStore((state) => state.approveChange)
```

**Target state:**
```typescript
// ApprovalQueue.tsx with dual-source
const { isDemoMode } = usePermissions()
const storePendingChanges = useApprovalStore((state) => state.pendingChanges)
const { data: dbPendingChanges } = usePendingChanges()
const pendingChanges = isDemoMode ? storePendingChanges : (dbPendingChanges || [])

// For mutations
const storeApprove = useApprovalStore((state) => state.approveChange)
const { mutate: dbApprove } = useApproveChange()
```

### 2. Audit Trail Integration

**Current state:**
```typescript
// useAuditLog.ts
const entries = useAuditStore((state) => state.entries)
```

**Target state:**
```typescript
// New: useAuditLogDb.ts
export function useAuditLogDb(filters: AuditFilters) {
  return useQuery({
    queryKey: ['auditLog', filters],
    queryFn: async () => {
      const { data, error } = await supabase
        .from('audit_log')
        .select('*')
        .order('created_at', { ascending: false })
      if (error) throw error
      return data.map(toAuditEntry)
    },
  })
}

// AuditPage.tsx with dual-source
const { isDemoMode } = usePermissions()
const { entries: storeEntries } = useAuditLog(filters)
const { data: dbEntries } = useAuditLogDb(filters)
const entries = isDemoMode ? storeEntries : (dbEntries || [])
```

**Database schema mapping:**
| audit_log (DB) | AuditEntry (TS) | Notes |
|----------------|-----------------|-------|
| id | id | UUID |
| entity_type | entityType | TEXT |
| entity_id | entityId | UUID |
| entity_name | entityName | TEXT |
| change_type | changeType | create/update/delete |
| old_data | fieldChanges[].oldValue | JSONB - extract fields |
| new_data | fieldChanges[].newValue | JSONB - extract fields |
| user_email | user | TEXT - email as identifier |
| created_at | timestamp | TIMESTAMPTZ |

### 3. Analytics Integration

**Current state:**
```typescript
// useAnalyticsData.ts
const controlTests = useRCTStore((state) => state.controlTests)
const entries = useAuditStore((state) => state.entries)
const rows = useRCTStore((state) => state.rows)
```

**Target state:** Create database-backed aggregation hooks:
```typescript
// New: useAnalyticsDataDb.ts
export function useControlTestTrendsDb(dateRange?: DateRange) {
  return useQuery({
    queryKey: ['analytics', 'controlTestTrends', dateRange],
    queryFn: async () => {
      const { data } = await supabase
        .from('control_tests')
        .select('test_date, result, effectiveness')
        .order('test_date')
      return data.map(toTrendPoint)
    },
  })
}

export function useAggregationByCategoryDb(groupBy: 'riskL1' | 'processL1') {
  return useQuery({
    queryKey: ['analytics', 'aggregation', groupBy],
    queryFn: async () => {
      // Join rct_rows with taxonomy_nodes for L1 grouping
      const { data } = await supabase
        .from('rct_rows')
        .select(`
          id,
          gross_score,
          risk:taxonomy_nodes!rct_rows_risk_id_fkey(id, name, path),
          process:taxonomy_nodes!rct_rows_process_id_fkey(id, name, path)
        `)
      // Aggregate by L1 in JavaScript (path[0] is L1)
      return aggregateByL1(data, groupBy)
    },
  })
}
```

### 4. Knowledge Base Integration

**New migration required:** `00028_knowledge_base.sql`

```sql
CREATE TABLE public.knowledge_base (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES public.tenants(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  content TEXT NOT NULL,
  category TEXT NOT NULL CHECK (category IN ('testing-procedure', 'best-practice', 'policy', 'template', 'reference')),
  tags TEXT[] DEFAULT '{}',
  author TEXT NOT NULL,
  related_control_types TEXT[] DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ
);

-- Indexes
CREATE INDEX idx_knowledge_base_tenant ON public.knowledge_base(tenant_id);
CREATE INDEX idx_knowledge_base_category ON public.knowledge_base(tenant_id, category);

-- Enable RLS
ALTER TABLE public.knowledge_base ENABLE ROW LEVEL SECURITY;

-- Tenant isolation policy
CREATE POLICY "knowledge_base_tenant_isolation" ON public.knowledge_base
  FOR ALL TO authenticated
  USING (tenant_id = (SELECT public.tenant_id()))
  WITH CHECK (tenant_id = (SELECT public.tenant_id()));

-- Grant permissions
GRANT SELECT, INSERT, UPDATE, DELETE ON public.knowledge_base TO authenticated;
```

**New hook:** `useKnowledgeBase.ts`
```typescript
export function useKnowledgeBase() {
  return useQuery({
    queryKey: ['knowledgeBase'],
    queryFn: async () => {
      const { data, error } = await supabase
        .from('knowledge_base')
        .select('*')
        .order('created_at', { ascending: false })
      if (error) throw error
      return data.map(toKnowledgeBaseEntry)
    },
  })
}
```

## Existing Infrastructure to Leverage

### Already Implemented
| Component | Status | Location |
|-----------|--------|----------|
| `pending_changes` table | EXISTS | `00023_pending_changes.sql` |
| `approval_settings` table | EXISTS | `00024_approval_settings.sql` |
| `audit_log` table | EXISTS | `00004_audit_log.sql` |
| Audit triggers | EXISTS | `00004_audit_log.sql` |
| `usePendingChanges` hook | EXISTS | `src/hooks/usePendingChanges.ts` |
| Dual-source pattern | EXISTS | Multiple components |
| `usePermissions().isDemoMode` | EXISTS | `src/hooks/usePermissions.ts` |

### Needs Creation
| Component | Status | Notes |
|-----------|--------|-------|
| `knowledge_base` table | MISSING | New migration needed |
| `useAuditLogDb` hook | MISSING | Query audit_log table |
| `useApprovalSettings` hook | MISSING | Query/upsert approval_settings |
| `useKnowledgeBase` hook | MISSING | CRUD for knowledge_base |
| `useAnalyticsDataDb` hooks | MISSING | Database-backed analytics |

## Code Examples

### Dual-Source ApprovalQueue (Target Implementation)

```typescript
// Source: Pattern from existing components (RCTTable.tsx, ControlsPage.tsx)
import { usePermissions } from '@/hooks/usePermissions'
import { useApprovalStore } from '@/stores/approvalStore'
import {
  usePendingChanges,
  useApproveChange,
  useRejectChange
} from '@/hooks/usePendingChanges'

export function ApprovalQueue({ readOnly = false }: ApprovalQueueProps) {
  const { isDemoMode } = usePermissions()

  // Dual-source data
  const storePendingChanges = useApprovalStore((state) => state.pendingChanges)
  const storeApprove = useApprovalStore((state) => state.approveChange)
  const storeReject = useApprovalStore((state) => state.rejectChange)

  const { data: dbPendingChanges } = usePendingChanges()
  const { mutate: dbApprove } = useApproveChange()
  const { mutate: dbReject } = useRejectChange()

  // Select appropriate source
  const pendingChanges = isDemoMode ? storePendingChanges : (dbPendingChanges || [])

  // Handler with dual-mode support
  const handleApprove = (id: string) => {
    if (isDemoMode) {
      storeApprove(id)
    } else {
      const role = useUIStore.getState().selectedRole
      dbApprove({ id, reviewedBy: role || 'unknown' })
    }
  }

  // ... rest of component
}
```

### Audit Log Database Hook

```typescript
// Source: Pattern from existing hooks (useControls.ts)
import { useQuery } from '@tanstack/react-query'
import { supabase } from '@/lib/supabase/client'
import type { AuditEntry, FieldChange } from '@/types/audit'
import type { AuditLog } from '@/lib/supabase/types'

function extractFieldChanges(oldData: unknown, newData: unknown): FieldChange[] {
  const changes: FieldChange[] = []
  const oldObj = (oldData || {}) as Record<string, unknown>
  const newObj = (newData || {}) as Record<string, unknown>

  const allKeys = new Set([...Object.keys(oldObj), ...Object.keys(newObj)])
  for (const key of allKeys) {
    if (JSON.stringify(oldObj[key]) !== JSON.stringify(newObj[key])) {
      changes.push({
        field: key,
        oldValue: oldObj[key] ?? null,
        newValue: newObj[key] ?? null,
      })
    }
  }
  return changes
}

function toAuditEntry(row: AuditLog): AuditEntry {
  return {
    id: row.id,
    timestamp: row.created_at,
    entityType: row.entity_type as AuditEntry['entityType'],
    entityId: row.entity_id || '',
    entityName: row.entity_name || undefined,
    changeType: row.change_type as AuditEntry['changeType'],
    fieldChanges: extractFieldChanges(row.old_data, row.new_data),
    user: row.user_email || 'system',
  }
}

export function useAuditLogDb() {
  return useQuery({
    queryKey: ['auditLog'],
    queryFn: async () => {
      const { data, error } = await supabase
        .from('audit_log')
        .select('*')
        .order('created_at', { ascending: false })
        .limit(1000) // Reasonable limit for UI

      if (error) throw error
      return data.map(toAuditEntry)
    },
  })
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| All localStorage | Dual-source pattern | Phase 26 | Already implemented for core entities |
| Manual audit | Database triggers | Phase 26.01 | Audit auto-recorded on entity changes |
| Single user | Multi-tenant RLS | Phase 21 | All queries auto-scoped to tenant |

**Deprecated/outdated:**
- Direct store access when authenticated - use dual-source pattern instead
- Manual audit entry creation for DB changes - triggers handle this

## Open Questions

1. **Audit entry format mismatch**
   - What we know: Database stores `old_data`/`new_data` JSONB, app expects `fieldChanges[]`
   - What's unclear: Best transformation strategy for complex nested objects
   - Recommendation: Extract top-level field changes only, store full objects as-is

2. **Analytics aggregation performance**
   - What we know: Need to join rct_rows with taxonomy_nodes for L1 grouping
   - What's unclear: Volume of data in production tenants
   - Recommendation: Start with client-side aggregation, add SQL views if performance issues arise

## Sources

### Primary (HIGH confidence)
- Codebase analysis: `src/hooks/usePendingChanges.ts` - existing database hook
- Codebase analysis: `src/stores/approvalStore.ts` - existing store implementation
- Codebase analysis: `supabase/migrations/00004_audit_log.sql` - audit schema
- Codebase analysis: `supabase/migrations/00023_pending_changes.sql` - pending changes schema
- Codebase analysis: `supabase/migrations/00024_approval_settings.sql` - approval settings schema

### Secondary (MEDIUM confidence)
- Pattern analysis: Dual-source pattern from RCTTable.tsx, ControlsPage.tsx, TaxonomyPage.tsx
- Pattern analysis: React Query hooks from useControls.ts, useComments.ts

## Metadata

**Confidence breakdown:**
- Approval Queue integration: HIGH - usePendingChanges hook already exists
- Audit Trail integration: HIGH - Database table exists with triggers
- Analytics integration: MEDIUM - Requires new aggregation hooks
- Knowledge Base integration: HIGH - Standard table + hook pattern

**Research date:** 2026-01-27
**Valid until:** 2026-02-27 (stable patterns, internal codebase)
