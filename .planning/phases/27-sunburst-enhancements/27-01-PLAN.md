---
phase: 27-sunburst-enhancements
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/sunburst/useSunburstData.ts
  - src/components/sunburst/SunburstChart.tsx
autonomous: true

must_haves:
  truths:
    - "Sunburst expands to fill available radius when L4-L5 are unchecked"
    - "No empty wedge gaps appear when L1 nodes have no data and hideNoData is enabled"
    - "Toggling levels immediately updates the chart without page refresh"
  artifacts:
    - path: "src/components/sunburst/useSunburstData.ts"
      provides: "Pre-filtered hierarchy excluding empty L1 nodes"
      contains: "filterEmptyL1Nodes"
    - path: "src/components/sunburst/SunburstChart.tsx"
      provides: "Dynamic radius calculation based on visible depth"
      contains: "maxVisibleDepth"
  key_links:
    - from: "useSunburstData.ts"
      to: "SunburstChart.tsx"
      via: "hierarchyData with filtered L1 nodes"
      pattern: "filterEmptyL1Nodes|hasDescendantWithData"
    - from: "SunburstChart.tsx"
      to: "visibleLevels state"
      via: "maxVisibleDepth calculation"
      pattern: "maxVisibleDepth.*visibleLevels"
---

<objective>
Implement dynamic sunburst sizing and L1 gap closure

Purpose: When users uncheck levels (e.g., show only L1-L3), the sunburst should expand to use the full radius instead of leaving empty space. When hideNoData is enabled, L1 nodes with no data should be filtered out BEFORE partition layout to close gaps.

Output: Sunburst that dynamically resizes based on visible levels and closes gaps for hidden empty L1 nodes.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/27-sunburst-enhancements/27-RESEARCH.md
@src/components/sunburst/SunburstChart.tsx
@src/components/sunburst/useSunburstData.ts
@src/stores/sunburstStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Filter empty L1 nodes in useSunburstData</name>
  <files>src/components/sunburst/useSunburstData.ts</files>
  <action>
Add pre-partition filtering for L1 nodes with no data when hideNoData is enabled.

1. Add helper function `hasDescendantWithData(node: SunburstNode): boolean`:
   - Returns true if node.value is not null
   - OR if any child recursively has data
   - Use for determining if L1 should be included

2. Add function `filterEmptyL1Nodes(root: SunburstNode, hideNoData: boolean): SunburstNode`:
   - If hideNoData is false, return root unchanged
   - Otherwise, filter root.children to only include L1 nodes that have descendant data
   - Return new root with filtered children

3. In `useSunburstData`, call `filterEmptyL1Nodes` on the rootNode BEFORE passing to `hierarchy()`:
   ```typescript
   const filteredRoot = filterEmptyL1Nodes(rootNode, hideNoData)
   const root = hierarchy(filteredRoot).count()
   ```

4. Pass `hideNoData` into the useMemo dependencies.

This ensures partition layout only sees L1 nodes with data, closing gaps at L1 level.
  </action>
  <verify>
- Build passes: `npm run build`
- When hideNoData is checked, inspect the hierarchy in React DevTools to confirm empty L1 nodes are not in the tree
- Visually confirm gaps close at L1 level in the sunburst
  </verify>
  <done>Empty L1 nodes are excluded from partition calculation when hideNoData is enabled, gaps close instead of leaving wedge holes</done>
</task>

<task type="auto">
  <name>Task 2: Dynamic radius based on visible levels</name>
  <files>src/components/sunburst/SunburstChart.tsx</files>
  <action>
Modify partition layout to use dynamic radius based on max visible depth.

1. Add `maxVisibleDepth` calculation using useMemo:
   ```typescript
   const maxVisibleDepth = useMemo(() => {
     const levels = ['l1', 'l2', 'l3', 'l4', 'l5'] as const
     let max = 0
     for (let i = 0; i < levels.length; i++) {
       if (visibleLevels[levels[i]]) max = i + 1
     }
     return Math.max(max, 1) // At least 1 level
   }, [visibleLevels])
   ```

2. Calculate dynamic ring width in visibleNodes useMemo:
   - Instead of using fixed radius for all 5 levels, calculate ring width based on maxVisibleDepth
   - `const ringWidth = (radius - innerRadius) / maxVisibleDepth`

3. Update arc y0/y1 scaling in visibleNodes to use maxVisibleDepth:
   - When computing y0/y1 for zoomed arcs, scale relative to visible depth count
   - Depth 1 node should occupy innerRadius to (innerRadius + ringWidth)
   - Depth 2 node should occupy (innerRadius + ringWidth) to (innerRadius + 2*ringWidth)
   - etc.

4. Add maxVisibleDepth to partitionedRoot useMemo dependencies.

5. Test with various level combinations:
   - L1 only: single ring fills available space
   - L1-L2: two rings fill available space
   - L1-L3: three rings fill available space
   - L1-L5: current behavior (5 rings)
  </action>
  <verify>
- Build passes: `npm run build`
- Toggle off L4 and L5 in UI, confirm sunburst expands (no empty space at edges)
- Toggle off L2-L5, confirm L1 ring expands to fill available radius
- Toggle all levels back on, confirm normal 5-ring layout
  </verify>
  <done>Sunburst dynamically resizes when fewer levels are selected, using full available radius without empty outer space</done>
</task>

</tasks>

<verification>
1. `npm run build` passes without errors
2. Visual verification:
   - Uncheck L4 and L5 levels - sunburst should expand L1-L3 to fill space
   - Check hideNoData - empty L1 wedges should disappear and gaps close
   - All level/hide combinations work correctly
3. No console errors or warnings
</verification>

<success_criteria>
- Sunburst uses full radius when fewer levels are visible (no empty space for hidden levels)
- Empty L1 nodes close gaps when hideNoData is enabled
- Existing zoom and interaction behavior still works
- Level toggles immediately update the visualization
</success_criteria>

<output>
After completion, create `.planning/phases/27-sunburst-enhancements/27-01-SUMMARY.md`
</output>
