---
phase: 28-matrix-invertible-display
plan: 03
type: execute
wave: 2
depends_on: ["28-01"]
files_modified:
  - src/components/matrix/MatrixGrid.tsx
autonomous: true

must_haves:
  truths:
    - "When isInverted=true, risks display as rows and processes as columns"
    - "When isInverted=false, processes display as rows and risks as columns (current behavior)"
    - "Risk labels format according to riskLabelMode setting"
    - "Process labels format according to processLabelMode setting"
    - "Corner cell text updates to reflect current orientation"
  artifacts:
    - path: "src/components/matrix/MatrixGrid.tsx"
      provides: "Invertible matrix rendering with configurable labels"
      contains: "isInverted"
  key_links:
    - from: "src/components/matrix/MatrixGrid.tsx"
      to: "src/stores/matrixStore.ts"
      via: "useMatrixStore hook"
      pattern: "useMatrixStore.*isInverted.*riskLabelMode.*processLabelMode"
---

<objective>
Apply matrix inversion logic and label mode formatting to MatrixGrid rendering.

Purpose: Make the matrix visually respond to user's display configuration choices.
Output: MatrixGrid that swaps rows/columns when inverted and formats labels according to selected modes.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-matrix-invertible-display/28-01-SUMMARY.md
@src/components/matrix/MatrixGrid.tsx
@src/stores/matrixStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add label formatting helper function</name>
  <files>src/components/matrix/MatrixGrid.tsx</files>
  <action>
1. Import LabelMode type:
   ```typescript
   import { useMatrixStore, type LabelMode } from '@/stores/matrixStore'
   ```

2. Add a helper function near the top of the file (after the existing helpers like findTaxonomyById):
   ```typescript
   /**
    * Format a label based on the selected label mode
    * @param positionalId - The hierarchical ID (e.g., "1.2.3")
    * @param name - The item name
    * @param mode - The label display mode
    */
   function formatLabel(positionalId: string, name: string, mode: LabelMode): string {
     switch (mode) {
       case 'id':
         return positionalId
       case 'name':
         return name
       case 'both':
       default:
         return `${positionalId}: ${name}`
     }
   }
   ```

This helper will be used for both row and column headers.
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>
formatLabel helper function defined and ready for use in rendering
  </done>
</task>

<task type="auto">
  <name>Task 2: Apply inversion and label mode logic to grid rendering</name>
  <files>src/components/matrix/MatrixGrid.tsx</files>
  <action>
1. Destructure the new state from useMatrixStore (update the existing destructure):
   ```typescript
   const { zoomLevel, isInverted, riskLabelMode, processLabelMode } = useMatrixStore()
   ```

2. Create derived variables for rows and columns based on inversion state.
   Add this AFTER the existing useMemo for processPositionalIds:
   ```typescript
   // Determine row/column assignment based on inversion
   const columnItems = isInverted ? processLeaves : riskLeaves
   const rowItems = isInverted ? riskLeaves : processLeaves
   const columnPositionalIds = isInverted ? processPositionalIds : riskPositionalIds
   const rowPositionalIds = isInverted ? riskPositionalIds : processPositionalIds
   const columnLabelMode = isInverted ? processLabelMode : riskLabelMode
   const rowLabelMode = isInverted ? riskLabelMode : processLabelMode
   const columnType = isInverted ? 'process' : 'risk'
   const rowType = isInverted ? 'risk' : 'process'
   ```

3. Update the corner cell text to reflect current orientation:
   ```tsx
   <div ...>
     {isInverted ? 'Process / Risk' : 'Risk / Process'}
   </div>
   ```

4. Update the grid template columns to use columnItems:
   ```tsx
   style={{
     gridTemplateColumns: `${headerWidth}px repeat(${columnItems.length}, ${cellSize}px)`,
     width: 'fit-content',
   }}
   ```

5. Update the column headers loop to use columnItems and formatLabel:
   ```tsx
   {columnItems.map((item) => {
     const positionalId = columnPositionalIds.get(item.id) || ''
     const label = formatLabel(positionalId, item.name, columnLabelMode)
     return (
       <div
         key={item.id}
         className="sticky top-0 z-20 bg-surface-elevated border-b border-r border-surface-border flex items-center justify-center p-1 text-xs font-medium text-text-primary"
         style={{
           width: `${cellSize}px`,
           height: `${cellSize}px`,
           minWidth: `${cellSize}px`,
         }}
         title={`${positionalId}: ${item.name}${item.description ? ` - ${item.description}` : ''}`}
       >
         <span className="truncate writing-vertical" style={{
           writingMode: 'vertical-lr',
           textOrientation: 'mixed',
           transform: 'rotate(180deg)',
           maxHeight: `${cellSize - 8}px`,
         }}>
           {label}
         </span>
       </div>
     )
   })}
   ```

6. Update the data rows loop to use rowItems and formatLabel:
   ```tsx
   {rowItems.map((rowItem) => {
     const rowPositionalId = rowPositionalIds.get(rowItem.id) || ''
     const rowLabel = formatLabel(rowPositionalId, rowItem.name, rowLabelMode)
     return (
       <>
         {/* Row header */}
         <div
           key={`header-${rowItem.id}`}
           className="sticky left-0 z-10 bg-surface-elevated border-b border-r border-surface-border flex items-center px-3 text-sm font-medium text-text-primary"
           style={{
             width: `${headerWidth}px`,
             height: `${cellSize}px`,
             minWidth: `${headerWidth}px`,
           }}
           title={`${rowPositionalId}: ${rowItem.name}${rowItem.description ? ` - ${rowItem.description}` : ''}`}
         >
           <span className="truncate">
             {rowLabel}
           </span>
         </div>

         {/* Data cells */}
         {columnItems.map((colItem) => {
           // Determine risk/process IDs based on inversion
           const riskId = isInverted ? rowItem.id : colItem.id
           const processId = isInverted ? colItem.id : rowItem.id
           const key = `${riskId}-${processId}`
           const score = scoreMap.get(key) ?? null

           return (
             <div
               key={key}
               className="border-b border-r border-surface-border"
             >
               <MatrixCell
                 riskId={riskId}
                 processId={processId}
                 score={score}
               />
             </div>
           )
         })}
       </>
     )
   })}
   ```

7. Update the empty state message to be more generic or handle both orientations:
   Keep the existing logic but ensure it checks both riskLeaves and processLeaves (not the derived columnItems/rowItems).
  </action>
  <verify>
1. `npx tsc --noEmit` - no TypeScript errors
2. Manual test: Toggle inversion - rows and columns should swap
3. Manual test: Change label modes - labels should update format
4. Manual test: Cell clicks should still open correct expanded view (riskId/processId mapping correct)
  </verify>
  <done>
MatrixGrid renders with correct orientation based on isInverted and formats labels according to riskLabelMode/processLabelMode
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors
2. Default state (isInverted=false): processes as rows, risks as columns (same as before)
3. Inverted state (isInverted=true): risks as rows, processes as columns
4. Label modes work independently for risks and processes
5. Corner cell text matches current orientation
6. Cell click still maps correctly to riskId/processId for expanded view
7. Score map lookup still works after inversion (key is always risk-process)
</verification>

<success_criteria>
- formatLabel helper handles all three label modes
- Grid swaps rows/columns when isInverted changes
- Labels format according to respective label mode settings
- Corner cell text updates to reflect orientation
- Cell interactions (click, expanded view) work correctly in both orientations
- Existing functionality preserved (zoom, scoring, colors)
</success_criteria>

<output>
After completion, create `.planning/phases/28-matrix-invertible-display/28-03-SUMMARY.md`
</output>
