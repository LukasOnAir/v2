---
phase: 31-controls-hub-ui-fix
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/rct/ControlPanel.tsx
  - src/components/remediation/RemediationTable.tsx
  - src/components/remediation/RemediationSummary.tsx
  - src/components/remediation/OverdueWidget.tsx
  - src/components/remediation/UpcomingWidget.tsx
  - src/components/rct/RemediationSection.tsx
  - src/components/rct/RemediationForm.tsx
autonomous: true

must_haves:
  truths:
    - "Controls linked to RCT rows display in ControlPanel when authenticated"
    - "Remediation plans display in RemediationTable when authenticated"
    - "Remediation summary shows correct counts from database"
    - "Overdue/upcoming widgets show database remediation plans"
    - "RemediationSection in ControlPanel shows linked remediation plans"
    - "Creating a remediation plan persists to database"
  artifacts:
    - path: "src/components/rct/ControlPanel.tsx"
      provides: "Verified dual-source controls with debug logging"
      contains: "useControls"
    - path: "src/components/remediation/RemediationTable.tsx"
      provides: "Dual-source remediation table"
      contains: "useIsDemoMode"
    - path: "src/components/remediation/RemediationSummary.tsx"
      provides: "Dual-source summary stats"
      contains: "useRemediationPlans"
    - path: "src/components/remediation/OverdueWidget.tsx"
      provides: "Dual-source overdue widget"
      contains: "useRemediationPlans"
    - path: "src/components/remediation/UpcomingWidget.tsx"
      provides: "Dual-source upcoming widget"
      contains: "useRemediationPlans"
    - path: "src/components/rct/RemediationSection.tsx"
      provides: "Dual-source remediation section"
      contains: "useRemediationForControl"
    - path: "src/components/rct/RemediationForm.tsx"
      provides: "Dual-source remediation creation"
      contains: "useCreateRemediationPlan"
  key_links:
    - from: "src/components/rct/ControlPanel.tsx"
      to: "useControls"
      via: "React Query hook"
      pattern: "useControls\\(\\)"
    - from: "src/components/rct/ControlPanel.tsx"
      to: "useControlLinks"
      via: "React Query hook"
      pattern: "useControlLinks\\(\\)"
    - from: "src/components/remediation/RemediationTable.tsx"
      to: "useRemediationPlans"
      via: "React Query hook"
      pattern: "useRemediationPlans\\(\\)"
    - from: "src/components/rct/RemediationForm.tsx"
      to: "useCreateRemediationPlan"
      via: "mutation hook"
      pattern: "useCreateRemediationPlan\\(\\)"
---

<objective>
Verify and fix controls display in ControlPanel, then wire all remediation components to use database data when authenticated.

Purpose: Fix bug where controls and remediation plans don't display in UI for authenticated users despite data existing in database. ControlPanel has dual-source code but is unverified. Remediation components only read from Zustand store which is empty for authenticated users per decision [26-07].

Output: Verified controls display in ControlPanel, all remediation components use dual-source pattern (demo: store, auth: hooks) for reading and mutating data.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/31-controls-hub-ui-fix/31-RESEARCH.md
@src/hooks/useRemediationPlans.ts
@src/hooks/useRCTRows.ts
@src/hooks/useControls.ts
@src/hooks/useControlLinks.ts
@src/components/rct/ControlPanel.tsx (reference implementation of dual-source pattern lines 135-156)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Verify and debug ControlPanel controls display</name>
  <files>src/components/rct/ControlPanel.tsx</files>
  <action>
Verify that ControlPanel correctly displays controls from the database when authenticated. The dual-source pattern is already implemented (lines 135-156), but research notes it's unverified with potential issues: query timing, data shape mismatch, ID format mismatch.

1. Add temporary debug logging after the dual-source selection (around line 156):
```typescript
// DEBUG: Verify controls data flow - remove after confirming fix
useEffect(() => {
  if (!isDemoMode && row) {
    console.log('[ControlPanel Debug]', {
      isDemoMode,
      rowId: row.id,
      dbControlsCount: dbControls?.length ?? 'undefined',
      dbControlLinksCount: dbControlLinks?.length ?? 'undefined',
      storeControlsCount: storeControls.length,
      storeControlLinksCount: storeControlLinks.length,
      // Check link-to-row matching
      linksForThisRow: controlLinks.filter(l => l.rowId === row.id).length,
      sampleLinkRowIds: controlLinks.slice(0, 3).map(l => l.rowId),
    })
  }
}, [isDemoMode, row, dbControls, dbControlLinks, storeControls, storeControlLinks, controlLinks])
```

2. Open browser DevTools console and test:
   - Log in as authenticated user
   - Navigate to RCT page
   - Click Controls button on a row that has controls in database
   - Check console for debug output

3. Based on debug output, identify the issue:

   **If dbControlsCount is 0 or undefined:**
   - Check RLS policies allow read access
   - Verify tenant_id is set correctly in session
   - Check useControls hook is enabled (session exists)

   **If dbControlLinksCount is 0 but controls exist:**
   - Check control_links table has data for this tenant
   - Verify RLS policy on control_links table

   **If linksForThisRow is 0 but dbControlLinksCount > 0:**
   - ID format mismatch: Compare row.id format with sampleLinkRowIds
   - Seed script may generate IDs differently than runtime
   - Fix: Either update seed script or adjust filtering logic

4. Fix the identified issue. Common fixes:

   **ID Format Mismatch (most likely based on research):**
   The seed script constructs row IDs as `{riskId}-{processId}`. Verify this matches how RCT rows are stored.

   If IDs don't match, the issue is in how control_links.rct_row_id was seeded. Options:
   a) Re-seed with correct IDs (preferred if seed script is wrong)
   b) Adjust controlLinks filter to handle both formats (if both are valid)

5. After confirming controls display correctly, you may remove the debug logging OR leave it commented out for future debugging:
```typescript
// DEBUG: Uncomment to verify controls data flow
// useEffect(() => { ... }, [...])
```

Note: This task focuses on VERIFICATION and DEBUGGING. The dual-source code structure is already correct - we need to identify why data isn't flowing through.
  </action>
  <verify>
1. TypeScript compiles: `npx tsc --noEmit`
2. Log in as authenticated user with seeded demo tenant data
3. Navigate to RCT page, click Controls button on a row with linked controls
4. Controls from database appear in the ControlPanel (not "No controls added yet")
5. Console shows debug output with non-zero dbControlsCount and linksForThisRow
  </verify>
  <done>Controls linked to RCT rows display in the ControlPanel side panel for authenticated users</done>
</task>

<task type="auto">
  <name>Task 2: Wire RemediationTable with dual-source pattern</name>
  <files>src/components/remediation/RemediationTable.tsx</files>
  <action>
Add dual-source pattern to RemediationTable:

1. Add imports at top:
```typescript
import { useIsDemoMode } from '@/hooks/useTenantData'
import { useRemediationPlans, useUpdateRemediationStatus, useUpdateRemediationPlan, useDeleteRemediationPlan } from '@/hooks/useRemediationPlans'
import { useRCTRows } from '@/hooks/useRCTRows'
```

2. Inside component, add demo mode check and dual-source data:
```typescript
const isDemoMode = useIsDemoMode()

// Store data (for demo mode)
const storeRemediationPlans = useRCTStore((state) => state.remediationPlans)
const storeRows = useRCTStore((state) => state.rows)
const storeUpdateStatus = useRCTStore((state) => state.updateRemediationStatus)
const storeUpdatePlan = useRCTStore((state) => state.updateRemediationPlan)
const storeToggleAction = useRCTStore((state) => state.toggleActionItem)
const storeAddAction = useRCTStore((state) => state.addActionItem)
const storeRemoveAction = useRCTStore((state) => state.removeActionItem)
const storeDeletePlan = useRCTStore((state) => state.deleteRemediationPlan)

// Database hooks (for authenticated mode)
const { data: dbRemediationPlans } = useRemediationPlans()
const { data: dbRows } = useRCTRows()
const updateStatusMutation = useUpdateRemediationStatus()
const updatePlanMutation = useUpdateRemediationPlan()
const deletePlanMutation = useDeleteRemediationPlan()

// Dual-source selection
const remediationPlans = isDemoMode ? storeRemediationPlans : (dbRemediationPlans || [])
const rows = isDemoMode ? storeRows : (dbRows?.map(r => ({ id: r.id, riskName: 'Unknown' })) || [])
```

Note: For rows, we only need the id for lookup. The riskName can be derived from taxonomy if needed later.

3. Create wrapper handlers for mutations:
```typescript
const handleStatusChange = (id: string, status: RemediationStatus) => {
  if (isDemoMode) {
    storeUpdateStatus(id, status)
  } else {
    updateStatusMutation.mutate({ id, status })
  }
}

const handlePlanUpdate = (id: string, updates: Partial<RemediationPlan>) => {
  if (isDemoMode) {
    storeUpdatePlan(id, updates)
  } else {
    updatePlanMutation.mutate({ id, ...updates })
  }
}

const handleDeletePlan = (id: string) => {
  if (isDemoMode) {
    storeDeletePlan(id)
  } else {
    deletePlanMutation.mutate(id)
  }
}

const handleToggleAction = (planId: string, actionId: string) => {
  if (isDemoMode) {
    storeToggleAction(planId, actionId)
  } else {
    // For action items, update the whole actionItems array
    const plan = remediationPlans.find(p => p.id === planId)
    if (plan) {
      const updatedItems = plan.actionItems.map(item =>
        item.id === actionId ? { ...item, completed: !item.completed } : item
      )
      updatePlanMutation.mutate({ id: planId, actionItems: updatedItems })
    }
  }
}

const handleAddAction = (planId: string, description: string) => {
  if (isDemoMode) {
    storeAddAction(planId, description)
  } else {
    const plan = remediationPlans.find(p => p.id === planId)
    if (plan) {
      const newItem = { id: `ai-${Date.now()}`, description, completed: false }
      updatePlanMutation.mutate({ id: planId, actionItems: [...plan.actionItems, newItem] })
    }
  }
}

const handleRemoveAction = (planId: string, actionId: string) => {
  if (isDemoMode) {
    storeRemoveAction(planId, actionId)
  } else {
    const plan = remediationPlans.find(p => p.id === planId)
    if (plan) {
      const updatedItems = plan.actionItems.filter(item => item.id !== actionId)
      updatePlanMutation.mutate({ id: planId, actionItems: updatedItems })
    }
  }
}
```

4. Update all references to use the wrapper handlers instead of direct store calls.

5. Update the `data` memo to use the dual-source `rows`:
```typescript
const data = useMemo(() => {
  return remediationPlans.map((plan) => {
    // For DB mode, try to find row by matching risk_id or process_id if available
    const row = rows.find((r) => r.id === plan.rowId)
    return {
      ...plan,
      riskName: row?.riskName || 'Unknown Risk',
    }
  })
}, [remediationPlans, rows])
```

Note: The riskName enrichment will show "Unknown Risk" for now in auth mode since RCTRowData doesn't include riskName. This is acceptable - the core functionality (displaying plans) works.
  </action>
  <verify>TypeScript compiles without errors: `npx tsc --noEmit`</verify>
  <done>RemediationTable reads from database when authenticated, mutations persist to database, demo mode unchanged</done>
</task>

<task type="auto">
  <name>Task 3: Wire RemediationSummary, OverdueWidget, UpcomingWidget</name>
  <files>
    src/components/remediation/RemediationSummary.tsx
    src/components/remediation/OverdueWidget.tsx
    src/components/remediation/UpcomingWidget.tsx
  </files>
  <action>
Apply dual-source pattern to all three summary/widget components:

**RemediationSummary.tsx:**

1. Add imports:
```typescript
import { useIsDemoMode } from '@/hooks/useTenantData'
import { useRemediationPlans } from '@/hooks/useRemediationPlans'
```

2. Update useRemediationSummary hook:
```typescript
function useRemediationSummary() {
  const isDemoMode = useIsDemoMode()

  // Store data (demo mode)
  const storeRemediationPlans = useRCTStore((state) => state.remediationPlans)

  // Database hook (auth mode)
  const { data: dbRemediationPlans } = useRemediationPlans()

  // Dual-source selection
  const remediationPlans = isDemoMode ? storeRemediationPlans : (dbRemediationPlans || [])

  return useMemo(() => {
    // ... existing logic unchanged, uses remediationPlans variable
  }, [remediationPlans])
}
```

**OverdueWidget.tsx:**

1. Add imports:
```typescript
import { useIsDemoMode } from '@/hooks/useTenantData'
import { useRemediationPlans } from '@/hooks/useRemediationPlans'
import { useRCTRows } from '@/hooks/useRCTRows'
```

2. Update useOverdueRemediations hook:
```typescript
function useOverdueRemediations() {
  const isDemoMode = useIsDemoMode()

  // Store data (demo mode)
  const storeRemediationPlans = useRCTStore((state) => state.remediationPlans)
  const storeRows = useRCTStore((state) => state.rows)

  // Database hooks (auth mode)
  const { data: dbRemediationPlans } = useRemediationPlans()
  const { data: dbRows } = useRCTRows()

  // Dual-source selection
  const remediationPlans = isDemoMode ? storeRemediationPlans : (dbRemediationPlans || [])
  const rows = isDemoMode ? storeRows : (dbRows || [])

  return useMemo(() => {
    // ... existing logic, update row lookup to handle both types
    const row = rows.find((r: { id: string }) => r.id === plan.rowId)
    return {
      ...plan,
      riskName: (row as { riskName?: string })?.riskName || 'Unknown Risk',
      daysOverdue,
    }
  }, [remediationPlans, rows])
}
```

**UpcomingWidget.tsx:**

Same pattern as OverdueWidget - add dual-source for remediationPlans and rows.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`. Navigate to Remediation page and verify summary stats appear for authenticated user.</verify>
  <done>All three components read from database when authenticated, summary counts reflect database data</done>
</task>

<task type="auto">
  <name>Task 4: Wire RemediationSection and RemediationForm</name>
  <files>
    src/components/rct/RemediationSection.tsx
    src/components/rct/RemediationForm.tsx
  </files>
  <action>
**RemediationSection.tsx:**

1. Add imports:
```typescript
import { useIsDemoMode } from '@/hooks/useTenantData'
import { useRemediationForControl, useUpdateRemediationStatus, useUpdateRemediationPlan, useDeleteRemediationPlan } from '@/hooks/useRemediationPlans'
```

2. Add dual-source pattern inside component:
```typescript
const isDemoMode = useIsDemoMode()

// Store data (demo mode)
const storeRemediationPlans = useRCTStore(s => s.remediationPlans)
const storeUpdateStatus = useRCTStore(s => s.updateRemediationStatus)
const storeToggleAction = useRCTStore(s => s.toggleActionItem)
const storeAddAction = useRCTStore(s => s.addActionItem)
const storeRemoveAction = useRCTStore(s => s.removeActionItem)
const storeDeletePlan = useRCTStore(s => s.deleteRemediationPlan)

// Database hooks (auth mode)
const { data: dbPlans } = useRemediationForControl(control.id)
const updateStatusMutation = useUpdateRemediationStatus()
const updatePlanMutation = useUpdateRemediationPlan()
const deletePlanMutation = useDeleteRemediationPlan()

// Dual-source selection - filter store plans for this control
const remediationPlans = isDemoMode
  ? storeRemediationPlans.filter(p => p.controlId === control.id)
  : (dbPlans || [])
```

3. Create wrapper handlers (similar to RemediationTable) for:
- handleStatusChange
- handleToggleAction
- handleAddAction
- handleRemoveAction
- handleDeletePlan

4. Update RemediationPlanCard callbacks to use wrapper handlers.

**RemediationForm.tsx:**

1. Add imports:
```typescript
import { useIsDemoMode } from '@/hooks/useTenantData'
import { useCreateRemediationPlan } from '@/hooks/useRemediationPlans'
```

2. Add dual-source pattern:
```typescript
const isDemoMode = useIsDemoMode()

// Store mutation (demo mode)
const storeCreatePlan = useRCTStore((state) => state.createRemediationPlan)

// Database mutation (auth mode)
const createMutation = useCreateRemediationPlan()
```

3. Update handleSubmit to use dual-source:
```typescript
const handleSubmit = (e: React.FormEvent) => {
  e.preventDefault()
  if (!isValid) return

  const actionItems = test.recommendations
    ? [{ id: `ai-${Date.now()}`, description: test.recommendations, completed: false }]
    : []

  const planData = {
    controlTestId: test.id,
    controlId,
    rowId,
    title: title.trim(),
    description: description.trim() || undefined,
    owner: owner.trim(),
    deadline,
    status: 'open' as const,
    actionItems,
  }

  if (isDemoMode) {
    storeCreatePlan(planData, grossScore)
  } else {
    createMutation.mutate({
      ...planData,
      priority: grossScore && grossScore >= 15 ? 'critical' : grossScore && grossScore >= 10 ? 'high' : grossScore && grossScore >= 5 ? 'medium' : 'low',
    })
  }

  onComplete()
}
```
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`. Creating a remediation plan in ControlPanel persists to database for authenticated users.</verify>
  <done>RemediationSection displays database plans, RemediationForm creates database records when authenticated</done>
</task>

</tasks>

<verification>
1. TypeScript compilation: `npx tsc --noEmit` - no errors
2. Log in as authenticated user with seeded demo tenant data
3. Navigate to RCT page, click Controls button on a row with linked controls - **controls display in ControlPanel**
4. Navigate to Remediation page - should show remediation plans from database
5. Summary stats should reflect database counts
6. Overdue/upcoming widgets should show database data
7. Open RCT, click Controls button on a row with controls - RemediationSection should show plans
8. Create a new remediation plan - should persist to database (verify in Supabase)
</verification>

<success_criteria>
- Controls linked to RCT rows display in ControlPanel when authenticated
- All remediation components use dual-source pattern
- Authenticated users see remediation plans from database
- Demo mode continues to work with Zustand store
- Creating/updating/deleting remediation plans persists to database
- No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/31-controls-hub-ui-fix/31-01-SUMMARY.md`
</output>
