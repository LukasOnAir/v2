# Phase 36: Mobile Control Tester - Research

**Researched:** 2026-01-28
**Domain:** PWA, Offline-First, Mobile UX for Non-Technical Users
**Confidence:** HIGH

## Summary

Phase 36 enhances the existing mobile-responsive tester interface into a dedicated, friction-minimal experience for first-line employees. The existing implementation (TesterDashboardPage, TesterControlCard, ControlTestForm) provides a solid foundation that needs UX refinement rather than architectural overhaul.

**Key findings:**
1. **PWA is the right choice** - vite-plugin-pwa provides zero-config PWA capabilities with offline support, installability, and push notifications without native app complexity
2. **Offline-first with Workbox Background Sync** - Queue failed submissions in IndexedDB and replay when online; simpler than full offline data sync
3. **Existing reminder infrastructure** - Weekly reminders already exist (pg_cron + process-reminders Edge Function); just needs activation for controls table
4. **Camera upload via HTML5** - Native `<input type="file" capture="environment">` works on all mobile browsers; Supabase Storage for persistence
5. **Wizard UX for guided testing** - Break control tests into 3-5 small steps with clear progress indicators

**Primary recommendation:** Enhance existing components with PWA wrapper, step-by-step wizard form, and background sync for offline submissions. No new pages needed - refine TesterDashboardPage and create mobile-optimized TestWizard component.

## Standard Stack

### Core (Already in Project)
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| React + TypeScript | 19.0.0 | UI framework | Already used |
| Vite | 6.2.0 | Build tool | Already used |
| Tailwind CSS | 4.1.18 | Styling | Already used |
| React Query | 5.90.20 | Server state | Already used |
| Zustand | 5.0.10 | Client state | Already used |
| Supabase | 2.91.1 | Backend | Already used |

### New Dependencies for PWA
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| vite-plugin-pwa | ^0.20 | PWA integration | Offline support, installability |
| workbox-window | ^7.0 | Service worker registration | Auto-generated by vite-plugin-pwa |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| vite-plugin-pwa | Manual service worker | PWA plugin handles 90% automatically; manual is error-prone |
| Workbox Background Sync | PowerSync/RxDB | Full offline DB is overkill for simple form submission queue |
| HTML file input | Camera API | File input works everywhere; Camera API needs permissions |
| Supabase Storage | External S3 | Storage already included in Supabase, RLS-enabled |

**Installation:**
```bash
npm install vite-plugin-pwa workbox-window -D
```

## Architecture Patterns

### Recommended Project Structure
```
src/
├── components/
│   └── tester/
│       ├── TesterControlCard.tsx     # (exists) - minor enhancements
│       ├── TestWizard.tsx            # NEW: Step-by-step test form
│       ├── WizardStep.tsx            # NEW: Single step component
│       ├── PhotoUpload.tsx           # NEW: Camera/file capture
│       ├── OfflineIndicator.tsx      # NEW: Network status badge
│       └── index.ts                  # (exists) - add exports
├── hooks/
│   ├── useControlTests.ts            # (exists) - add offline queue
│   ├── useNetworkStatus.ts           # NEW: Online/offline detection
│   └── usePendingSync.ts             # NEW: Background sync queue
├── pages/
│   └── TesterDashboardPage.tsx       # (exists) - PWA enhancements
├── lib/
│   └── offlineQueue.ts               # NEW: IndexedDB queue utilities
└── sw.ts                             # NEW: Custom service worker (if needed)
```

### Pattern 1: PWA Configuration with vite-plugin-pwa
**What:** Configure PWA with manifest, caching, and service worker
**When to use:** Initial PWA setup
**Example:**
```typescript
// vite.config.ts
import { VitePWA } from 'vite-plugin-pwa'

export default defineConfig({
  plugins: [
    react(),
    tailwindcss(),
    VitePWA({
      registerType: 'autoUpdate',
      includeAssets: ['favicon.ico', 'robots.txt'],
      manifest: {
        name: 'RiskGuard Control Tester',
        short_name: 'Tester',
        description: 'Complete control tests on mobile',
        theme_color: '#1a1a2e',
        background_color: '#0d0d14',
        display: 'standalone',
        icons: [
          { src: 'pwa-192x192.png', sizes: '192x192', type: 'image/png' },
          { src: 'pwa-512x512.png', sizes: '512x512', type: 'image/png' }
        ]
      },
      workbox: {
        globPatterns: ['**/*.{js,css,html,ico,png,svg,woff2}'],
        runtimeCaching: [
          {
            urlPattern: /^https:\/\/.*supabase.*\/rest\/v1\/.*/i,
            handler: 'NetworkFirst',
            options: {
              cacheName: 'api-cache',
              expiration: { maxEntries: 50, maxAgeSeconds: 300 }
            }
          }
        ]
      }
    })
  ]
})
```

### Pattern 2: Step-by-Step Wizard Form
**What:** Break test form into discrete steps with progress tracking
**When to use:** Multi-field forms on mobile
**Example:**
```typescript
// TestWizard.tsx
const WIZARD_STEPS = [
  { id: 'confirm', title: 'Confirm Control', fields: ['controlName'] },
  { id: 'result', title: 'Test Result', fields: ['result', 'effectiveness'] },
  { id: 'evidence', title: 'Add Evidence', fields: ['evidence', 'photoUrl'] },
  { id: 'review', title: 'Review & Submit', fields: [] }
]

function TestWizard({ control, onComplete }: Props) {
  const [currentStep, setCurrentStep] = useState(0)
  const [formData, setFormData] = useState<Partial<ControlTest>>({})

  const progress = ((currentStep + 1) / WIZARD_STEPS.length) * 100

  return (
    <div className="flex flex-col h-full">
      {/* Progress bar */}
      <div className="h-2 bg-surface-border rounded-full overflow-hidden">
        <div
          className="h-full bg-accent-500 transition-all duration-300"
          style={{ width: `${progress}%` }}
        />
      </div>

      {/* Step indicator */}
      <p className="text-sm text-text-secondary mt-2">
        Step {currentStep + 1} of {WIZARD_STEPS.length}: {WIZARD_STEPS[currentStep].title}
      </p>

      {/* Step content */}
      <WizardStep
        step={WIZARD_STEPS[currentStep]}
        data={formData}
        onChange={setFormData}
      />

      {/* Navigation */}
      <div className="flex gap-3 mt-auto pt-4">
        {currentStep > 0 && (
          <button onClick={() => setCurrentStep(s => s - 1)} className="...">
            Back
          </button>
        )}
        <button
          onClick={() => currentStep < WIZARD_STEPS.length - 1
            ? setCurrentStep(s => s + 1)
            : handleSubmit()
          }
          className="flex-1 min-h-[48px] bg-accent-500 ..."
        >
          {currentStep === WIZARD_STEPS.length - 1 ? 'Submit Test' : 'Next'}
        </button>
      </div>
    </div>
  )
}
```

### Pattern 3: Photo/File Upload with Camera Capture
**What:** Mobile-friendly file input that defaults to camera
**When to use:** Evidence collection on mobile
**Example:**
```typescript
// PhotoUpload.tsx
function PhotoUpload({ onUpload, existingUrl }: Props) {
  const [uploading, setUploading] = useState(false)
  const [preview, setPreview] = useState<string | null>(existingUrl ?? null)

  const handleCapture = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0]
    if (!file) return

    setUploading(true)
    setPreview(URL.createObjectURL(file))

    try {
      // Upload to Supabase Storage
      const fileName = `${crypto.randomUUID()}.${file.name.split('.').pop()}`
      const { data, error } = await supabase.storage
        .from('test-evidence')
        .upload(fileName, file, { contentType: file.type })

      if (error) throw error

      const { data: { publicUrl } } = supabase.storage
        .from('test-evidence')
        .getPublicUrl(data.path)

      onUpload(publicUrl)
    } catch (err) {
      console.error('Upload failed:', err)
      toast.error('Failed to upload photo')
    } finally {
      setUploading(false)
    }
  }

  return (
    <div className="space-y-3">
      {preview && (
        <img src={preview} alt="Evidence" className="w-full rounded-lg" />
      )}

      <label className="flex items-center justify-center gap-2 min-h-[48px] px-4 py-3 bg-surface-elevated border border-surface-border rounded-lg cursor-pointer">
        <Camera size={20} />
        <span>{preview ? 'Replace Photo' : 'Take Photo'}</span>
        <input
          type="file"
          accept="image/*"
          capture="environment"  {/* Opens rear camera on mobile */}
          onChange={handleCapture}
          className="hidden"
          disabled={uploading}
        />
      </label>
    </div>
  )
}
```

### Pattern 4: Offline Queue with Background Sync
**What:** Queue form submissions when offline, replay when online
**When to use:** Critical data that must not be lost
**Example:**
```typescript
// lib/offlineQueue.ts
const DB_NAME = 'riskguard-offline'
const STORE_NAME = 'pending-tests'

async function openDB(): Promise<IDBDatabase> {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, 1)
    request.onerror = () => reject(request.error)
    request.onsuccess = () => resolve(request.result)
    request.onupgradeneeded = (event) => {
      const db = (event.target as IDBOpenDBRequest).result
      if (!db.objectStoreNames.contains(STORE_NAME)) {
        db.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true })
      }
    }
  })
}

export async function queueTestSubmission(test: Omit<ControlTest, 'id'>) {
  const db = await openDB()
  const tx = db.transaction(STORE_NAME, 'readwrite')
  const store = tx.objectStore(STORE_NAME)
  store.add({ ...test, queuedAt: new Date().toISOString() })
}

export async function getPendingTests(): Promise<Array<Omit<ControlTest, 'id'>>> {
  const db = await openDB()
  const tx = db.transaction(STORE_NAME, 'readonly')
  const store = tx.objectStore(STORE_NAME)
  return new Promise((resolve, reject) => {
    const request = store.getAll()
    request.onsuccess = () => resolve(request.result)
    request.onerror = () => reject(request.error)
  })
}

export async function clearPendingTest(id: number) {
  const db = await openDB()
  const tx = db.transaction(STORE_NAME, 'readwrite')
  tx.objectStore(STORE_NAME).delete(id)
}
```

### Pattern 5: Network Status Hook
**What:** Track online/offline status reactively
**When to use:** Show offline indicator, trigger sync
**Example:**
```typescript
// hooks/useNetworkStatus.ts
export function useNetworkStatus() {
  const [isOnline, setIsOnline] = useState(navigator.onLine)

  useEffect(() => {
    const handleOnline = () => setIsOnline(true)
    const handleOffline = () => setIsOnline(false)

    window.addEventListener('online', handleOnline)
    window.addEventListener('offline', handleOffline)

    return () => {
      window.removeEventListener('online', handleOnline)
      window.removeEventListener('offline', handleOffline)
    }
  }, [])

  return isOnline
}
```

### Anti-Patterns to Avoid
- **Full offline database sync:** PowerSync/RxDB adds complexity for a use case (form submission) that only needs a simple queue
- **Custom service worker from scratch:** vite-plugin-pwa + Workbox handles 95% of PWA requirements
- **Native app:** PWA provides installability and offline without App Store complexity
- **Complex wizard libraries:** Simple state machine with React hooks is sufficient

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Service worker | Manual SW registration | vite-plugin-pwa | Handles caching, updates, registration automatically |
| Offline caching | Custom fetch interceptor | Workbox runtimeCaching | Battle-tested, handles edge cases |
| Camera capture | WebRTC Camera API | `<input capture>` | Works everywhere, no permissions prompt |
| File storage | Custom file server | Supabase Storage | Already in stack, RLS-enabled, CDN |
| Form wizard | Heavy library | Simple step state | 50 lines of code vs dependency |
| Push notifications | FCM setup | Email reminders | Already built in Phase 23 |

**Key insight:** The existing codebase already has 80% of the infrastructure. This phase is about UX refinement and PWA wrapper, not new architecture.

## Common Pitfalls

### Pitfall 1: Overcomplicating Offline Sync
**What goes wrong:** Implementing full bidirectional sync when only outbound writes need queueing
**Why it happens:** Developers assume offline-first means full local database
**How to avoid:** For this use case, testers only SUBMIT tests - they don't need to modify historical data offline. Queue submissions, replay on reconnect.
**Warning signs:** Evaluating PowerSync/RxDB for a simple form submission feature

### Pitfall 2: iOS PWA Push Notification Limitations
**What goes wrong:** Expecting web push to work like native notifications on iOS
**Why it happens:** iOS requires PWA to be installed to home screen for push to work
**How to avoid:** Keep email reminders as primary (already built in Phase 23). Web push is a nice-to-have enhancement, not a replacement.
**Warning signs:** Planning to deprecate email reminders in favor of push

### Pitfall 3: Forgetting Touch Targets
**What goes wrong:** Buttons and inputs too small for mobile
**Why it happens:** Testing only on desktop
**How to avoid:** Enforce 44px minimum touch targets (already in project decisions [24-02])
**Warning signs:** min-h missing from interactive elements

### Pitfall 4: Complex Language in UI
**What goes wrong:** Using risk management jargon for first-line employees
**Why it happens:** Developers think in domain terms
**How to avoid:** User test with actual first-line employees. Use "Take Photo" not "Capture Evidence", "How well did it work?" not "Rate Effectiveness"
**Warning signs:** Control owners understand the UI but testers don't

### Pitfall 5: Safari Background Sync Fallback
**What goes wrong:** Background Sync doesn't work in Safari/iOS
**Why it happens:** BackgroundSync API not supported in Safari
**How to avoid:** Workbox provides fallback that retries on SW start, but test manually. Also retry on `online` event.
**Warning signs:** Tests pass in Chrome but queued submissions never sync in Safari

## Code Examples

### ReloadPrompt Component (PWA Update UI)
```typescript
// Source: vite-pwa-org.netlify.app/frameworks/react
import { useRegisterSW } from 'virtual:pwa-register/react'
import { toast } from 'sonner'

export function ReloadPrompt() {
  const {
    needRefresh: [needRefresh, setNeedRefresh],
    updateServiceWorker,
  } = useRegisterSW({
    onRegisteredSW(swUrl, r) {
      console.log('SW registered:', swUrl)
    },
  })

  useEffect(() => {
    if (needRefresh) {
      toast('New version available', {
        action: {
          label: 'Update',
          onClick: () => updateServiceWorker(true),
        },
        duration: Infinity,
      })
    }
  }, [needRefresh])

  return null
}
```

### Supabase Storage Bucket RLS Policy
```sql
-- Source: supabase.com/docs/guides/storage/security/access-control
-- Create bucket for test evidence (run once in SQL Editor)
INSERT INTO storage.buckets (id, name, public)
VALUES ('test-evidence', 'test-evidence', true);

-- Allow authenticated users to upload to their tenant's folder
CREATE POLICY "Authenticated users can upload evidence"
ON storage.objects FOR INSERT TO authenticated
WITH CHECK (
  bucket_id = 'test-evidence'
  AND (storage.foldername(name))[1] = (SELECT tenant_id()::text)
);

-- Allow anyone to read (images embedded in test records)
CREATE POLICY "Anyone can view evidence"
ON storage.objects FOR SELECT TO public
USING (bucket_id = 'test-evidence');
```

### Simplified Mobile Test Form Fields
```typescript
// Mobile version - only essential fields
const MOBILE_TEST_FIELDS = {
  required: ['result'],           // Pass/Fail/Partial
  optional: ['evidence'],         // Photo upload
  omitted: [                      // Hide on mobile wizard
    'effectiveness',              // Technical - auto-derive from result
    'testerName',                 // Auto-fill from auth
    'findings',                   // Combine into evidence
    'recommendations'             // Combine into evidence
  ]
}

// Map result to default effectiveness
const RESULT_TO_EFFECTIVENESS: Record<TestResult, number> = {
  'pass': 5,
  'partial': 3,
  'fail': 1,
  'not-tested': 0
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Native app for offline | PWA with service workers | 2022+ | No App Store, same capabilities |
| Manual service workers | vite-plugin-pwa / Workbox | 2023+ | Zero-config setup |
| localStorage offline | IndexedDB + Background Sync | 2023+ | Reliable queuing, larger storage |
| Camera plugins (Cordova) | HTML `capture` attribute | 2020+ | No plugins needed |
| Complex wizard libraries | Simple state machine | Always | Less code, more control |

**Deprecated/outdated:**
- **Cordova/PhoneGap:** PWAs have replaced these for most use cases
- **ApplicationCache (appcache):** Replaced by Service Workers in 2018
- **Web SQL:** Replaced by IndexedDB

## Open Questions

1. **Push Notifications Scope**
   - What we know: iOS requires PWA installed to home screen; email reminders already work
   - What's unclear: Do testers want push notifications, or are emails sufficient?
   - Recommendation: Keep email as primary, add push as enhancement in future phase if requested

2. **Evidence Storage Retention**
   - What we know: Supabase Storage works; images can be uploaded
   - What's unclear: How long to retain uploaded images? What size limits?
   - Recommendation: Start with 10MB limit per upload, 1 year retention; adjust based on usage

3. **Test Procedure Display**
   - What we know: Controls have `testProcedure` field (TEXT)
   - What's unclear: Should procedure be multi-step? Should steps be checkbox items?
   - Recommendation: Phase 36 displays procedure as-is; future phase could add structured steps

## Sources

### Primary (HIGH confidence)
- vite-plugin-pwa official docs - PWA configuration, React hooks
- Supabase Storage Access Control docs - RLS policies for uploads
- MDN Web Docs - HTML capture attribute, IndexedDB API

### Secondary (MEDIUM confidence)
- [The Pros and Cons of PWAs in 2025](https://www.10grounds.com/blog/the-pros-and-cons-of-progressive-web-apps-pwas-in-2025) - PWA vs native tradeoffs
- [Offline-First Frontend Apps in 2025](https://blog.logrocket.com/offline-first-frontend-apps-2025-indexeddb-sqlite/) - IndexedDB patterns
- [Workbox Background Sync](https://developer.chrome.com/docs/workbox/modules/workbox-background-sync) - Offline queue pattern
- [Wizard Design Pattern UX Planet](https://uxplanet.org/wizard-design-pattern-8c86e14f2a38) - Step-by-step UX
- [Mobile UX Design Guide 2025](https://uxcam.com/blog/mobile-ux/) - Touch targets, simplicity

### Tertiary (LOW confidence)
- WebSearch results for current ecosystem trends

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - all libraries are official/documented, most already in project
- Architecture: HIGH - patterns verified with official docs
- PWA setup: HIGH - vite-plugin-pwa is well-documented with React examples
- Offline: MEDIUM - Background Sync fallback on Safari needs testing
- UX recommendations: MEDIUM - based on general best practices, not user testing

**Research date:** 2026-01-28
**Valid until:** 2026-03-28 (60 days - stable domain)

---

## Existing Code Reuse

### Reuse As-Is
| Component | Location | Reuse For |
|-----------|----------|-----------|
| TesterDashboardPage | `src/pages/TesterDashboardPage.tsx` | Main entry point, enhance not replace |
| TesterControlCard | `src/components/tester/TesterControlCard.tsx` | Control list display |
| useControlTests hook | `src/hooks/useControlTests.ts` | Database mutations |
| process-reminders Edge Function | `supabase/functions/process-reminders/` | Weekly reminders (activate queries) |

### Enhance
| Component | Current | Enhancement |
|-----------|---------|-------------|
| ControlTestForm | All fields visible | Split into wizard steps |
| TesterControlCard | Text procedure | Add "Start Test" wizard trigger |
| useRecordTest | Direct mutation | Add offline queue wrapper |

### Create New
| Component | Purpose |
|-----------|---------|
| TestWizard | Step-by-step guided test form |
| PhotoUpload | Camera capture + Supabase upload |
| OfflineIndicator | Network status badge |
| useNetworkStatus | Online/offline hook |
| offlineQueue.ts | IndexedDB queue utilities |

## Recommendations for Planning

### Plan 1: PWA Infrastructure
- Add vite-plugin-pwa to vite.config.ts
- Create manifest with app icons
- Add ReloadPrompt component
- Test installability on mobile

### Plan 2: Offline Queue
- Create IndexedDB queue utilities
- Create useNetworkStatus hook
- Wrap useRecordTest with offline queue
- Add OfflineIndicator component

### Plan 3: Test Wizard UX
- Create TestWizard component (3-4 steps)
- Create PhotoUpload component
- Create Supabase Storage bucket + policy
- Update TesterControlCard to trigger wizard

### Plan 4: Reminders Activation
- Update process-reminders Edge Function queries (remove stubs)
- Add tenant-specific reminder preferences
- Test weekly reminder delivery

### Plan 5: Polish & Verification
- Mobile device testing (iOS Safari, Android Chrome)
- Offline scenario testing
- First-line user feedback integration
