---
phase: 38-control-assignment
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/controls/ControlDetailPanel.tsx
  - supabase/seed/demo_profiles.sql
autonomous: true

must_haves:
  truths:
    - "Controls Hub detail panel shows Testing section"
    - "Controls Hub detail panel shows Remediation section"
    - "Controls Hub detail panel shows Tickets section"
    - "Controls Hub detail panel shows Comments section"
    - "Control Tester users appear in assignment dropdown when authenticated"
  artifacts:
    - path: "src/components/controls/ControlDetailPanel.tsx"
      provides: "Full control detail view with all sections"
      contains: "ControlTestSection"
    - path: "supabase/seed/demo_profiles.sql"
      provides: "Demo tenant control-tester users"
      contains: "control-tester"
  key_links:
    - from: "src/components/controls/ControlDetailPanel.tsx"
      to: "ControlTestSection"
      via: "import and render"
      pattern: "ControlTestSection"
    - from: "src/components/controls/ControlDetailPanel.tsx"
      to: "RemediationSection"
      via: "import and render"
      pattern: "RemediationSection"
---

<objective>
Add missing sections (Testing, Remediation, Tickets, Comments) to ControlDetailPanel and seed control-tester users for the demo tenant.

Purpose: Controls Hub detail panel should show all the same information as RCT ControlPanel for full data parity. Testers should appear in assignment dropdown.
Output: ControlDetailPanel has all four sections, demo tenant has control-tester users seeded.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/38-control-assignment/38-RESEARCH.md

# Reference files
@src/components/controls/ControlDetailPanel.tsx
@src/components/rct/ControlPanel.tsx (reference for sections integration)
@src/components/rct/ControlTestSection.tsx
@src/components/rct/RemediationSection.tsx
@src/components/tickets/TicketsSection.tsx
@src/components/rct/CommentsSection.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Missing Sections to ControlDetailPanel</name>
  <files>src/components/controls/ControlDetailPanel.tsx</files>
  <action>
Add the four missing sections to ControlDetailPanel (Testing, Remediation, Tickets, Comments) to match ControlPanel.

1. Add imports at top of file:
```tsx
import { ControlTestSection } from '@/components/rct/ControlTestSection'
import { RemediationSection } from '@/components/rct/RemediationSection'
import { TicketsSection } from '@/components/tickets'
import { CommentsSection } from '@/components/rct/CommentsSection'
```

2. Add hooks for test data after existing hooks (around line 175):
```tsx
// Get tests for this control (for Remediation section)
const { data: controlTests } = useTestHistory(control?.id || '')
```
Import useTestHistory from @/hooks/useControlTests

3. After the Linked Risks section (after line 986, before the closing `</div>` of the content area), add the four sections:

```tsx
{/* Testing Section */}
{control && linkedRows.length > 0 && (
  <ControlTestSection
    rowId={linkedRows[0].id}
    control={control}
  />
)}

{/* Remediation Section */}
{control && linkedRows.length > 0 && (
  <RemediationSection
    rowId={linkedRows[0].id}
    control={control}
    tests={controlTests || []}
    grossScore={null}
  />
)}

{/* Tickets Section */}
{control && (
  <TicketsSection
    controlId={control.id}
    controlName={control.name}
  />
)}

{/* Comments Section */}
{control && (
  <CommentsSection
    entityType="control"
    entityId={control.id}
  />
)}
```

Note: The sections that require rowId (Testing, Remediation) use the first linked row's ID. If no rows are linked, these sections won't render. This matches the use case: if a control isn't linked to any risk, there's no context for testing/remediation.

For controls with no linked rows, show an info message:
```tsx
{control && linkedRows.length === 0 && (
  <div className="text-sm text-text-muted p-3 bg-surface-overlay rounded-lg border border-surface-border">
    Link this control to a risk to enable testing and remediation tracking.
  </div>
)}
```
  </action>
  <verify>TypeScript compiles without errors: `npx tsc --noEmit`</verify>
  <done>ControlDetailPanel shows Testing, Remediation, Tickets, and Comments sections</done>
</task>

<task type="auto">
  <name>Task 2: Seed Control Tester Users for Demo Tenant</name>
  <files>supabase/seed/demo_profiles.sql</files>
  <action>
Create a seed SQL file that adds control-tester users to the demo tenant so the assignment dropdown has options.

Create new file `supabase/seed/demo_profiles.sql`:

```sql
-- Demo tenant control-tester users for assignment dropdown
-- These are profiles only (no auth.users needed for RLS-enabled profiles table)
-- Demo tenant UUID: 5ea03edb-6e79-4b62-bd36-39f1963d0640

-- Insert control-tester profiles for demo tenant
-- Note: These need matching auth.users which requires Supabase Auth API
-- For now, add via service role in Edge Function or manually in Supabase Dashboard

-- Approach: Create a migration that inserts test users if they don't exist
-- Uses ON CONFLICT DO NOTHING for idempotency

-- First, we need to check if demo_profiles seed has already been applied
-- We use a simple approach: insert known UUIDs so we can reference them

DO $$
DECLARE
  demo_tenant_id UUID := '5ea03edb-6e79-4b62-bd36-39f1963d0640';
  tester1_id UUID := 'a1b2c3d4-e5f6-7890-abcd-ef1234567891';
  tester2_id UUID := 'a1b2c3d4-e5f6-7890-abcd-ef1234567892';
  tester3_id UUID := 'a1b2c3d4-e5f6-7890-abcd-ef1234567893';
  owner1_id UUID := 'b1c2d3e4-f5a6-7890-bcde-f12345678901';
BEGIN
  -- Insert profiles for control testers (if not exists)
  INSERT INTO public.profiles (id, tenant_id, full_name, role, is_active)
  VALUES
    (tester1_id, demo_tenant_id, 'Alice Tester', 'control-tester', true),
    (tester2_id, demo_tenant_id, 'Bob Tester', 'control-tester', true),
    (tester3_id, demo_tenant_id, 'Carol Tester', 'control-tester', true),
    (owner1_id, demo_tenant_id, 'David Owner', 'control-owner', true)
  ON CONFLICT (id) DO UPDATE SET
    full_name = EXCLUDED.full_name,
    role = EXCLUDED.role,
    is_active = EXCLUDED.is_active;
END $$;
```

IMPORTANT: This seed requires that the profile IDs also exist in auth.users for RLS to work. Since we can't create auth users via SQL alone, document in comments that this seed is for development/testing only.

Alternative approach - use the existing 00040 migration pattern to add profiles that work with RLS:
1. Check if demo_profiles migration exists in supabase/migrations/
2. If not, create as a new migration file

Create file as a migration instead: `supabase/migrations/00040_demo_profiles.sql`
  </action>
  <verify>
File exists and SQL syntax is valid. Run: `cat supabase/migrations/00040_demo_profiles.sql 2>/dev/null || cat supabase/seed/demo_profiles.sql`
  </verify>
  <done>SQL seed file exists with control-tester and control-owner profiles for demo tenant</done>
</task>

</tasks>

<verification>
1. Run `npx tsc --noEmit` to verify TypeScript compiles
2. Visual check: ControlDetailPanel shows four additional sections after Linked Risks
3. SQL file contains correct INSERT statements for control-tester profiles
</verification>

<success_criteria>
- ControlDetailPanel renders ControlTestSection when control has linked rows
- ControlDetailPanel renders RemediationSection when control has linked rows
- ControlDetailPanel renders TicketsSection for any control
- ControlDetailPanel renders CommentsSection for any control
- Seed SQL file creates control-tester and control-owner profiles for demo tenant
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/38-control-assignment/38-02-SUMMARY.md`
</output>
