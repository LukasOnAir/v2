---
phase: 40-admin-feature-visibility
plan: 02
type: execute
wave: 2
depends_on: ["40-01"]
files_modified:
  - src/hooks/useFeatureFlags.ts
  - src/components/layout/Header.tsx
autonomous: true

must_haves:
  truths:
    - "useFeatureFlags hook returns feature visibility state"
    - "Hook combines global flags with per-user overrides (user override wins)"
    - "RFI button only shows when show_rfi feature is enabled"
    - "Demo mode defaults to showing all features"
  artifacts:
    - path: "src/hooks/useFeatureFlags.ts"
      provides: "Feature flags hook with dual-source pattern"
      exports: ["useFeatureFlags"]
    - path: "src/components/layout/Header.tsx"
      provides: "Conditional RFI button rendering"
      contains: "useFeatureFlags"
  key_links:
    - from: "src/hooks/useFeatureFlags.ts"
      to: "supabase"
      via: "React Query fetch"
      pattern: "supabase\\.from\\('feature_flags'\\)"
    - from: "src/components/layout/Header.tsx"
      to: "src/hooks/useFeatureFlags.ts"
      via: "hook import"
      pattern: "useFeatureFlags"
---

<objective>
Create the useFeatureFlags hook that reads global and per-user settings, then integrate into Header to conditionally render RFI button.

Purpose: Provide a clean React hook API for checking feature visibility throughout the app, with the first integration hiding/showing the RFI button.

Output: useFeatureFlags hook with dual-source pattern (demo mode vs authenticated), Header updated to use it.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/40-admin-feature-visibility/40-01-SUMMARY.md
@src/hooks/usePermissions.ts
@src/contexts/AuthContext.tsx
@src/components/layout/Header.tsx
@src/lib/supabase/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useFeatureFlags hook</name>
  <files>src/hooks/useFeatureFlags.ts</files>
  <action>
Create src/hooks/useFeatureFlags.ts with dual-source pattern (matching project conventions from usePermissions, useTenantData):

```typescript
import { useQuery } from '@tanstack/react-query'
import { supabase } from '@/lib/supabase/client'
import { useAuth } from '@/contexts/AuthContext'
import type { FeatureFlagRow, FeatureOverrides } from '@/lib/supabase/types'

/**
 * Known feature flags - extend this as new features are added
 */
export type FeatureKey = 'show_rfi'

/**
 * Default feature visibility in demo mode (all features shown)
 */
const DEMO_DEFAULTS: Record<FeatureKey, boolean> = {
  show_rfi: true,
}

/**
 * Hook to check feature visibility
 *
 * Priority: User override > Global flag > Demo default
 *
 * In demo mode (not authenticated), returns DEMO_DEFAULTS
 * In authenticated mode, fetches from database:
 *   1. Global feature_flags for tenant
 *   2. User's feature_overrides from profile
 *   3. User override wins if set
 */
export function useFeatureFlags() {
  const { session, user } = useAuth()
  const isDemoMode = !session

  // Fetch global feature flags for tenant
  const { data: globalFlags = [] } = useQuery({
    queryKey: ['feature-flags'],
    queryFn: async () => {
      const { data, error } = await supabase
        .from('feature_flags')
        .select('feature_key, enabled')

      if (error) {
        console.error('Error fetching feature flags:', error)
        return []
      }
      return data as Pick<FeatureFlagRow, 'feature_key' | 'enabled'>[]
    },
    enabled: !isDemoMode,
    staleTime: 5 * 60 * 1000, // 5 minutes - flags don't change often
  })

  // Fetch user's feature overrides from profile
  const { data: userOverrides } = useQuery({
    queryKey: ['feature-overrides', user?.id],
    queryFn: async () => {
      if (!user?.id) return null

      const { data, error } = await supabase
        .from('profiles')
        .select('feature_overrides')
        .eq('id', user.id)
        .single()

      if (error) {
        console.error('Error fetching feature overrides:', error)
        return null
      }
      return data?.feature_overrides as FeatureOverrides | null
    },
    enabled: !isDemoMode && !!user?.id,
    staleTime: 5 * 60 * 1000,
  })

  /**
   * Check if a feature is enabled
   * @param key Feature key to check
   * @returns true if feature should be visible
   */
  const isFeatureEnabled = (key: FeatureKey): boolean => {
    // Demo mode: use defaults (all features visible)
    if (isDemoMode) {
      return DEMO_DEFAULTS[key] ?? true
    }

    // Check user override first (highest priority)
    if (userOverrides && key in userOverrides) {
      return userOverrides[key]
    }

    // Check global flag
    const globalFlag = globalFlags.find(f => f.feature_key === key)
    if (globalFlag) {
      return globalFlag.enabled
    }

    // Default to visible if not configured
    return true
  }

  return {
    isFeatureEnabled,
    // Convenience accessors for common features
    showRfi: isFeatureEnabled('show_rfi'),
    // Loading state
    isLoading: !isDemoMode && globalFlags.length === 0,
    isDemoMode,
  }
}
```

Key design decisions:
- Type-safe FeatureKey union for known features
- Demo mode shows all features (no restrictions for sales demos)
- User override takes priority over global flag
- 5-minute staleTime since flags change infrequently
- Graceful fallback to "visible" if not configured
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>
useFeatureFlags hook exists with isFeatureEnabled function, showRfi convenience accessor, and dual-source pattern for demo/authenticated modes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate feature flag into Header</name>
  <files>src/components/layout/Header.tsx</files>
  <action>
Update src/components/layout/Header.tsx to conditionally render RFI button:

1. Import useFeatureFlags:
```typescript
import { useFeatureFlags } from '@/hooks/useFeatureFlags'
```

2. Add hook call at the top of the Header component (after existing hooks):
```typescript
const { showRfi } = useFeatureFlags()
```

3. Wrap the RFI button in a conditional:
```tsx
{showRfi && (
  <button
    onClick={() => setShowRFI(true)}
    className="px-3 py-1.5 text-sm bg-surface-overlay hover:bg-surface-elevated border border-surface-border rounded-md flex items-center gap-1.5 text-text-secondary hover:text-text-primary transition-colors"
  >
    <FileText className="w-4 h-4" />
    Show RFI
  </button>
)}
```

No other changes needed - the rest of the Header stays the same.
  </action>
  <verify>
1. App compiles without errors: `npm run build`
2. Manual check: In demo mode, RFI button should still appear (demo defaults to visible)
  </verify>
  <done>
Header.tsx imports useFeatureFlags and conditionally renders RFI button based on showRfi flag.
  </done>
</task>

</tasks>

<verification>
- [ ] useFeatureFlags hook exists and exports correctly
- [ ] Hook handles demo mode (returns defaults)
- [ ] Hook fetches from database when authenticated
- [ ] User overrides take priority over global flags
- [ ] Header imports and uses useFeatureFlags
- [ ] RFI button conditionally rendered
- [ ] App builds without errors
</verification>

<success_criteria>
- useFeatureFlags hook provides clean API for feature visibility
- RFI button respects feature flag setting
- Demo mode continues to show RFI (no regression)
- Authenticated users see RFI based on tenant settings
</success_criteria>

<output>
After completion, create `.planning/phases/40-admin-feature-visibility/40-02-SUMMARY.md`
</output>
