---
phase: 44-super-admin-tenant-switching
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/00033_superadmin_tenant_read_policies.sql
  - src/contexts/ImpersonationContext.tsx
  - src/hooks/useEffectiveTenant.ts
autonomous: true

must_haves:
  truths:
    - "Super-admin can read data from any tenant via RLS"
    - "Impersonation state is available throughout the app"
    - "Impersonation state persists across page refresh"
  artifacts:
    - path: "supabase/migrations/00033_superadmin_tenant_read_policies.sql"
      provides: "RLS policies for super-admin cross-tenant read"
      contains: "CREATE POLICY.*superadmin_read"
    - path: "src/contexts/ImpersonationContext.tsx"
      provides: "Impersonation state management"
      exports: ["ImpersonationProvider", "useImpersonation"]
    - path: "src/hooks/useEffectiveTenant.ts"
      provides: "Combined auth + impersonation tenant resolution"
      exports: ["useEffectiveTenant"]
  key_links:
    - from: "src/hooks/useEffectiveTenant.ts"
      to: "src/contexts/ImpersonationContext.tsx"
      via: "useImpersonation import"
      pattern: "useImpersonation"
    - from: "src/hooks/useEffectiveTenant.ts"
      to: "src/contexts/AuthContext.tsx"
      via: "useAuth import"
      pattern: "useAuth"
---

<objective>
Create the foundation for super-admin tenant impersonation: database RLS policies for cross-tenant read access and React context for impersonation state management.

Purpose: Super-admins need to be able to read data from any tenant while impersonating. This requires both database-level policies (RLS) and frontend state management (context).

Output: Migration file with super-admin read policies for all tenant-scoped tables, ImpersonationContext for state management, and useEffectiveTenant hook for consuming effective tenant ID.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/44-super-admin-tenant-switching/44-RESEARCH.md

# Existing patterns to follow
@src/contexts/AuthContext.tsx
@supabase/migrations/00031_super_admin_and_global_flags.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create super-admin read RLS policies migration</name>
  <files>supabase/migrations/00033_superadmin_tenant_read_policies.sql</files>
  <action>
Create migration file that adds SELECT RLS policies for super-admins on ALL tenant-scoped tables.

Use the existing `public.is_super_admin()` function from migration 00031.

Tables requiring super-admin read policies (15 tables):
1. controls
2. rct_rows
3. taxonomy_nodes
4. control_links
5. control_tests
6. remediation_plans
7. tickets
8. comments
9. pending_changes
10. audit_log
11. custom_columns
12. score_labels
13. taxonomy_weights
14. knowledge_base
15. feature_flags (tenant-scoped, NOT global_feature_flags)

Also need to:
- Enable RLS on tenants table if not already enabled
- Add super-admin read policy for tenants table (to list all tenants)
- Add super-admin read policy for profiles table (to list profiles within a tenant)

Pattern for each table:
```sql
DROP POLICY IF EXISTS "{table}_superadmin_read" ON public.{table};
CREATE POLICY "{table}_superadmin_read" ON public.{table}
  FOR SELECT TO authenticated
  USING (public.is_super_admin());
```

Make migration idempotent (DROP POLICY IF EXISTS before CREATE).

Add comment at top explaining this migration adds super-admin cross-tenant read access for impersonation feature.
  </action>
  <verify>File exists at supabase/migrations/00033_superadmin_tenant_read_policies.sql with policies for all 15+ tables</verify>
  <done>Migration file contains DROP/CREATE POLICY pairs for all tenant-scoped tables plus tenants and profiles tables</done>
</task>

<task type="auto">
  <name>Task 2: Create ImpersonationContext for state management</name>
  <files>src/contexts/ImpersonationContext.tsx</files>
  <action>
Create React context for impersonation state management.

Interface:
```typescript
interface ImpersonationState {
  tenantId: string | null
  tenantName: string | null
  profileId: string | null
  profileName: string | null
  profileRole: string | null  // Store impersonated user's role
}

interface ImpersonationContextType {
  impersonation: ImpersonationState
  isImpersonating: boolean
  isReadOnly: boolean  // Always true when impersonating
  startTenantImpersonation: (tenantId: string, tenantName: string) => void
  selectProfile: (profileId: string, profileName: string, profileRole: string) => void
  exitImpersonation: () => void
}
```

Implementation requirements:
1. Use useState with lazy initializer to restore from sessionStorage on mount
2. Create persist helper that saves to sessionStorage AND updates state
3. startTenantImpersonation: set tenantId/tenantName, clear profileId/profileName/profileRole
4. selectProfile: keep tenantId/tenantName, set profileId/profileName/profileRole
5. exitImpersonation: clear all, remove from sessionStorage
6. isImpersonating = !!impersonation.tenantId
7. isReadOnly = isImpersonating (always read-only when impersonating)

Export:
- ImpersonationProvider (component)
- useImpersonation (hook)

Follow existing AuthContext.tsx patterns for structure and error handling (throw error if hook used outside provider).

Storage key: 'risklytix-impersonation' (namespace to avoid conflicts)
  </action>
  <verify>TypeScript compiles without errors: `npx tsc --noEmit`</verify>
  <done>ImpersonationContext exports ImpersonationProvider and useImpersonation hook with sessionStorage persistence</done>
</task>

<task type="auto">
  <name>Task 3: Create useEffectiveTenant hook</name>
  <files>src/hooks/useEffectiveTenant.ts</files>
  <action>
Create hook that combines auth tenant with impersonation override.

Implementation:
```typescript
import { useAuth } from '@/contexts/AuthContext'
import { useImpersonation } from '@/contexts/ImpersonationContext'

export function useEffectiveTenant() {
  const { tenantId: realTenantId, authRole: realRole } = useAuth()
  const { impersonation, isImpersonating, isReadOnly } = useImpersonation()

  return {
    // Effective values (impersonation overrides real)
    effectiveTenantId: impersonation.tenantId ?? realTenantId,
    effectiveProfileId: impersonation.profileId ?? null,
    effectiveRole: impersonation.profileRole ?? realRole,

    // State flags
    isImpersonating,
    isReadOnly,

    // Real values (for admin UI to know who the actual user is)
    realTenantId,
    realRole,
  }
}
```

This hook will be used by:
1. Data hooks - to get effectiveTenantId for queryKey and explicit filtering
2. Mutation hooks - to check isReadOnly before allowing modifications
3. UI components - to show effective role for permission-based rendering

Export the hook as named export.
  </action>
  <verify>TypeScript compiles without errors: `npx tsc --noEmit`</verify>
  <done>useEffectiveTenant hook exports effectiveTenantId, effectiveProfileId, effectiveRole, isImpersonating, isReadOnly, realTenantId, realRole</done>
</task>

</tasks>

<verification>
1. Migration file exists with correct number of policies (check for 17+ CREATE POLICY statements)
2. ImpersonationContext.tsx exports ImpersonationProvider and useImpersonation
3. useEffectiveTenant.ts exports useEffectiveTenant hook
4. TypeScript compiles: `npx tsc --noEmit`
</verification>

<success_criteria>
- Migration file ready for `supabase db push` with super-admin read policies for all tenant-scoped tables
- ImpersonationContext provides complete impersonation state management with sessionStorage persistence
- useEffectiveTenant hook combines auth and impersonation state for downstream consumption
- All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/44-super-admin-tenant-switching/44-01-SUMMARY.md`
</output>
