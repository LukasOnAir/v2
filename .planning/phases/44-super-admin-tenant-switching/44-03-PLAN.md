---
phase: 44-super-admin-tenant-switching
plan: 03
type: execute
wave: 2
depends_on: [44-01]
files_modified:
  - src/hooks/useRCTRows.ts
  - src/hooks/useTaxonomy.ts
  - src/hooks/useControls.ts
  - src/hooks/useControlLinks.ts
  - src/hooks/useControlTests.ts
  - src/hooks/useTickets.ts
  - src/hooks/useComments.ts
  - src/hooks/usePendingChanges.ts
  - src/hooks/useCustomColumns.ts
  - src/hooks/useScoreLabels.ts
  - src/hooks/useTaxonomyWeights.ts
  - src/hooks/useKnowledgeBase.ts
  - src/hooks/useProfiles.ts
  - src/hooks/useRemediationPlans.ts
  - src/hooks/useAuditLogDb.ts
autonomous: true

must_haves:
  truths:
    - "Data hooks filter by effective tenant when impersonating"
    - "Query cache is isolated per tenant (no cross-tenant pollution)"
    - "Mutations are blocked when in read-only mode"
  artifacts:
    - path: "src/hooks/useRCTRows.ts"
      provides: "RCT rows with impersonation support"
      contains: "effectiveTenantId"
    - path: "src/hooks/useControls.ts"
      provides: "Controls with impersonation support"
      contains: "effectiveTenantId"
    - path: "src/hooks/useTaxonomy.ts"
      provides: "Taxonomy with impersonation support"
      contains: "effectiveTenantId"
  key_links:
    - from: "src/hooks/useRCTRows.ts"
      to: "src/hooks/useEffectiveTenant.ts"
      via: "hook import"
      pattern: "useEffectiveTenant"
    - from: "src/hooks/useControls.ts"
      to: "src/hooks/useEffectiveTenant.ts"
      via: "hook import"
      pattern: "useEffectiveTenant"
---

<objective>
Modify all data hooks to support tenant impersonation: add effectiveTenantId to queryKey for cache isolation, add explicit tenant filter when impersonating, and block mutations in read-only mode.

Purpose: When a super-admin impersonates a tenant, data hooks must fetch that tenant's data (not the super-admin's null tenant). Without explicit filtering, RLS would return ALL data since super-admin has cross-tenant read access. Mutations must be blocked to enforce read-only mode.

Output: All 15 data hooks modified with impersonation support.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/44-super-admin-tenant-switching/44-RESEARCH.md
@.planning/phases/44-super-admin-tenant-switching/44-01-SUMMARY.md

# Hooks to modify
@src/hooks/useRCTRows.ts
@src/hooks/useControls.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Modify core data hooks (RCT, Taxonomy, Controls, ControlLinks)</name>
  <files>src/hooks/useRCTRows.ts, src/hooks/useTaxonomy.ts, src/hooks/useControls.ts, src/hooks/useControlLinks.ts</files>
  <action>
Modify each hook with the impersonation pattern. For each hook:

**1. Import useEffectiveTenant:**
```typescript
import { useEffectiveTenant } from '@/hooks/useEffectiveTenant'
```

**2. Get effective values in hook:**
```typescript
const { effectiveTenantId, isImpersonating, isReadOnly } = useEffectiveTenant()
```

**3. Update queryKey to include tenant for cache isolation:**
```typescript
// Before:
queryKey: ['rctRows']
// After:
queryKey: ['rctRows', effectiveTenantId]
```

**4. Add explicit tenant filter when impersonating:**
```typescript
queryFn: async () => {
  let query = supabase.from('rct_rows').select('*')

  // When impersonating, super-admin RLS allows all reads
  // Add explicit filter to get only the impersonated tenant's data
  if (isImpersonating && effectiveTenantId) {
    query = query.eq('tenant_id', effectiveTenantId)
  }

  const { data, error } = await query.order('row_id')
  // ...
}
```

**5. Add read-only check to all mutation hooks:**
For useMutation hooks (useUpdateRCTRow, useCreateRCTRow, etc.), add at start of mutationFn:
```typescript
mutationFn: async (params) => {
  if (isReadOnly) {
    toast.error('Cannot modify data while viewing as another user')
    throw new Error('Read-only mode: modifications disabled')
  }
  // ... existing mutation code
}
```

**Files and their query keys:**

**useRCTRows.ts:**
- useRCTRows: ['rctRows'] -> ['rctRows', effectiveTenantId]
- useRCTRowById: ['rctRows', id] -> ['rctRows', 'byId', id, effectiveTenantId]
- Add isReadOnly check to: useUpdateRCTRow, useCreateRCTRow, useDeleteRCTRow, useBulkCreateRCTRows, useBulkUpsertRCTRows

**useTaxonomy.ts:**
- useTaxonomy: ['taxonomy', type] -> ['taxonomy', type, effectiveTenantId]
- Add isReadOnly check to mutation hooks if any exist

**useControls.ts:**
- useControls: ['controls'] -> ['controls', effectiveTenantId]
- useMyAssignedControls: ['controls', 'assigned', testerId] -> ['controls', 'assigned', testerId, effectiveTenantId]
- useControlById: ['controls', id] -> ['controls', 'byId', id, effectiveTenantId]
- Add isReadOnly check to: useAddControl, useUpdateControl, useDeleteControl

**useControlLinks.ts:**
- useControlLinks: ['controlLinks'] -> ['controlLinks', effectiveTenantId]
- useControlLinksByRow: ['controlLinks', 'byRow', rowId] -> ['controlLinks', 'byRow', rowId, effectiveTenantId]
- useControlLinksByControl: ['controlLinks', 'byControl', controlId] -> ['controlLinks', 'byControl', controlId, effectiveTenantId]
- Add isReadOnly check to: useAddControlLink, useDeleteControlLink
  </action>
  <verify>TypeScript compiles without errors: `npx tsc --noEmit`</verify>
  <done>Core data hooks (useRCTRows, useTaxonomy, useControls, useControlLinks) modified with effectiveTenantId in queryKey, explicit tenant filter when impersonating, and isReadOnly check on mutations</done>
</task>

<task type="auto">
  <name>Task 2: Modify remaining entity hooks (Tests, Tickets, Comments, Remediation, Pending)</name>
  <files>src/hooks/useControlTests.ts, src/hooks/useTickets.ts, src/hooks/useComments.ts, src/hooks/useRemediationPlans.ts, src/hooks/usePendingChanges.ts</files>
  <action>
Apply the same impersonation pattern to remaining entity hooks.

**useControlTests.ts:**
- useControlTests: ['controlTests'] -> ['controlTests', effectiveTenantId]
- useControlTestsByControl: ['controlTests', 'byControl', controlId] -> ['controlTests', 'byControl', controlId, effectiveTenantId]
- Add isReadOnly check to mutation hooks

**useTickets.ts:**
- useTickets: ['tickets'] -> ['tickets', effectiveTenantId]
- useTicketById: ['tickets', id] -> ['tickets', 'byId', id, effectiveTenantId]
- Add isReadOnly check to mutation hooks

**useComments.ts:**
- useComments: ['comments'] -> ['comments', effectiveTenantId]
- useCommentsByEntity: ['comments', entityType, entityId] -> ['comments', entityType, entityId, effectiveTenantId]
- Add isReadOnly check to mutation hooks

**useRemediationPlans.ts:**
- useRemediationPlans: ['remediationPlans'] -> ['remediationPlans', effectiveTenantId]
- useRemediationPlansByControl: ['remediationPlans', 'byControl', controlId] -> ['remediationPlans', 'byControl', controlId, effectiveTenantId]
- Add isReadOnly check to mutation hooks

**usePendingChanges.ts:**
- usePendingChanges: ['pendingChanges'] -> ['pendingChanges', effectiveTenantId]
- Add isReadOnly check to mutation hooks

Pattern for each file:
1. Add import: `import { useEffectiveTenant } from '@/hooks/useEffectiveTenant'`
2. Add at top of each hook: `const { effectiveTenantId, isImpersonating, isReadOnly } = useEffectiveTenant()`
3. Update queryKey to include effectiveTenantId as last element
4. Add explicit tenant filter in queryFn when isImpersonating
5. Add isReadOnly check at start of mutation functions
  </action>
  <verify>TypeScript compiles without errors: `npx tsc --noEmit`</verify>
  <done>Entity hooks (useControlTests, useTickets, useComments, useRemediationPlans, usePendingChanges) modified with impersonation support</done>
</task>

<task type="auto">
  <name>Task 3: Modify configuration and utility hooks</name>
  <files>src/hooks/useCustomColumns.ts, src/hooks/useScoreLabels.ts, src/hooks/useTaxonomyWeights.ts, src/hooks/useKnowledgeBase.ts, src/hooks/useProfiles.ts, src/hooks/useAuditLogDb.ts</files>
  <action>
Apply the same impersonation pattern to configuration and utility hooks.

**useCustomColumns.ts:**
- useCustomColumns: ['customColumns'] -> ['customColumns', effectiveTenantId]
- Add isReadOnly check to mutation hooks

**useScoreLabels.ts:**
- useScoreLabels: ['scoreLabels'] -> ['scoreLabels', effectiveTenantId]
- Add isReadOnly check to mutation hooks

**useTaxonomyWeights.ts:**
- useTaxonomyWeights: ['taxonomyWeights'] -> ['taxonomyWeights', effectiveTenantId]
- Add isReadOnly check to mutation hooks

**useKnowledgeBase.ts:**
- useKnowledgeBase: ['knowledgeBase'] -> ['knowledgeBase', effectiveTenantId]
- useKnowledgeBaseById: ['knowledgeBase', id] -> ['knowledgeBase', 'byId', id, effectiveTenantId]
- Add isReadOnly check to mutation hooks

**useProfiles.ts:**
- useProfiles: ['profiles'] -> ['profiles', effectiveTenantId]
- Add isReadOnly check to mutation hooks (if any)

**useAuditLogDb.ts:**
- useAuditLog: ['auditLog'] -> ['auditLog', effectiveTenantId]
- Note: Audit log is typically read-only, so may not have mutations to protect

Same pattern for each:
1. Import useEffectiveTenant
2. Get effectiveTenantId, isImpersonating, isReadOnly
3. Add effectiveTenantId to queryKey
4. Add explicit tenant filter when isImpersonating
5. Add isReadOnly check to mutations

Note: Some hooks may need slight variations based on their existing structure. Follow the existing patterns in each file while adding impersonation support.
  </action>
  <verify>TypeScript compiles without errors: `npx tsc --noEmit`</verify>
  <done>Configuration hooks (useCustomColumns, useScoreLabels, useTaxonomyWeights, useKnowledgeBase, useProfiles, useAuditLogDb) modified with impersonation support</done>
</task>

</tasks>

<verification>
1. All 15 data hooks import useEffectiveTenant
2. All query hooks include effectiveTenantId in queryKey
3. All query hooks add explicit tenant filter when isImpersonating
4. All mutation hooks check isReadOnly before executing
5. TypeScript compiles: `npx tsc --noEmit`
6. Quick grep check: `grep -l "useEffectiveTenant" src/hooks/*.ts` should show all modified files
</verification>

<success_criteria>
- All data hooks include effectiveTenantId in queryKey for cache isolation
- All data hooks filter by effectiveTenantId when impersonating
- All mutations blocked with toast error when isReadOnly is true
- No cross-tenant cache pollution possible
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/44-super-admin-tenant-switching/44-03-SUMMARY.md`
</output>
