---
phase: 45-control-test-steps
plan: 03
type: execute
wave: 2
depends_on: ["45-01"]
files_modified:
  - src/components/tester/StepInput.tsx
  - src/components/tester/CannotRecordReason.tsx
  - src/components/tester/TestWizard.tsx
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Test wizard shows procedure steps if control has testSteps defined"
    - "Each step renders appropriate input control based on inputType"
    - "Tester can mark step as 'cannot record' with mandatory reason"
    - "Tester can attach photo evidence per-step"
    - "Step responses are saved with test submission"
    - "Legacy controls (no testSteps) work unchanged"
  artifacts:
    - path: "src/components/tester/StepInput.tsx"
      provides: "Dynamic input rendering by step type"
      min_lines: 80
    - path: "src/components/tester/CannotRecordReason.tsx"
      provides: "Skip step with mandatory reason UI"
      min_lines: 30
    - path: "src/components/tester/TestWizard.tsx"
      provides: "Extended wizard with dynamic procedure steps"
      contains: "testSteps"
  key_links:
    - from: "src/components/tester/TestWizard.tsx"
      to: "src/components/tester/StepInput.tsx"
      via: "render procedure step content"
      pattern: "StepInput"
    - from: "src/components/tester/TestWizard.tsx"
      to: "src/types/rct.ts"
      via: "StepResponse type"
      pattern: "StepResponse"
---

<objective>
Extend the mobile test wizard to render dynamic procedure steps with appropriate input controls.

Purpose: When a control has structured test steps, testers see each step as a separate wizard screen with the appropriate input control (text, yes/no, multiple choice, number, date). This guides testers through repeatable testing procedures.

Output: StepInput component for dynamic inputs, CannotRecordReason for skip functionality, extended TestWizard with dynamic step injection.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/45-control-test-steps/45-RESEARCH.md
@.planning/phases/45-control-test-steps/45-01-SUMMARY.md

@src/components/tester/TestWizard.tsx
@src/components/tester/PhotoUpload.tsx
@src/types/rct.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CannotRecordReason component</name>
  <files>src/components/tester/CannotRecordReason.tsx</files>
  <action>
Create component for skipping a step with mandatory reason:

```typescript
interface CannotRecordReasonProps {
  reason: string
  onReasonChange: (reason: string) => void
}
```

Layout:
1. Warning icon (AlertTriangle) with "Cannot record this step" label
2. Required textarea for reason (min 10 characters)
3. Helper text: "Please explain why this step cannot be recorded"
4. Validation message if reason is too short

Styling:
- Yellow/amber warning colors (bg-amber-500/10 border-amber-500/30)
- min-h-[100px] textarea for touch-friendly input
- Mobile-optimized (44px minimum touch targets)
- Match existing TestWizard Tailwind patterns
  </action>
  <verify>File exists with textarea, reason validation, and amber warning styling</verify>
  <done>CannotRecordReason renders warning state with mandatory reason textarea</done>
</task>

<task type="auto">
  <name>Task 2: Create StepInput component for dynamic input rendering</name>
  <files>src/components/tester/StepInput.tsx</files>
  <action>
Create component that renders appropriate input based on step type:

```typescript
interface StepInputProps {
  step: TestStep
  value: string | number | boolean | null
  onChange: (value: string | number | boolean | null) => void
  cannotRecord: boolean
  cannotRecordReason: string
  onCannotRecordChange: (cannot: boolean, reason: string) => void
  evidenceUrl: string | null
  onEvidenceChange: (url: string | null) => void
}
```

Render by inputType:

**text:**
- Textarea with step.helpText as placeholder
- min-h-[100px], resize-y
- Mobile-friendly padding (px-4 py-3)

**binary:**
- Two large buttons: "Yes" (green) and "No" (red)
- min-h-[64px] for touch targets
- Selected state: bg-green-500/10 border-green-500 or bg-red-500/10 border-red-500
- Use boolean: true for Yes, false for No

**multiple_choice:**
- Vertical stack of option buttons from step.options
- Each button full width, min-h-[48px]
- Selected state: bg-accent-500/10 border-accent-500
- String value matches selected option

**number:**
- `<input type="number">` with large touch target
- min-h-[48px], text-lg for readability
- Parse to number on change, null if empty

**date:**
- `<input type="date">` with large touch target
- min-h-[48px]
- String value in ISO format (yyyy-MM-dd)

All types include:
1. "Cannot record this step" toggle button at bottom
2. When toggled, show CannotRecordReason component instead of input
3. Per-step evidence section using existing PhotoUpload component
4. Step label displayed as header (handled by wizard, not this component)
  </action>
  <verify>
File has switch statement for all 5 input types
Each input type has min-h for touch targets
PhotoUpload imported and rendered for evidence
  </verify>
  <done>StepInput renders all 5 input types with cannot-record toggle and per-step evidence</done>
</task>

<task type="auto">
  <name>Task 3: Extend TestWizard with dynamic procedure steps</name>
  <files>src/components/tester/TestWizard.tsx</files>
  <action>
Modify TestWizard.tsx to inject procedure steps between Review and Result:

1. Add state for step responses:
```typescript
const [stepResponses, setStepResponses] = useState<Map<string, StepResponse>>(new Map())
```

2. Build dynamic wizard steps:
```typescript
const buildWizardSteps = (control: Control) => {
  const steps = [
    { id: 'confirm', title: 'Review Control', subtitle: 'Verify this is the correct control' },
  ]

  // Inject procedure steps if defined
  if (control.testSteps && control.testSteps.length > 0) {
    const procedureSteps = [...control.testSteps]
      .sort((a, b) => a.order - b.order)
      .map((step, idx) => ({
        id: `step-${step.id}`,
        title: `Step ${idx + 1}: ${step.label}`,
        subtitle: step.helpText || getInputTypeLabel(step.inputType),
        procedureStep: step,
      }))
    steps.push(...procedureSteps)
  }

  steps.push(
    { id: 'result', title: 'Test Result', subtitle: 'Did the control work as expected?' },
    { id: 'evidence', title: 'Add Evidence', subtitle: 'Optional: Take a photo or add notes' },
    { id: 'review', title: 'Review & Submit', subtitle: 'Check your answers before submitting' },
  )

  return steps
}
```

3. Helper function for input type labels:
```typescript
const getInputTypeLabel = (type: TestStepInputType): string => {
  const labels: Record<TestStepInputType, string> = {
    text: 'Enter your observation',
    binary: 'Yes or No',
    multiple_choice: 'Select one option',
    number: 'Enter a number',
    date: 'Select a date',
  }
  return labels[type]
}
```

4. Use useMemo for WIZARD_STEPS:
```typescript
const wizardSteps = useMemo(() => buildWizardSteps(control), [control])
```

5. Render StepInput for procedure steps:
```typescript
{currentWizardStep.procedureStep && (
  <StepInput
    step={currentWizardStep.procedureStep}
    value={stepResponses.get(currentWizardStep.procedureStep.id)?.value ?? null}
    onChange={(value) => updateStepResponse(currentWizardStep.procedureStep!.id, { value })}
    cannotRecord={stepResponses.get(currentWizardStep.procedureStep.id)?.cannotRecord ?? false}
    cannotRecordReason={stepResponses.get(currentWizardStep.procedureStep.id)?.cannotRecordReason ?? ''}
    onCannotRecordChange={(cannot, reason) => updateStepResponse(currentWizardStep.procedureStep!.id, { cannotRecord: cannot, cannotRecordReason: reason })}
    evidenceUrl={stepResponses.get(currentWizardStep.procedureStep.id)?.evidenceUrl ?? null}
    onEvidenceChange={(url) => updateStepResponse(currentWizardStep.procedureStep!.id, { evidenceUrl: url })}
  />
)}
```

6. Helper to update step responses:
```typescript
const updateStepResponse = (stepId: string, updates: Partial<StepResponse>) => {
  setStepResponses(prev => {
    const current = prev.get(stepId) || {
      stepId,
      value: null,
      cannotRecord: false,
      recordedAt: new Date().toISOString()
    }
    const updated = new Map(prev)
    updated.set(stepId, { ...current, ...updates, recordedAt: new Date().toISOString() })
    return updated
  })
}
```

7. Update canProceed to validate required steps:
```typescript
// For procedure step pages
if (currentWizardStep.procedureStep) {
  const step = currentWizardStep.procedureStep
  const response = stepResponses.get(step.id)
  if (step.required) {
    if (response?.cannotRecord) {
      return (response.cannotRecordReason?.length ?? 0) >= 10
    }
    return response?.value !== null && response?.value !== undefined && response?.value !== ''
  }
  return true // Non-required steps can proceed
}
```

8. Include step_responses in submission:
```typescript
const testData = {
  // ... existing fields ...
  stepResponses: control.testSteps?.length
    ? Array.from(stepResponses.values())
    : undefined,
}
```

9. Update review step to show step responses summary.

Import StepInput, CannotRecordReason, and types at top of file.
  </action>
  <verify>
`grep -n "buildWizardSteps\|procedureStep\|stepResponses" src/components/tester/TestWizard.tsx` shows dynamic steps and response tracking
TestWizard.tsx imports StepInput component
  </verify>
  <done>TestWizard dynamically injects procedure steps, tracks responses, validates required steps, includes responses in submission</done>
</task>

</tasks>

<verification>
- [ ] Control without testSteps shows original 4-step wizard (unchanged)
- [ ] Control with testSteps shows Review > Step1 > Step2... > Result > Evidence > Submit
- [ ] Binary input shows Yes/No buttons with visual selection state
- [ ] Multiple choice shows all options as selectable buttons
- [ ] Number input accepts numeric values
- [ ] Date input shows native date picker
- [ ] Text input shows textarea with helpText placeholder
- [ ] "Cannot record" toggle hides input and shows reason textarea
- [ ] Required steps block progression if not completed
- [ ] Per-step evidence (photo) can be attached
- [ ] Step responses included in test submission
- [ ] TypeScript compiles without errors
</verification>

<success_criteria>
1. StepInput renders correct control for each of 5 input types
2. CannotRecordReason enforces minimum reason length
3. TestWizard dynamically builds steps based on control.testSteps
4. Required step validation blocks Next until completed
5. stepResponses array included in test submission to database
6. Backward compatibility: legacy controls work unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/45-control-test-steps/45-03-SUMMARY.md`
</output>
