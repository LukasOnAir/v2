/**
 * Offline Queue - IndexedDB utilities for queuing test submissions when offline
 */
import type { ControlTest } from '@/types/rct'

// Database constants
const DB_NAME = 'riskguard-offline'
const STORE_NAME = 'pending-tests'
const DB_VERSION = 1

/**
 * Pending test entry stored in IndexedDB
 * Includes auto-generated id and queuedAt timestamp
 */
export interface PendingTest extends Omit<ControlTest, 'id'> {
  id: number
  queuedAt: string
}

/**
 * Open the IndexedDB database
 * Creates object store on first open (upgrade)
 */
function openDB(): Promise<IDBDatabase> {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, DB_VERSION)

    request.onerror = () => {
      reject(request.error)
    }

    request.onsuccess = () => {
      resolve(request.result)
    }

    request.onupgradeneeded = (event) => {
      const db = (event.target as IDBOpenDBRequest).result
      if (!db.objectStoreNames.contains(STORE_NAME)) {
        db.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true })
      }
    }
  })
}

/**
 * Queue a test submission for later sync
 * @param test Test data to queue (id will be auto-generated by IndexedDB)
 */
export async function queueTestSubmission(test: Omit<ControlTest, 'id'>): Promise<void> {
  const db = await openDB()

  return new Promise((resolve, reject) => {
    const transaction = db.transaction(STORE_NAME, 'readwrite')
    const store = transaction.objectStore(STORE_NAME)

    const entry = {
      ...test,
      queuedAt: new Date().toISOString(),
    }

    const request = store.add(entry)

    request.onerror = () => {
      reject(request.error)
    }

    request.onsuccess = () => {
      resolve()
    }

    transaction.oncomplete = () => {
      db.close()
    }
  })
}

/**
 * Get all pending test submissions from the queue
 * @returns Array of pending tests with their IndexedDB ids
 */
export async function getPendingTests(): Promise<PendingTest[]> {
  const db = await openDB()

  return new Promise((resolve, reject) => {
    const transaction = db.transaction(STORE_NAME, 'readonly')
    const store = transaction.objectStore(STORE_NAME)
    const request = store.getAll()

    request.onerror = () => {
      reject(request.error)
    }

    request.onsuccess = () => {
      resolve(request.result as PendingTest[])
    }

    transaction.oncomplete = () => {
      db.close()
    }
  })
}

/**
 * Clear a pending test after successful sync
 * @param id IndexedDB id of the entry to remove
 */
export async function clearPendingTest(id: number): Promise<void> {
  const db = await openDB()

  return new Promise((resolve, reject) => {
    const transaction = db.transaction(STORE_NAME, 'readwrite')
    const store = transaction.objectStore(STORE_NAME)
    const request = store.delete(id)

    request.onerror = () => {
      reject(request.error)
    }

    request.onsuccess = () => {
      resolve()
    }

    transaction.oncomplete = () => {
      db.close()
    }
  })
}

/**
 * Get count of pending tests in the queue
 * @returns Number of pending test submissions
 */
export async function getPendingCount(): Promise<number> {
  const db = await openDB()

  return new Promise((resolve, reject) => {
    const transaction = db.transaction(STORE_NAME, 'readonly')
    const store = transaction.objectStore(STORE_NAME)
    const request = store.count()

    request.onerror = () => {
      reject(request.error)
    }

    request.onsuccess = () => {
      resolve(request.result)
    }

    transaction.oncomplete = () => {
      db.close()
    }
  })
}
