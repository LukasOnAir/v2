-- Migration: 00013_taxonomy_nodes.sql
-- Purpose: Create taxonomy_nodes table for hierarchical risk/process taxonomies
-- Phase: 26-shared-tenant-database
-- Dependencies: 00001_tenants.sql, 00002_rls_helper_functions.sql

-- TAXONOMY: Hierarchical tree with adjacency list + path cache
-- Stores both risk and process taxonomies in single table
CREATE TABLE public.taxonomy_nodes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES public.tenants(id) ON DELETE CASCADE,
  type TEXT NOT NULL CHECK (type IN ('risk', 'process')),
  parent_id UUID REFERENCES public.taxonomy_nodes(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  description TEXT DEFAULT '',
  hierarchical_id TEXT NOT NULL DEFAULT '',
  path UUID[] DEFAULT '{}',
  sort_order INT DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

COMMENT ON TABLE public.taxonomy_nodes IS 'Hierarchical taxonomy items for risk and process trees';
COMMENT ON COLUMN public.taxonomy_nodes.type IS 'Taxonomy type: risk or process';
COMMENT ON COLUMN public.taxonomy_nodes.parent_id IS 'Parent node ID for adjacency list hierarchy';
COMMENT ON COLUMN public.taxonomy_nodes.hierarchical_id IS 'Display ID in format 1.2.3 (generated by trigger)';
COMMENT ON COLUMN public.taxonomy_nodes.path IS 'Materialized path array for efficient ancestor queries';
COMMENT ON COLUMN public.taxonomy_nodes.sort_order IS 'Sort order among siblings';

-- Indexes (use subquery pattern for RLS performance)
CREATE INDEX idx_taxonomy_tenant_type ON public.taxonomy_nodes(tenant_id, type);
CREATE INDEX idx_taxonomy_parent ON public.taxonomy_nodes(parent_id);
CREATE INDEX idx_taxonomy_path ON public.taxonomy_nodes USING GIN(path);

-- RLS
ALTER TABLE public.taxonomy_nodes ENABLE ROW LEVEL SECURITY;

CREATE POLICY "taxonomy_tenant_isolation" ON public.taxonomy_nodes
  FOR ALL TO authenticated
  USING (tenant_id = (SELECT public.tenant_id()))
  WITH CHECK (tenant_id = (SELECT public.tenant_id()));

GRANT SELECT, INSERT, UPDATE, DELETE ON public.taxonomy_nodes TO authenticated;

-- Generate hierarchical ID based on sibling count and parent path
CREATE OR REPLACE FUNCTION generate_hierarchical_id()
RETURNS TRIGGER AS $$
DECLARE
  parent_hid TEXT;
  sibling_count INT;
BEGIN
  -- Get parent's hierarchical_id
  IF NEW.parent_id IS NULL THEN
    parent_hid := '';
  ELSE
    SELECT hierarchical_id INTO parent_hid
    FROM public.taxonomy_nodes
    WHERE id = NEW.parent_id;
  END IF;

  -- Count siblings (same parent, same tenant, same type)
  SELECT COUNT(*) INTO sibling_count
  FROM public.taxonomy_nodes
  WHERE tenant_id = NEW.tenant_id
    AND type = NEW.type
    AND COALESCE(parent_id::text, '') = COALESCE(NEW.parent_id::text, '')
    AND id != NEW.id;

  -- Generate hierarchical_id
  IF parent_hid = '' OR parent_hid IS NULL THEN
    NEW.hierarchical_id := (sibling_count + 1)::TEXT;
  ELSE
    NEW.hierarchical_id := parent_hid || '.' || (sibling_count + 1)::TEXT;
  END IF;

  -- Update path array
  IF NEW.parent_id IS NULL THEN
    NEW.path := ARRAY[NEW.id];
  ELSE
    SELECT path || NEW.id INTO NEW.path
    FROM public.taxonomy_nodes
    WHERE id = NEW.parent_id;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION generate_hierarchical_id() IS 'Trigger function to auto-generate hierarchical_id and path on taxonomy node insert';

CREATE TRIGGER trg_taxonomy_hierarchical_id
  BEFORE INSERT ON public.taxonomy_nodes
  FOR EACH ROW
  EXECUTE FUNCTION generate_hierarchical_id();

-- Updated_at trigger
CREATE OR REPLACE FUNCTION update_taxonomy_timestamp()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at := NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_taxonomy_updated_at
  BEFORE UPDATE ON public.taxonomy_nodes
  FOR EACH ROW
  EXECUTE FUNCTION update_taxonomy_timestamp();
